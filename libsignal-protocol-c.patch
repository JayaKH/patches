From 864fa77f9cd31d65f7ba899819f3605009d202f8 Mon Sep 17 00:00:00 2001
From: WhatsApp Security <security@whatsapp.com>
Date: Thu, 2 Mar 2017 09:48:10 -0800
Subject: [PATCH] Changes to libsignal-protocol-c from Open Whisper Systems

Copyright (C) 2017 WhatsApp Inc. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
---
 protobuf/LocalStorageProtocol.proto         |   10 +
 protobuf/WhisperTextProtocol.proto          |    7 +
 src/CMakeLists.txt                          |   19 +
 src/LocalStorageProtocol.pb-c.c             |  188 ++++
 src/LocalStorageProtocol.pb-c.h             |   75 +-
 src/WhisperTextProtocol.pb-c.c              |  120 +++
 src/WhisperTextProtocol.pb-c.h              |   43 +-
 src/fast_ratchet_group_cipher.c             |  309 ++++++
 src/fast_ratchet_group_cipher.h             |  115 +++
 src/fast_ratchet_group_session_builder.c    |  185 ++++
 src/fast_ratchet_group_session_builder.h    |   73 ++
 src/fast_ratchet_sender_key.c               |  376 +++++++
 src/fast_ratchet_sender_key.h               |   32 +
 src/fast_ratchet_sender_key_record.c        |  343 +++++++
 src/fast_ratchet_sender_key_record.h        |   30 +
 src/fast_ratchet_sender_key_state.c         |  429 ++++++++
 src/fast_ratchet_sender_key_state.h         |   31 +
 src/fast_ratchet_util.c                     |   62 ++
 src/fast_ratchet_util.h                     |   45 +
 src/protocol.c                              |  325 ++++++
 src/protocol.h                              |   30 +-
 src/sender_key.c                            |    4 +-
 src/sender_key_internal.h                   |    7 +
 src/signal_protocol.c                       |   87 +-
 src/signal_protocol.h                       |   47 +
 src/signal_protocol_internal.h              |    4 +
 src/signal_protocol_types.h                 |   10 +
 tests/CMakeLists.txt                        |   12 +
 tests/test_common.c                         |   16 +
 tests/test_common.h                         |    3 +
 tests/test_fast_ratchet_group_cipher.c      | 1480 +++++++++++++++++++++++++++
 tests/test_fast_ratchet_sender_key_record.c |  345 +++++++
 tests/test_fast_ratchet_util.c              |  188 ++++
 tests/test_protocol.c                       |   71 ++
 34 files changed, 5109 insertions(+), 12 deletions(-)
 create mode 100644 src/fast_ratchet_group_cipher.c
 create mode 100644 src/fast_ratchet_group_cipher.h
 create mode 100644 src/fast_ratchet_group_session_builder.c
 create mode 100644 src/fast_ratchet_group_session_builder.h
 create mode 100644 src/fast_ratchet_sender_key.c
 create mode 100644 src/fast_ratchet_sender_key.h
 create mode 100644 src/fast_ratchet_sender_key_record.c
 create mode 100644 src/fast_ratchet_sender_key_record.h
 create mode 100644 src/fast_ratchet_sender_key_state.c
 create mode 100644 src/fast_ratchet_sender_key_state.h
 create mode 100644 src/fast_ratchet_util.c
 create mode 100644 src/fast_ratchet_util.h
 create mode 100644 src/sender_key_internal.h
 create mode 100644 tests/test_fast_ratchet_group_cipher.c
 create mode 100644 tests/test_fast_ratchet_sender_key_record.c
 create mode 100644 tests/test_fast_ratchet_util.c

diff --git a/protobuf/LocalStorageProtocol.proto b/protobuf/LocalStorageProtocol.proto
index 7de2f19..88117a5 100644
--- a/protobuf/LocalStorageProtocol.proto
+++ b/protobuf/LocalStorageProtocol.proto
@@ -109,4 +109,14 @@ message SenderKeyStateStructure {
 
 message SenderKeyRecordStructure {
     repeated SenderKeyStateStructure senderKeyStates = 1;
+}
+
+message FastRatchetSenderKeyStateStructure {
+    optional uint32                                   senderKeyId       = 1;
+    repeated SenderKeyStateStructure.SenderChainKey   senderChainKeys   = 2;
+    optional SenderKeyStateStructure.SenderSigningKey senderSigningKey  = 3;
+}
+
+message FastRatchetSenderKeyRecordStructure {
+    repeated FastRatchetSenderKeyStateStructure senderKeyStates = 1;
 }
\ No newline at end of file
diff --git a/protobuf/WhisperTextProtocol.proto b/protobuf/WhisperTextProtocol.proto
index f6a3c95..241c260 100644
--- a/protobuf/WhisperTextProtocol.proto
+++ b/protobuf/WhisperTextProtocol.proto
@@ -40,6 +40,13 @@ message SenderKeyDistributionMessage {
   optional bytes  signingKey = 4;
 }
 
+message FastRatchetSenderKeyDistributionMessage {
+  optional uint32 id         = 1;
+  optional uint32 iteration  = 2;
+  repeated bytes  chainKeys  = 3;
+  optional bytes  signingKey = 4;
+}
+
 message DeviceConsistencyCodeMessage {
   optional uint32 generation = 1;
   optional bytes  signature  = 2;
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 54a24d0..97211f1 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -43,6 +43,7 @@ set(signal_protocol_SRCS
 	key_helper.h
 	sender_key.c
 	sender_key.h
+	sender_key_internal.h
 	sender_key_state.c
 	sender_key_state.h
 	sender_key_record.c
@@ -55,6 +56,18 @@ set(signal_protocol_SRCS
 	fingerprint.h
 	device_consistency.c
 	device_consistency.h
+	fast_ratchet_util.c
+	fast_ratchet_util.h
+	fast_ratchet_sender_key.c
+	fast_ratchet_sender_key.h
+	fast_ratchet_sender_key_state.c
+	fast_ratchet_sender_key_state.h
+	fast_ratchet_sender_key_record.c
+	fast_ratchet_sender_key_record.h
+	fast_ratchet_group_session_builder.c
+	fast_ratchet_group_session_builder.h
+	fast_ratchet_group_cipher.c
+	fast_ratchet_group_cipher.h
 )
 
 add_subdirectory(curve25519)
@@ -88,6 +101,12 @@ INSTALL(
 	group_cipher.h
 	fingerprint.h
 	device_consistency.h
+	fast_ratchet_util.h
+	fast_ratchet_sender_key.h
+	fast_ratchet_sender_key_state.h
+	fast_ratchet_sender_key_record.h
+	fast_ratchet_group_session_builder.h
+	fast_ratchet_group_cipher.h
 	DESTINATION ${INCLUDE_INSTALL_DIR}/signal
 )
 
diff --git a/src/LocalStorageProtocol.pb-c.c b/src/LocalStorageProtocol.pb-c.c
index afe0171..2bd7c4f 100644
--- a/src/LocalStorageProtocol.pb-c.c
+++ b/src/LocalStorageProtocol.pb-c.c
@@ -356,6 +356,92 @@ void   textsecure__sender_key_record_structure__free_unpacked
   assert(message->base.descriptor == &textsecure__sender_key_record_structure__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
+void   textsecure__fast_ratchet_sender_key_state_structure__init
+                     (Textsecure__FastRatchetSenderKeyStateStructure         *message)
+{
+  static Textsecure__FastRatchetSenderKeyStateStructure init_value = TEXTSECURE__FAST_RATCHET_SENDER_KEY_STATE_STRUCTURE__INIT;
+  *message = init_value;
+}
+size_t textsecure__fast_ratchet_sender_key_state_structure__get_packed_size
+                     (const Textsecure__FastRatchetSenderKeyStateStructure *message)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_state_structure__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t textsecure__fast_ratchet_sender_key_state_structure__pack
+                     (const Textsecure__FastRatchetSenderKeyStateStructure *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_state_structure__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t textsecure__fast_ratchet_sender_key_state_structure__pack_to_buffer
+                     (const Textsecure__FastRatchetSenderKeyStateStructure *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_state_structure__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Textsecure__FastRatchetSenderKeyStateStructure *
+       textsecure__fast_ratchet_sender_key_state_structure__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Textsecure__FastRatchetSenderKeyStateStructure *)
+     protobuf_c_message_unpack (&textsecure__fast_ratchet_sender_key_state_structure__descriptor,
+                                allocator, len, data);
+}
+void   textsecure__fast_ratchet_sender_key_state_structure__free_unpacked
+                     (Textsecure__FastRatchetSenderKeyStateStructure *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_state_structure__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
+void   textsecure__fast_ratchet_sender_key_record_structure__init
+                     (Textsecure__FastRatchetSenderKeyRecordStructure         *message)
+{
+  static Textsecure__FastRatchetSenderKeyRecordStructure init_value = TEXTSECURE__FAST_RATCHET_SENDER_KEY_RECORD_STRUCTURE__INIT;
+  *message = init_value;
+}
+size_t textsecure__fast_ratchet_sender_key_record_structure__get_packed_size
+                     (const Textsecure__FastRatchetSenderKeyRecordStructure *message)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_record_structure__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t textsecure__fast_ratchet_sender_key_record_structure__pack
+                     (const Textsecure__FastRatchetSenderKeyRecordStructure *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_record_structure__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t textsecure__fast_ratchet_sender_key_record_structure__pack_to_buffer
+                     (const Textsecure__FastRatchetSenderKeyRecordStructure *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_record_structure__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Textsecure__FastRatchetSenderKeyRecordStructure *
+       textsecure__fast_ratchet_sender_key_record_structure__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Textsecure__FastRatchetSenderKeyRecordStructure *)
+     protobuf_c_message_unpack (&textsecure__fast_ratchet_sender_key_record_structure__descriptor,
+                                allocator, len, data);
+}
+void   textsecure__fast_ratchet_sender_key_record_structure__free_unpacked
+                     (Textsecure__FastRatchetSenderKeyRecordStructure *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_record_structure__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
 static const ProtobufCFieldDescriptor textsecure__session_structure__chain__chain_key__field_descriptors[2] =
 {
   {
@@ -1460,3 +1546,105 @@ const ProtobufCMessageDescriptor textsecure__sender_key_record_structure__descri
   (ProtobufCMessageInit) textsecure__sender_key_record_structure__init,
   NULL,NULL,NULL    /* reserved[123] */
 };
+static const ProtobufCFieldDescriptor textsecure__fast_ratchet_sender_key_state_structure__field_descriptors[3] =
+{
+  {
+    "senderKeyId",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Textsecure__FastRatchetSenderKeyStateStructure, has_senderkeyid),
+    offsetof(Textsecure__FastRatchetSenderKeyStateStructure, senderkeyid),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "senderChainKeys",
+    2,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(Textsecure__FastRatchetSenderKeyStateStructure, n_senderchainkeys),
+    offsetof(Textsecure__FastRatchetSenderKeyStateStructure, senderchainkeys),
+    &textsecure__sender_key_state_structure__sender_chain_key__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "senderSigningKey",
+    3,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_MESSAGE,
+    0,   /* quantifier_offset */
+    offsetof(Textsecure__FastRatchetSenderKeyStateStructure, sendersigningkey),
+    &textsecure__sender_key_state_structure__sender_signing_key__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned textsecure__fast_ratchet_sender_key_state_structure__field_indices_by_name[] = {
+  1,   /* field[1] = senderChainKeys */
+  0,   /* field[0] = senderKeyId */
+  2,   /* field[2] = senderSigningKey */
+};
+static const ProtobufCIntRange textsecure__fast_ratchet_sender_key_state_structure__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 3 }
+};
+const ProtobufCMessageDescriptor textsecure__fast_ratchet_sender_key_state_structure__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "textsecure.FastRatchetSenderKeyStateStructure",
+  "FastRatchetSenderKeyStateStructure",
+  "Textsecure__FastRatchetSenderKeyStateStructure",
+  "textsecure",
+  sizeof(Textsecure__FastRatchetSenderKeyStateStructure),
+  3,
+  textsecure__fast_ratchet_sender_key_state_structure__field_descriptors,
+  textsecure__fast_ratchet_sender_key_state_structure__field_indices_by_name,
+  1,  textsecure__fast_ratchet_sender_key_state_structure__number_ranges,
+  (ProtobufCMessageInit) textsecure__fast_ratchet_sender_key_state_structure__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
+static const ProtobufCFieldDescriptor textsecure__fast_ratchet_sender_key_record_structure__field_descriptors[1] =
+{
+  {
+    "senderKeyStates",
+    1,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_MESSAGE,
+    offsetof(Textsecure__FastRatchetSenderKeyRecordStructure, n_senderkeystates),
+    offsetof(Textsecure__FastRatchetSenderKeyRecordStructure, senderkeystates),
+    &textsecure__fast_ratchet_sender_key_state_structure__descriptor,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned textsecure__fast_ratchet_sender_key_record_structure__field_indices_by_name[] = {
+  0,   /* field[0] = senderKeyStates */
+};
+static const ProtobufCIntRange textsecure__fast_ratchet_sender_key_record_structure__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 1 }
+};
+const ProtobufCMessageDescriptor textsecure__fast_ratchet_sender_key_record_structure__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "textsecure.FastRatchetSenderKeyRecordStructure",
+  "FastRatchetSenderKeyRecordStructure",
+  "Textsecure__FastRatchetSenderKeyRecordStructure",
+  "textsecure",
+  sizeof(Textsecure__FastRatchetSenderKeyRecordStructure),
+  1,
+  textsecure__fast_ratchet_sender_key_record_structure__field_descriptors,
+  textsecure__fast_ratchet_sender_key_record_structure__field_indices_by_name,
+  1,  textsecure__fast_ratchet_sender_key_record_structure__number_ranges,
+  (ProtobufCMessageInit) textsecure__fast_ratchet_sender_key_record_structure__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
diff --git a/src/LocalStorageProtocol.pb-c.h b/src/LocalStorageProtocol.pb-c.h
index cbf2532..5a4bfe6 100644
--- a/src/LocalStorageProtocol.pb-c.h
+++ b/src/LocalStorageProtocol.pb-c.h
@@ -10,7 +10,7 @@ PROTOBUF_C__BEGIN_DECLS
 
 #if PROTOBUF_C_VERSION_NUMBER < 1000000
 # error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
-#elif 1001001 < PROTOBUF_C_MIN_COMPILER_VERSION
+#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
 # error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
 #endif
 
@@ -30,6 +30,8 @@ typedef struct _Textsecure__SenderKeyStateStructure__SenderChainKey Textsecure__
 typedef struct _Textsecure__SenderKeyStateStructure__SenderMessageKey Textsecure__SenderKeyStateStructure__SenderMessageKey;
 typedef struct _Textsecure__SenderKeyStateStructure__SenderSigningKey Textsecure__SenderKeyStateStructure__SenderSigningKey;
 typedef struct _Textsecure__SenderKeyRecordStructure Textsecure__SenderKeyRecordStructure;
+typedef struct _Textsecure__FastRatchetSenderKeyStateStructure Textsecure__FastRatchetSenderKeyStateStructure;
+typedef struct _Textsecure__FastRatchetSenderKeyRecordStructure Textsecure__FastRatchetSenderKeyRecordStructure;
 
 
 /* --- enums --- */
@@ -277,6 +279,31 @@ struct  _Textsecure__SenderKeyRecordStructure
     , 0,NULL }
 
 
+struct  _Textsecure__FastRatchetSenderKeyStateStructure
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_senderkeyid;
+  uint32_t senderkeyid;
+  size_t n_senderchainkeys;
+  Textsecure__SenderKeyStateStructure__SenderChainKey **senderchainkeys;
+  Textsecure__SenderKeyStateStructure__SenderSigningKey *sendersigningkey;
+};
+#define TEXTSECURE__FAST_RATCHET_SENDER_KEY_STATE_STRUCTURE__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&textsecure__fast_ratchet_sender_key_state_structure__descriptor) \
+    , 0,0, 0,NULL, NULL }
+
+
+struct  _Textsecure__FastRatchetSenderKeyRecordStructure
+{
+  ProtobufCMessage base;
+  size_t n_senderkeystates;
+  Textsecure__FastRatchetSenderKeyStateStructure **senderkeystates;
+};
+#define TEXTSECURE__FAST_RATCHET_SENDER_KEY_RECORD_STRUCTURE__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&textsecure__fast_ratchet_sender_key_record_structure__descriptor) \
+    , 0,NULL }
+
+
 /* Textsecure__SessionStructure__Chain__ChainKey methods */
 void   textsecure__session_structure__chain__chain_key__init
                      (Textsecure__SessionStructure__Chain__ChainKey         *message);
@@ -434,6 +461,44 @@ Textsecure__SenderKeyRecordStructure *
 void   textsecure__sender_key_record_structure__free_unpacked
                      (Textsecure__SenderKeyRecordStructure *message,
                       ProtobufCAllocator *allocator);
+/* Textsecure__FastRatchetSenderKeyStateStructure methods */
+void   textsecure__fast_ratchet_sender_key_state_structure__init
+                     (Textsecure__FastRatchetSenderKeyStateStructure         *message);
+size_t textsecure__fast_ratchet_sender_key_state_structure__get_packed_size
+                     (const Textsecure__FastRatchetSenderKeyStateStructure   *message);
+size_t textsecure__fast_ratchet_sender_key_state_structure__pack
+                     (const Textsecure__FastRatchetSenderKeyStateStructure   *message,
+                      uint8_t             *out);
+size_t textsecure__fast_ratchet_sender_key_state_structure__pack_to_buffer
+                     (const Textsecure__FastRatchetSenderKeyStateStructure   *message,
+                      ProtobufCBuffer     *buffer);
+Textsecure__FastRatchetSenderKeyStateStructure *
+       textsecure__fast_ratchet_sender_key_state_structure__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   textsecure__fast_ratchet_sender_key_state_structure__free_unpacked
+                     (Textsecure__FastRatchetSenderKeyStateStructure *message,
+                      ProtobufCAllocator *allocator);
+/* Textsecure__FastRatchetSenderKeyRecordStructure methods */
+void   textsecure__fast_ratchet_sender_key_record_structure__init
+                     (Textsecure__FastRatchetSenderKeyRecordStructure         *message);
+size_t textsecure__fast_ratchet_sender_key_record_structure__get_packed_size
+                     (const Textsecure__FastRatchetSenderKeyRecordStructure   *message);
+size_t textsecure__fast_ratchet_sender_key_record_structure__pack
+                     (const Textsecure__FastRatchetSenderKeyRecordStructure   *message,
+                      uint8_t             *out);
+size_t textsecure__fast_ratchet_sender_key_record_structure__pack_to_buffer
+                     (const Textsecure__FastRatchetSenderKeyRecordStructure   *message,
+                      ProtobufCBuffer     *buffer);
+Textsecure__FastRatchetSenderKeyRecordStructure *
+       textsecure__fast_ratchet_sender_key_record_structure__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   textsecure__fast_ratchet_sender_key_record_structure__free_unpacked
+                     (Textsecure__FastRatchetSenderKeyRecordStructure *message,
+                      ProtobufCAllocator *allocator);
 /* --- per-message closures --- */
 
 typedef void (*Textsecure__SessionStructure__Chain__ChainKey_Closure)
@@ -481,6 +546,12 @@ typedef void (*Textsecure__SenderKeyStateStructure_Closure)
 typedef void (*Textsecure__SenderKeyRecordStructure_Closure)
                  (const Textsecure__SenderKeyRecordStructure *message,
                   void *closure_data);
+typedef void (*Textsecure__FastRatchetSenderKeyStateStructure_Closure)
+                 (const Textsecure__FastRatchetSenderKeyStateStructure *message,
+                  void *closure_data);
+typedef void (*Textsecure__FastRatchetSenderKeyRecordStructure_Closure)
+                 (const Textsecure__FastRatchetSenderKeyRecordStructure *message,
+                  void *closure_data);
 
 /* --- services --- */
 
@@ -502,6 +573,8 @@ extern const ProtobufCMessageDescriptor textsecure__sender_key_state_structure__
 extern const ProtobufCMessageDescriptor textsecure__sender_key_state_structure__sender_message_key__descriptor;
 extern const ProtobufCMessageDescriptor textsecure__sender_key_state_structure__sender_signing_key__descriptor;
 extern const ProtobufCMessageDescriptor textsecure__sender_key_record_structure__descriptor;
+extern const ProtobufCMessageDescriptor textsecure__fast_ratchet_sender_key_state_structure__descriptor;
+extern const ProtobufCMessageDescriptor textsecure__fast_ratchet_sender_key_record_structure__descriptor;
 
 PROTOBUF_C__END_DECLS
 
diff --git a/src/WhisperTextProtocol.pb-c.c b/src/WhisperTextProtocol.pb-c.c
index f73c064..4ccd6ba 100644
--- a/src/WhisperTextProtocol.pb-c.c
+++ b/src/WhisperTextProtocol.pb-c.c
@@ -222,6 +222,49 @@ void   textsecure__sender_key_distribution_message__free_unpacked
   assert(message->base.descriptor == &textsecure__sender_key_distribution_message__descriptor);
   protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
 }
+void   textsecure__fast_ratchet_sender_key_distribution_message__init
+                     (Textsecure__FastRatchetSenderKeyDistributionMessage         *message)
+{
+  static Textsecure__FastRatchetSenderKeyDistributionMessage init_value = TEXTSECURE__FAST_RATCHET_SENDER_KEY_DISTRIBUTION_MESSAGE__INIT;
+  *message = init_value;
+}
+size_t textsecure__fast_ratchet_sender_key_distribution_message__get_packed_size
+                     (const Textsecure__FastRatchetSenderKeyDistributionMessage *message)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_distribution_message__descriptor);
+  return protobuf_c_message_get_packed_size ((const ProtobufCMessage*)(message));
+}
+size_t textsecure__fast_ratchet_sender_key_distribution_message__pack
+                     (const Textsecure__FastRatchetSenderKeyDistributionMessage *message,
+                      uint8_t       *out)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_distribution_message__descriptor);
+  return protobuf_c_message_pack ((const ProtobufCMessage*)message, out);
+}
+size_t textsecure__fast_ratchet_sender_key_distribution_message__pack_to_buffer
+                     (const Textsecure__FastRatchetSenderKeyDistributionMessage *message,
+                      ProtobufCBuffer *buffer)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_distribution_message__descriptor);
+  return protobuf_c_message_pack_to_buffer ((const ProtobufCMessage*)message, buffer);
+}
+Textsecure__FastRatchetSenderKeyDistributionMessage *
+       textsecure__fast_ratchet_sender_key_distribution_message__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data)
+{
+  return (Textsecure__FastRatchetSenderKeyDistributionMessage *)
+     protobuf_c_message_unpack (&textsecure__fast_ratchet_sender_key_distribution_message__descriptor,
+                                allocator, len, data);
+}
+void   textsecure__fast_ratchet_sender_key_distribution_message__free_unpacked
+                     (Textsecure__FastRatchetSenderKeyDistributionMessage *message,
+                      ProtobufCAllocator *allocator)
+{
+  assert(message->base.descriptor == &textsecure__fast_ratchet_sender_key_distribution_message__descriptor);
+  protobuf_c_message_free_unpacked ((ProtobufCMessage*)message, allocator);
+}
 void   textsecure__device_consistency_code_message__init
                      (Textsecure__DeviceConsistencyCodeMessage         *message)
 {
@@ -676,6 +719,83 @@ const ProtobufCMessageDescriptor textsecure__sender_key_distribution_message__de
   (ProtobufCMessageInit) textsecure__sender_key_distribution_message__init,
   NULL,NULL,NULL    /* reserved[123] */
 };
+static const ProtobufCFieldDescriptor textsecure__fast_ratchet_sender_key_distribution_message__field_descriptors[4] =
+{
+  {
+    "id",
+    1,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Textsecure__FastRatchetSenderKeyDistributionMessage, has_id),
+    offsetof(Textsecure__FastRatchetSenderKeyDistributionMessage, id),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "iteration",
+    2,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_UINT32,
+    offsetof(Textsecure__FastRatchetSenderKeyDistributionMessage, has_iteration),
+    offsetof(Textsecure__FastRatchetSenderKeyDistributionMessage, iteration),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "chainKeys",
+    3,
+    PROTOBUF_C_LABEL_REPEATED,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Textsecure__FastRatchetSenderKeyDistributionMessage, n_chainkeys),
+    offsetof(Textsecure__FastRatchetSenderKeyDistributionMessage, chainkeys),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+  {
+    "signingKey",
+    4,
+    PROTOBUF_C_LABEL_OPTIONAL,
+    PROTOBUF_C_TYPE_BYTES,
+    offsetof(Textsecure__FastRatchetSenderKeyDistributionMessage, has_signingkey),
+    offsetof(Textsecure__FastRatchetSenderKeyDistributionMessage, signingkey),
+    NULL,
+    NULL,
+    0,             /* flags */
+    0,NULL,NULL    /* reserved1,reserved2, etc */
+  },
+};
+static const unsigned textsecure__fast_ratchet_sender_key_distribution_message__field_indices_by_name[] = {
+  2,   /* field[2] = chainKeys */
+  0,   /* field[0] = id */
+  1,   /* field[1] = iteration */
+  3,   /* field[3] = signingKey */
+};
+static const ProtobufCIntRange textsecure__fast_ratchet_sender_key_distribution_message__number_ranges[1 + 1] =
+{
+  { 1, 0 },
+  { 0, 4 }
+};
+const ProtobufCMessageDescriptor textsecure__fast_ratchet_sender_key_distribution_message__descriptor =
+{
+  PROTOBUF_C__MESSAGE_DESCRIPTOR_MAGIC,
+  "textsecure.FastRatchetSenderKeyDistributionMessage",
+  "FastRatchetSenderKeyDistributionMessage",
+  "Textsecure__FastRatchetSenderKeyDistributionMessage",
+  "textsecure",
+  sizeof(Textsecure__FastRatchetSenderKeyDistributionMessage),
+  4,
+  textsecure__fast_ratchet_sender_key_distribution_message__field_descriptors,
+  textsecure__fast_ratchet_sender_key_distribution_message__field_indices_by_name,
+  1,  textsecure__fast_ratchet_sender_key_distribution_message__number_ranges,
+  (ProtobufCMessageInit) textsecure__fast_ratchet_sender_key_distribution_message__init,
+  NULL,NULL,NULL    /* reserved[123] */
+};
 static const ProtobufCFieldDescriptor textsecure__device_consistency_code_message__field_descriptors[2] =
 {
   {
diff --git a/src/WhisperTextProtocol.pb-c.h b/src/WhisperTextProtocol.pb-c.h
index 8dab74a..cf19c2c 100644
--- a/src/WhisperTextProtocol.pb-c.h
+++ b/src/WhisperTextProtocol.pb-c.h
@@ -10,7 +10,7 @@ PROTOBUF_C__BEGIN_DECLS
 
 #if PROTOBUF_C_VERSION_NUMBER < 1000000
 # error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
-#elif 1001001 < PROTOBUF_C_MIN_COMPILER_VERSION
+#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
 # error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
 #endif
 
@@ -20,6 +20,7 @@ typedef struct _Textsecure__PreKeySignalMessage Textsecure__PreKeySignalMessage;
 typedef struct _Textsecure__KeyExchangeMessage Textsecure__KeyExchangeMessage;
 typedef struct _Textsecure__SenderKeyMessage Textsecure__SenderKeyMessage;
 typedef struct _Textsecure__SenderKeyDistributionMessage Textsecure__SenderKeyDistributionMessage;
+typedef struct _Textsecure__FastRatchetSenderKeyDistributionMessage Textsecure__FastRatchetSenderKeyDistributionMessage;
 typedef struct _Textsecure__DeviceConsistencyCodeMessage Textsecure__DeviceConsistencyCodeMessage;
 
 
@@ -120,6 +121,23 @@ struct  _Textsecure__SenderKeyDistributionMessage
     , 0,0, 0,0, 0,{0,NULL}, 0,{0,NULL} }
 
 
+struct  _Textsecure__FastRatchetSenderKeyDistributionMessage
+{
+  ProtobufCMessage base;
+  protobuf_c_boolean has_id;
+  uint32_t id;
+  protobuf_c_boolean has_iteration;
+  uint32_t iteration;
+  size_t n_chainkeys;
+  ProtobufCBinaryData *chainkeys;
+  protobuf_c_boolean has_signingkey;
+  ProtobufCBinaryData signingkey;
+};
+#define TEXTSECURE__FAST_RATCHET_SENDER_KEY_DISTRIBUTION_MESSAGE__INIT \
+ { PROTOBUF_C_MESSAGE_INIT (&textsecure__fast_ratchet_sender_key_distribution_message__descriptor) \
+    , 0,0, 0,0, 0,NULL, 0,{0,NULL} }
+
+
 struct  _Textsecure__DeviceConsistencyCodeMessage
 {
   ProtobufCMessage base;
@@ -228,6 +246,25 @@ Textsecure__SenderKeyDistributionMessage *
 void   textsecure__sender_key_distribution_message__free_unpacked
                      (Textsecure__SenderKeyDistributionMessage *message,
                       ProtobufCAllocator *allocator);
+/* Textsecure__FastRatchetSenderKeyDistributionMessage methods */
+void   textsecure__fast_ratchet_sender_key_distribution_message__init
+                     (Textsecure__FastRatchetSenderKeyDistributionMessage         *message);
+size_t textsecure__fast_ratchet_sender_key_distribution_message__get_packed_size
+                     (const Textsecure__FastRatchetSenderKeyDistributionMessage   *message);
+size_t textsecure__fast_ratchet_sender_key_distribution_message__pack
+                     (const Textsecure__FastRatchetSenderKeyDistributionMessage   *message,
+                      uint8_t             *out);
+size_t textsecure__fast_ratchet_sender_key_distribution_message__pack_to_buffer
+                     (const Textsecure__FastRatchetSenderKeyDistributionMessage   *message,
+                      ProtobufCBuffer     *buffer);
+Textsecure__FastRatchetSenderKeyDistributionMessage *
+       textsecure__fast_ratchet_sender_key_distribution_message__unpack
+                     (ProtobufCAllocator  *allocator,
+                      size_t               len,
+                      const uint8_t       *data);
+void   textsecure__fast_ratchet_sender_key_distribution_message__free_unpacked
+                     (Textsecure__FastRatchetSenderKeyDistributionMessage *message,
+                      ProtobufCAllocator *allocator);
 /* Textsecure__DeviceConsistencyCodeMessage methods */
 void   textsecure__device_consistency_code_message__init
                      (Textsecure__DeviceConsistencyCodeMessage         *message);
@@ -264,6 +301,9 @@ typedef void (*Textsecure__SenderKeyMessage_Closure)
 typedef void (*Textsecure__SenderKeyDistributionMessage_Closure)
                  (const Textsecure__SenderKeyDistributionMessage *message,
                   void *closure_data);
+typedef void (*Textsecure__FastRatchetSenderKeyDistributionMessage_Closure)
+                 (const Textsecure__FastRatchetSenderKeyDistributionMessage *message,
+                  void *closure_data);
 typedef void (*Textsecure__DeviceConsistencyCodeMessage_Closure)
                  (const Textsecure__DeviceConsistencyCodeMessage *message,
                   void *closure_data);
@@ -278,6 +318,7 @@ extern const ProtobufCMessageDescriptor textsecure__pre_key_signal_message__desc
 extern const ProtobufCMessageDescriptor textsecure__key_exchange_message__descriptor;
 extern const ProtobufCMessageDescriptor textsecure__sender_key_message__descriptor;
 extern const ProtobufCMessageDescriptor textsecure__sender_key_distribution_message__descriptor;
+extern const ProtobufCMessageDescriptor textsecure__fast_ratchet_sender_key_distribution_message__descriptor;
 extern const ProtobufCMessageDescriptor textsecure__device_consistency_code_message__descriptor;
 
 PROTOBUF_C__END_DECLS
diff --git a/src/fast_ratchet_group_cipher.c b/src/fast_ratchet_group_cipher.c
new file mode 100644
index 0000000..addffac
--- /dev/null
+++ b/src/fast_ratchet_group_cipher.c
@@ -0,0 +1,309 @@
+#include "fast_ratchet_group_cipher.h"
+
+#include <assert.h>
+#include <string.h>
+#include "protocol.h"
+#include "sender_key.h"
+#include "fast_ratchet_sender_key.h"
+#include "fast_ratchet_sender_key_record.h"
+#include "fast_ratchet_sender_key_state.h"
+#include "signal_protocol_internal.h"
+
+struct fast_ratchet_group_cipher
+{
+    signal_protocol_store_context *store;
+    const signal_protocol_sender_key_name *sender_key_id;
+    signal_context *global_context;
+    int (*decrypt_callback)(fast_ratchet_group_cipher *cipher, signal_buffer *plaintext, void *decrypt_context);
+    int inside_callback;
+    void *user_data;
+};
+
+static int fast_ratchet_group_cipher_get_sender_key(fast_ratchet_group_cipher *cipher,
+        sender_message_key **sender_key, fast_ratchet_sender_key_state *state, uint32_t iteration);
+static int fast_ratchet_group_cipher_decrypt_callback(fast_ratchet_group_cipher *cipher,
+        signal_buffer *plaintext, void *decrypt_context);
+
+int fast_ratchet_group_cipher_create(fast_ratchet_group_cipher **cipher,
+        signal_protocol_store_context *store, const signal_protocol_sender_key_name *sender_key_id,
+        signal_context *global_context)
+{
+    fast_ratchet_group_cipher *result_cipher;
+
+    assert(store);
+    assert(global_context);
+
+    result_cipher = malloc(sizeof(fast_ratchet_group_cipher));
+    if(!result_cipher) {
+        return SG_ERR_NOMEM;
+    }
+    memset(result_cipher, 0, sizeof(fast_ratchet_group_cipher));
+
+    result_cipher->store = store;
+    result_cipher->sender_key_id = sender_key_id;
+    result_cipher->global_context = global_context;
+
+    *cipher = result_cipher;
+    return 0;
+}
+
+void fast_ratchet_group_cipher_set_user_data(fast_ratchet_group_cipher *cipher, void *user_data)
+{
+    assert(cipher);
+    cipher->user_data = user_data;
+}
+
+void *fast_ratchet_group_cipher_get_user_data(fast_ratchet_group_cipher *cipher)
+{
+    assert(cipher);
+    return cipher->user_data;
+}
+
+void fast_ratchet_group_cipher_set_decryption_callback(fast_ratchet_group_cipher *cipher,
+        int (*callback)(fast_ratchet_group_cipher *cipher, signal_buffer *plaintext, void *decrypt_context))
+{
+    assert(cipher);
+    cipher->decrypt_callback = callback;
+}
+
+int fast_ratchet_group_cipher_encrypt(fast_ratchet_group_cipher *cipher,
+        const uint8_t *padded_plaintext, size_t padded_plaintext_len,
+        ciphertext_message **encrypted_message)
+{
+    int result = 0;
+    sender_key_message *result_message = 0;
+    fast_ratchet_sender_key_record *record = 0;
+    fast_ratchet_sender_key_state *state = 0;
+    ec_private_key *signing_key_private = 0;
+    sender_message_key *sender_key = 0;
+    fast_ratchet_sender_chain_key *next_chain_key = 0;
+    signal_buffer *sender_cipher_key = 0;
+    signal_buffer *sender_cipher_iv = 0;
+    signal_buffer *ciphertext = 0;
+
+    assert(cipher);
+    signal_lock(cipher->global_context);
+
+    if(cipher->inside_callback == 1) {
+        result = SG_ERR_INVAL;
+        goto complete;
+    }
+
+    result = signal_protocol_fast_ratchet_sender_key_load_key(cipher->store, &record, cipher->sender_key_id);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fast_ratchet_sender_key_record_get_sender_key_state(record, &state);
+    if(result < 0) {
+        goto complete;
+    }
+
+    signing_key_private = fast_ratchet_sender_key_state_get_signing_key_private(state);
+    if(!signing_key_private) {
+        result = SG_ERR_INVALID_KEY;
+        goto complete;
+    }
+
+    result = fast_ratchet_sender_chain_key_create_message_key(fast_ratchet_sender_key_state_get_chain_key(state), &sender_key);
+    if(result < 0) {
+        goto complete;
+    }
+
+    sender_cipher_key = sender_message_key_get_cipher_key(sender_key);
+    sender_cipher_iv = sender_message_key_get_iv(sender_key);
+
+    result = signal_encrypt(cipher->global_context, &ciphertext, SG_CIPHER_AES_CBC_PKCS5,
+            signal_buffer_data(sender_cipher_key), signal_buffer_len(sender_cipher_key),
+            signal_buffer_data(sender_cipher_iv), signal_buffer_len(sender_cipher_iv),
+            padded_plaintext, padded_plaintext_len);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = sender_key_message_create(&result_message,
+            fast_ratchet_sender_key_state_get_key_id(state),
+            sender_message_key_get_iteration(sender_key),
+            signal_buffer_data(ciphertext), signal_buffer_len(ciphertext),
+            signing_key_private,
+            cipher->global_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fast_ratchet_sender_chain_key_create_next(fast_ratchet_sender_key_state_get_chain_key(state), &next_chain_key, 1);
+    if(result < 0) {
+        goto complete;
+    }
+
+    fast_ratchet_sender_key_state_set_chain_key(state, next_chain_key);
+
+    result = signal_protocol_fast_ratchet_sender_key_store_key(cipher->store, cipher->sender_key_id, record);
+
+complete:
+    if(result >= 0) {
+        *encrypted_message = (ciphertext_message *)result_message;
+    }
+    else {
+        if(result == SG_ERR_INVALID_KEY_ID) {
+            result = SG_ERR_NO_SESSION;
+        }
+        SIGNAL_UNREF(result_message);
+    }
+    signal_buffer_free(ciphertext);
+    SIGNAL_UNREF(next_chain_key);
+    SIGNAL_UNREF(sender_key);
+    SIGNAL_UNREF(record);
+    signal_unlock(cipher->global_context);
+    return result;
+}
+
+int fast_ratchet_group_cipher_decrypt(fast_ratchet_group_cipher *cipher,
+        sender_key_message *ciphertext, void *decrypt_context,
+        signal_buffer **plaintext)
+{
+    int result = 0;
+    signal_buffer *result_buf = 0;
+    fast_ratchet_sender_key_record *record = 0;
+    fast_ratchet_sender_key_state *state = 0;
+    sender_message_key *sender_key = 0;
+    signal_buffer *sender_cipher_key = 0;
+    signal_buffer *sender_cipher_iv = 0;
+    signal_buffer *ciphertext_body = 0;
+
+    assert(cipher);
+    signal_lock(cipher->global_context);
+
+    if(cipher->inside_callback == 1) {
+        result = SG_ERR_INVAL;
+        goto complete;
+    }
+
+    result = signal_protocol_fast_ratchet_sender_key_load_key(cipher->store, &record, cipher->sender_key_id);
+    if(result < 0) {
+        goto complete;
+    }
+
+    if(fast_ratchet_sender_key_record_is_empty(record)) {
+        result = SG_ERR_NO_SESSION;
+        signal_log(cipher->global_context, SG_LOG_WARNING, "No sender key for: %s::%s::%d",
+                cipher->sender_key_id->group_id,
+                cipher->sender_key_id->sender.name,
+                cipher->sender_key_id->sender.device_id);
+        goto complete;
+    }
+
+    result = fast_ratchet_sender_key_record_get_sender_key_state_by_id(record, &state, sender_key_message_get_key_id(ciphertext));
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = sender_key_message_verify_signature(ciphertext, fast_ratchet_sender_key_state_get_signing_key_public(state));
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fast_ratchet_group_cipher_get_sender_key(cipher, &sender_key, state, sender_key_message_get_iteration(ciphertext));
+    if(result < 0) {
+        goto complete;
+    }
+
+    sender_cipher_key = sender_message_key_get_cipher_key(sender_key);
+    sender_cipher_iv = sender_message_key_get_iv(sender_key);
+    ciphertext_body = sender_key_message_get_ciphertext(ciphertext);
+
+    result = signal_decrypt(cipher->global_context, &result_buf, SG_CIPHER_AES_CBC_PKCS5,
+            signal_buffer_data(sender_cipher_key), signal_buffer_len(sender_cipher_key),
+            signal_buffer_data(sender_cipher_iv), signal_buffer_len(sender_cipher_iv),
+            signal_buffer_data(ciphertext_body), signal_buffer_len(ciphertext_body));
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fast_ratchet_group_cipher_decrypt_callback(cipher, result_buf, decrypt_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = signal_protocol_fast_ratchet_sender_key_store_key(cipher->store, cipher->sender_key_id, record);
+
+complete:
+    SIGNAL_UNREF(sender_key);
+    SIGNAL_UNREF(record);
+    if(result >= 0) {
+        *plaintext = result_buf;
+    }
+    else {
+        if(result == SG_ERR_INVALID_KEY || result == SG_ERR_INVALID_KEY_ID) {
+            result = SG_ERR_INVALID_MESSAGE;
+        }
+        signal_buffer_free(result_buf);
+    }
+    signal_unlock(cipher->global_context);
+    return result;
+}
+
+int fast_ratchet_group_cipher_get_sender_key(fast_ratchet_group_cipher *cipher,
+        sender_message_key **sender_key, fast_ratchet_sender_key_state *state, uint32_t iteration)
+{
+    int result = 0;
+    sender_message_key *result_key = 0;
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    fast_ratchet_sender_chain_key *next_chain_key = 0;
+
+    chain_key = fast_ratchet_sender_key_state_get_chain_key(state);
+    SIGNAL_REF(chain_key);
+
+    if(fast_ratchet_sender_chain_key_get_iteration(chain_key) > iteration) {
+        result = SG_ERR_DUPLICATE_MESSAGE;
+        signal_log(cipher->global_context, SG_LOG_WARNING,
+                "Received message with old counter: %d, %d",
+                fast_ratchet_sender_chain_key_get_iteration(chain_key), iteration);
+        goto complete;
+    }
+    else if(fast_ratchet_sender_chain_key_get_iteration(chain_key) < iteration) {
+        result = fast_ratchet_sender_chain_key_create_next(chain_key, &next_chain_key,
+                iteration - fast_ratchet_sender_chain_key_get_iteration(chain_key));
+        if(result < 0) {
+            goto complete;
+        }
+        SIGNAL_UNREF(chain_key);
+        chain_key = next_chain_key;
+        next_chain_key = 0;
+    }
+
+    result = fast_ratchet_sender_chain_key_create_next(chain_key, &next_chain_key, 1);
+    if(result < 0) {
+        goto complete;
+    }
+
+    fast_ratchet_sender_key_state_set_chain_key(state, next_chain_key);
+    result = fast_ratchet_sender_chain_key_create_message_key(chain_key, &result_key);
+
+complete:
+    SIGNAL_UNREF(chain_key);
+    SIGNAL_UNREF(next_chain_key);
+    if(result >= 0) {
+        *sender_key = result_key;
+    }
+    return result;
+}
+
+int fast_ratchet_group_cipher_decrypt_callback(fast_ratchet_group_cipher *cipher,
+        signal_buffer *plaintext, void *decrypt_context)
+{
+    int result = 0;
+    if(cipher->decrypt_callback) {
+        cipher->inside_callback = 1;
+        result = cipher->decrypt_callback(cipher, plaintext, decrypt_context);
+        cipher->inside_callback = 0;
+    }
+    return result;
+}
+
+void fast_ratchet_group_cipher_free(fast_ratchet_group_cipher *cipher)
+{
+    if(cipher) {
+        free(cipher);
+    }
+}
diff --git a/src/fast_ratchet_group_cipher.h b/src/fast_ratchet_group_cipher.h
new file mode 100644
index 0000000..3314684
--- /dev/null
+++ b/src/fast_ratchet_group_cipher.h
@@ -0,0 +1,115 @@
+#ifndef FAST_RATCHET_GROUP_CIPHER_H
+#define FAST_RATCHET_GROUP_CIPHER_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "signal_protocol_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The main entry point for Signal Protocol fast ratchet group encrypt/decrypt operations.
+ *
+ * Once a session has been established with fast_ratchet_group_session_builder and a
+ * fast_ratchet_sender_key_distribution_message has been distributed to each member of
+ * the group, this class can be used for all subsequent encrypt/decrypt
+ * operations within that session (i.e. until group membership changes).
+ */
+
+/**
+ * Construct a fast ratchet group cipher for encrypt/decrypt operations.
+ *
+ * The store and global contexts must remain valid for the lifetime of the
+ * group cipher.
+ *
+ * When finished, free the returned instance by calling fast_ratchet_group_cipher_free().
+ *
+ * @param cipher set to a freshly allocated fast ratchet group cipher instance
+ * @param store the signal_protocol_store_context to store all state information in
+ * @param sender_key_id the sender that messages will be encrypted to or decrypted from
+ * @param global_context the global library context
+ * @return 0 on success, or negative on failure
+ */
+int fast_ratchet_group_cipher_create(fast_ratchet_group_cipher **cipher,
+        signal_protocol_store_context *store, const signal_protocol_sender_key_name *sender_key_id,
+        signal_context *global_context);
+
+/**
+ * Set the optional user data pointer for the fast ratchet group cipher.
+ *
+ * This is to give callback functions a way of accessing app specific
+ * context information for this cipher.
+ */
+void fast_ratchet_group_cipher_set_user_data(fast_ratchet_group_cipher *cipher, void *user_data);
+
+/**
+ * Get the optional user data pointer for the fast ratchet group cipher.
+ *
+ * This is to give callback functions a way of accessing app specific
+ * context information for this cipher.
+ */
+void *fast_ratchet_group_cipher_get_user_data(fast_ratchet_group_cipher *cipher);
+
+/**
+ * Set the callback function that is called during the decrypt process.
+ *
+ * The callback function is called from within fast_ratchet_group_cipher_decrypt() after
+ * decryption is complete but before the updated session state has been
+ * committed to the session store. If the callback function returns a
+ * negative value, then the decrypt function will immediately fail with
+ * an error.
+ *
+ * This a callback allows some implementations to store the committed plaintext
+ * to their local message store first, in case they are concerned with a crash
+ * or write error happening between the time the session state is updated but
+ * before they're able to successfully store the plaintext to disk.
+ *
+ * @param callback the callback function to set
+ * @param user_data user data pointer provided to the callback
+ */
+void fast_ratchet_group_cipher_set_decryption_callback(fast_ratchet_group_cipher *cipher,
+        int (*callback)(fast_ratchet_group_cipher *cipher, signal_buffer *plaintext, void *decrypt_context));
+
+/**
+ * Encrypt a message.
+ *
+ * @param padded_message The plaintext message bytes, optionally padded to a constant multiple.
+ * @param padded_message_len The length of the data pointed to by padded_message
+ * @param encrypted_message Set to a ciphertext message encrypted to the group+sender+device tuple.
+ *
+ * @retval SG_SUCCESS Success
+ * @retval SG_ERR_NO_SESSION if there is no established session for this contact.
+ * @retval SG_ERR_INVALID_KEY if there is no valid private key for this session.
+ */
+int fast_ratchet_group_cipher_encrypt(fast_ratchet_group_cipher *cipher,
+        const uint8_t *padded_plaintext, size_t padded_plaintext_len,
+        ciphertext_message **encrypted_message);
+
+/**
+ * Decrypt a message.
+ *
+ * @param ciphertext The sender_key_message to decrypt.
+ * @param decrypt_context Optional context pointer associated with the
+ *   ciphertext, which is passed to the decryption callback function
+ * @param plaintext Set to a newly allocated buffer containing the plaintext.
+ *
+ * @retval SG_SUCCESS Success
+ * @retval SG_ERR_INVALID_MESSAGE if the input is not valid ciphertext.
+ * @retval SG_ERR_DUPLICATE_MESSAGE if the input is a message that has already been received.
+ * @retval SG_ERR_LEGACY_MESSAGE if the input is a message formatted by a protocol version that
+ *                               is no longer supported.
+ * @retval SG_ERR_NO_SESSION if there is no established session for this contact.
+ */
+int fast_ratchet_group_cipher_decrypt(fast_ratchet_group_cipher *cipher,
+        sender_key_message *ciphertext, void *decrypt_context,
+        signal_buffer **plaintext);
+
+void fast_ratchet_group_cipher_free(fast_ratchet_group_cipher *cipher);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FAST_RATCHET_GROUP_CIPHER_H */
diff --git a/src/fast_ratchet_group_session_builder.c b/src/fast_ratchet_group_session_builder.c
new file mode 100644
index 0000000..47721e8
--- /dev/null
+++ b/src/fast_ratchet_group_session_builder.c
@@ -0,0 +1,185 @@
+#include "fast_ratchet_group_session_builder.h"
+
+#include <assert.h>
+#include <string.h>
+#include "fast_ratchet_sender_key_record.h"
+#include "fast_ratchet_sender_key_state.h"
+#include "fast_ratchet_sender_key.h"
+#include "fast_ratchet_util.h"
+#include "protocol.h"
+#include "key_helper.h"
+#include "signal_protocol_internal.h"
+
+struct fast_ratchet_group_session_builder
+{
+    signal_protocol_store_context *store;
+    signal_context *global_context;
+};
+
+int fast_ratchet_group_session_builder_create(fast_ratchet_group_session_builder **builder,
+        signal_protocol_store_context *store, signal_context *global_context)
+{
+    fast_ratchet_group_session_builder *result = 0;
+
+    assert(store);
+    assert(global_context);
+
+    result = malloc(sizeof(fast_ratchet_group_session_builder));
+    if(!result) {
+        return SG_ERR_NOMEM;
+    }
+    memset(result, 0, sizeof(fast_ratchet_group_session_builder));
+
+    result->store = store;
+    result->global_context = global_context;
+
+    *builder = result;
+    return 0;
+}
+
+int fast_ratchet_group_session_builder_process_session(fast_ratchet_group_session_builder *builder,
+        const signal_protocol_sender_key_name *sender_key_name,
+        fast_ratchet_sender_key_distribution_message *distribution_message)
+{
+    int result = 0;
+    fast_ratchet_sender_key_record *record = 0;
+
+    assert(builder);
+    assert(builder->store);
+    signal_lock(builder->global_context);
+
+    result = signal_protocol_fast_ratchet_sender_key_load_key(builder->store, &record, sender_key_name);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fast_ratchet_sender_key_record_add_sender_key_state(record,
+            fast_ratchet_sender_key_distribution_message_get_id(distribution_message),
+            fast_ratchet_sender_key_distribution_message_get_iteration(distribution_message),
+            fast_ratchet_sender_key_distribution_message_get_chain_keys(distribution_message),
+            fast_ratchet_sender_key_distribution_message_get_signature_key(distribution_message));
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = signal_protocol_fast_ratchet_sender_key_store_key(builder->store, sender_key_name, record);
+
+complete:
+    SIGNAL_UNREF(record);
+    signal_unlock(builder->global_context);
+    return result;
+}
+
+int fast_ratchet_group_session_builder_create_session(fast_ratchet_group_session_builder *builder,
+        fast_ratchet_sender_key_distribution_message **distribution_message,
+        const signal_protocol_sender_key_name *sender_key_name, int scale)
+{
+    int result = 0;
+    fast_ratchet_sender_key_record *record = 0;
+    fast_ratchet_sender_key_state *state = 0;
+    uint32_t sender_key_id = 0;
+    signal_buffer *sender_key = 0;
+    ec_key_pair *sender_signing_key = 0;
+    fast_ratchet_sender_chain_key *initial_chain_key = 0;
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    signal_buffer_list *seeds = 0;
+    int create_state = 0;
+
+    assert(builder);
+    assert(builder->store);
+
+    if(scale < 0 || scale > 5) {
+        signal_log(builder->global_context, SG_LOG_ERROR, "Scale must be between 0 and 5");
+        return SG_ERR_INVAL;
+    }
+
+    signal_lock(builder->global_context);
+
+    result = signal_protocol_fast_ratchet_sender_key_load_key(builder->store, &record, sender_key_name);
+    if(result < 0) {
+        goto complete;
+    }
+
+    if(fast_ratchet_sender_key_record_is_empty(record)) {
+        create_state = 1;
+    }
+    else {
+        result = fast_ratchet_sender_key_record_get_sender_key_state(record, &state);
+        if(result < 0) {
+            goto complete;
+        }
+
+        chain_key = fast_ratchet_sender_key_state_get_chain_key(state);
+        seeds = fast_ratchet_sender_chain_key_get_seeds(chain_key);
+
+        if((unsigned int)fast_ratchet_scale_to_dimensions(scale) != signal_buffer_list_size(seeds)) {
+            create_state = 1;
+        }
+    }
+
+    if(create_state) {
+
+        result = signal_protocol_key_helper_generate_sender_key_id(&sender_key_id, builder->global_context);
+        if(result < 0) {
+            goto complete;
+        }
+
+        result = signal_protocol_key_helper_generate_sender_key(&sender_key, builder->global_context);
+        if(result < 0) {
+            goto complete;
+        }
+
+        result = signal_protocol_key_helper_generate_sender_signing_key(&sender_signing_key, builder->global_context);
+        if(result < 0) {
+            goto complete;
+        }
+
+        result = fast_ratchet_sender_chain_key_create_initial(&initial_chain_key, sender_key, scale,
+                builder->global_context);
+        if(result < 0) {
+            goto complete;
+        }
+
+        result = fast_ratchet_sender_key_record_set_sender_key_state(record, sender_key_id,
+                0, fast_ratchet_sender_chain_key_get_seeds(initial_chain_key),
+                sender_signing_key);
+        if(result < 0) {
+            goto complete;
+        }
+
+        result = signal_protocol_fast_ratchet_sender_key_store_key(builder->store, sender_key_name, record);
+        if(result < 0) {
+            goto complete;
+        }
+    }
+
+    result = fast_ratchet_sender_key_record_get_sender_key_state(record, &state);
+    if(result < 0) {
+        goto complete;
+    }
+
+    chain_key = fast_ratchet_sender_key_state_get_chain_key(state);
+    seeds = fast_ratchet_sender_chain_key_get_seeds(chain_key);
+
+    result = fast_ratchet_sender_key_distribution_message_create(distribution_message,
+            fast_ratchet_sender_key_state_get_key_id(state),
+            fast_ratchet_sender_chain_key_get_iteration(chain_key),
+            seeds,
+            fast_ratchet_sender_key_state_get_signing_key_public(state),
+            builder->global_context);
+
+complete:
+    signal_buffer_bzero_free(sender_key);
+    SIGNAL_UNREF(initial_chain_key);
+    SIGNAL_UNREF(sender_signing_key);
+    SIGNAL_UNREF(record);
+    signal_unlock(builder->global_context);
+    return result;
+}
+
+void fast_ratchet_group_session_builder_free(fast_ratchet_group_session_builder *builder)
+{
+    if(builder) {
+        free(builder);
+    }
+}
diff --git a/src/fast_ratchet_group_session_builder.h b/src/fast_ratchet_group_session_builder.h
new file mode 100644
index 0000000..47f406c
--- /dev/null
+++ b/src/fast_ratchet_group_session_builder.h
@@ -0,0 +1,73 @@
+#ifndef FAST_RATCHET_GROUP_SESSION_BUILDER_H
+#define FAST_RATCHET_GROUP_SESSION_BUILDER_H
+
+#include "signal_protocol_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Fast ratchet group session builder is responsible for setting up group
+ * sender key encrypted sessions.
+ *
+ * Once a session has been established, fast_ratchet_group_cipher can be used to
+ * encrypt/decrypt messages in that session.
+ * <p>
+ * The built sessions are unidirectional: they can be used either for sending
+ * or for receiving, but not both.
+ *
+ * Sessions are constructed per (groupId + senderId + deviceId) tuple.  Remote logical users
+ * are identified by their senderId, and each logical recipientId can have multiple physical
+ * devices.
+ */
+
+/**
+ * Constructs a group session builder.
+ *
+ * The store and global contexts must remain valid for the lifetime of the
+ * session builder.
+ *
+ * When finished, free the returned instance by calling fast_ratchet_group_session_builder_free().
+ *
+ * @param builder set to a freshly allocated group session builder instance
+ * @param store the signal_protocol_store_context to store all state information in
+ * @param global_context the global library context
+ * @return 0 on success, or negative on failure
+ */
+int fast_ratchet_group_session_builder_create(fast_ratchet_group_session_builder **builder,
+        signal_protocol_store_context *store, signal_context *global_context);
+
+/**
+ * Construct a group session for receiving messages from senderKeyName.
+ *
+ * @param sender_key_name the (groupId, senderId, deviceId) tuple associated
+ *     with the sender_key_distribution_message
+ * @param distribution_message a received fast_ratchet_sender_key_distribution_message
+ * @return 0 on success, or negative on failure
+ */
+int fast_ratchet_group_session_builder_process_session(fast_ratchet_group_session_builder *builder,
+        const signal_protocol_sender_key_name *sender_key_name,
+        fast_ratchet_sender_key_distribution_message *distribution_message);
+
+/**
+ * Construct a group session for sending messages.
+ *
+ * @param distribution_message a distribution message to be allocated and populated
+ * @param sender_key_name the (groupId, senderId, deviceId) tuple. In this
+ *     case, the sender should be the caller
+ * @param scale Value from which the number of dimensions for the chain key ratchet is derived.
+ *     Valid values are from [0..5]. (Dimensions is 2^scale.)
+ * @return 0 on success, or negative on failure
+ */
+int fast_ratchet_group_session_builder_create_session(fast_ratchet_group_session_builder *builder,
+        fast_ratchet_sender_key_distribution_message **distribution_message,
+        const signal_protocol_sender_key_name *sender_key_name, int scale);
+
+void fast_ratchet_group_session_builder_free(fast_ratchet_group_session_builder *builder);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FAST_RATCHET_GROUP_SESSION_BUILDER_H */
diff --git a/src/fast_ratchet_sender_key.c b/src/fast_ratchet_sender_key.c
new file mode 100644
index 0000000..40bef76
--- /dev/null
+++ b/src/fast_ratchet_sender_key.c
@@ -0,0 +1,376 @@
+#include "fast_ratchet_sender_key.h"
+
+#include <string.h>
+#include <assert.h>
+
+#include "fast_ratchet_util.h"
+#include "sender_key.h"
+#include "sender_key_internal.h"
+#include "signal_protocol_internal.h"
+
+struct fast_ratchet_sender_chain_key {
+    signal_type_base base;
+    uint32_t iteration;
+    signal_buffer_list *chain_keys;
+    signal_context *global_context;
+};
+
+static const uint8_t MESSAGE_KEY_SEED = 0x01;
+static const uint8_t CHAIN_KEY_SEED = 0x02;
+
+int fast_ratchet_sender_chain_key_get_derived_seeds(fast_ratchet_sender_chain_key *key, signal_buffer **derived_keys);
+
+int fast_ratchet_sender_chain_key_create_initial(fast_ratchet_sender_chain_key **key,
+        signal_buffer *base_chain_key, int scale,
+        signal_context *global_context)
+{
+    fast_ratchet_sender_chain_key *result = 0;
+    int chain_count = 0;
+    signal_buffer *chain_keys[FAST_RATCHET_MAX_CHAINS];
+    signal_buffer *chain_key = 0;
+    int i = 0;
+    int ret = 0;
+
+    assert(global_context);
+
+    if(!base_chain_key) {
+        return SG_ERR_INVAL;
+    }
+
+    if(scale < 0 || scale > 5) {
+        signal_log(global_context, SG_LOG_ERROR, "Scale must be between 0 and 5");
+        return SG_ERR_INVAL;
+    }
+
+    memset(chain_keys, 0, sizeof(chain_keys));
+
+    result = malloc(sizeof(fast_ratchet_sender_chain_key));
+    if(!result) {
+        return SG_ERR_NOMEM;
+    }
+
+    SIGNAL_INIT(result, fast_ratchet_sender_chain_key_destroy);
+
+    chain_count = fast_ratchet_scale_to_dimensions(scale);
+
+    result->iteration = 0;
+
+    result->chain_keys = signal_buffer_list_alloc();
+    if(!result->chain_keys) {
+        ret = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    chain_key = signal_buffer_copy(base_chain_key);
+    if(!chain_key) {
+        ret = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    ret = signal_buffer_list_push_back(result->chain_keys, chain_key);
+    if(ret < 0) {
+        goto complete;
+    }
+    chain_key = 0;
+
+    for(i = 1; i < chain_count; i++) {
+        chain_key = signal_buffer_alloc(0);
+        if(!chain_key) {
+            ret = SG_ERR_NOMEM;
+            goto complete;
+        }
+
+        ret = signal_buffer_list_push_back(result->chain_keys, chain_key);
+        if(ret < 0) {
+            goto complete;
+        }
+	chain_key = 0;
+    }
+
+    result->global_context = global_context;
+
+complete:
+    if(ret < 0) {
+        SIGNAL_UNREF(result);
+	signal_buffer_bzero_free(chain_key);
+        for(i = 0; i < FAST_RATCHET_MAX_CHAINS; i++) {
+            signal_buffer_bzero_free(chain_keys[i]);
+        }
+    }
+    else {
+        ret = 0;
+        *key = result;
+    }
+    return ret;
+}
+
+int fast_ratchet_sender_chain_key_create(fast_ratchet_sender_chain_key **key,
+        uint32_t iteration, signal_buffer_list *chain_keys,
+        signal_context *global_context)
+{
+    fast_ratchet_sender_chain_key *result = 0;
+    unsigned int chain_count = 0;
+    unsigned int i;
+    int ret = 0;
+
+    assert(global_context);
+
+    if(!chain_keys) {
+        return SG_ERR_INVAL;
+    }
+
+    chain_count = signal_buffer_list_size(chain_keys);
+
+    if(chain_count == 0 || 32 % chain_count != 0) {
+        signal_log(global_context, SG_LOG_ERROR, "Invalid number of chain keys: %d", chain_count);
+        return SG_ERR_INVAL;
+    }
+
+    if(iteration == 0 && chain_count > 1 && signal_buffer_len(signal_buffer_list_at(chain_keys, 1)) == 0) {
+        for(i = 2; i < chain_count; i++) {
+            if(signal_buffer_len(signal_buffer_list_at(chain_keys, i)) > 0) {
+                signal_log(global_context, SG_LOG_ERROR, "Invalid chain key values for starting iteration");
+                return SG_ERR_INVAL;
+            }
+        }
+    }
+    else {
+        for(i = 0; i < chain_count; i++) {
+            if(signal_buffer_len(signal_buffer_list_at(chain_keys, i)) == 0) {
+                signal_log(global_context, SG_LOG_ERROR, "Invalid chain key values");
+                return SG_ERR_INVAL;
+            }
+        }
+    }
+
+    result = malloc(sizeof(fast_ratchet_sender_chain_key));
+    if(!result) {
+        return SG_ERR_NOMEM;
+    }
+
+    SIGNAL_INIT(result, fast_ratchet_sender_chain_key_destroy);
+
+    result->iteration = iteration;
+
+    result->chain_keys = signal_buffer_list_copy(chain_keys);
+    if(!result->chain_keys) {
+        ret = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    result->global_context = global_context;
+
+complete:
+    if(ret < 0) {
+        SIGNAL_UNREF(result);
+    }
+    else {
+        ret = 0;
+        *key = result;
+    }
+    return ret;
+}
+
+uint32_t fast_ratchet_sender_chain_key_get_iteration(const fast_ratchet_sender_chain_key *key)
+{
+    assert(key);
+    return key->iteration;
+}
+
+int fast_ratchet_sender_chain_key_create_message_key(fast_ratchet_sender_chain_key *key,
+        sender_message_key **message_key)
+{
+    int ret = 0;
+    unsigned int chain_count = 0;
+    signal_buffer *chain_keys[FAST_RATCHET_MAX_CHAINS];
+    signal_buffer *derivative = 0;
+    unsigned int i;
+    sender_message_key *result = 0;
+
+    assert(key);
+
+    chain_count = signal_buffer_list_size(key->chain_keys);
+    assert(chain_count > 0);
+
+    memset(chain_keys, 0, sizeof(chain_keys));
+
+    ret = fast_ratchet_sender_chain_key_get_derived_seeds(key, chain_keys);
+    if(ret < 0) {
+        goto complete;
+    }
+
+    ret = sender_chain_key_get_derivative(&derivative, MESSAGE_KEY_SEED,
+            chain_keys[chain_count - 1], key->global_context);
+    if(ret < 0) {
+        goto complete;
+    }
+
+    ret = sender_message_key_create(&result, key->iteration, derivative, key->global_context);
+
+complete:
+    signal_buffer_bzero_free(derivative);
+    for(i = 0; i < FAST_RATCHET_MAX_CHAINS; i++) {
+        signal_buffer_bzero_free(chain_keys[i]);
+    }
+    if(ret >= 0) {
+        ret = 0;
+        *message_key = result;
+    }
+    return ret;
+}
+
+int fast_ratchet_sender_chain_key_create_next(fast_ratchet_sender_chain_key *key,
+        fast_ratchet_sender_chain_key **next_key, uint32_t count)
+{
+    int ret = 0;
+    unsigned int chain_count;
+    uint32_t next_iteration;
+    uint32_t current_decomposition[FAST_RATCHET_MAX_CHAINS];
+    uint32_t next_decomposition[FAST_RATCHET_MAX_CHAINS];
+    signal_buffer *result_chains[FAST_RATCHET_MAX_CHAINS];
+    signal_buffer_list *result_chains_list = 0;
+    fast_ratchet_sender_chain_key *result = 0;
+    unsigned int i = 0;
+
+    assert(key);
+    assert(count > 0);
+
+    chain_count = signal_buffer_list_size(key->chain_keys);
+    next_iteration = key->iteration + count;
+    fast_ratchet_decompose_chain_iterations(current_decomposition, chain_count, key->iteration);
+    fast_ratchet_decompose_chain_iterations(next_decomposition, chain_count, next_iteration);
+
+    memset(result_chains, 0, sizeof(result_chains));
+
+    ret = fast_ratchet_sender_chain_key_get_derived_seeds(key, result_chains);
+    if(ret < 0) {
+        goto complete;
+    }
+
+    for(i = 0; i < chain_count; i++) {
+        while(next_decomposition[i] > current_decomposition[i]) {
+            signal_buffer *derivative_key = 0;
+
+            if(i < chain_count - 1 && next_decomposition[i] - 1 == current_decomposition[i]) {
+                ret = sender_chain_key_get_derivative(&derivative_key, CHAIN_KEY_SEED + i + 1, result_chains[i], key->global_context);
+                if(ret < 0) {
+                    goto complete;
+                }
+
+                if(result_chains[i + 1]) {
+                    signal_buffer_bzero_free(result_chains[i + 1]);
+                }
+                result_chains[i + 1] = derivative_key;
+                derivative_key = 0;
+
+                current_decomposition[i + 1] = 0;
+            }
+
+            ret = sender_chain_key_get_derivative(&derivative_key, CHAIN_KEY_SEED + i, result_chains[i], key->global_context);
+            if(ret < 0) {
+                goto complete;
+            }
+
+            if(result_chains[i]) {
+                signal_buffer_bzero_free(result_chains[i]);
+            }
+            result_chains[i] = derivative_key;
+
+            current_decomposition[i]++;
+        }
+    }
+
+    result_chains_list = signal_buffer_list_alloc();
+    if(!result_chains_list) {
+        ret = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    for(i = 0; i < chain_count; i++) {
+        ret = signal_buffer_list_push_back(result_chains_list, result_chains[i]);
+        if(ret < 0) {
+            goto complete;
+        }
+        result_chains[i] = 0;
+    }
+
+    ret = fast_ratchet_sender_chain_key_create(&result, next_iteration, result_chains_list, key->global_context);
+
+complete:
+    signal_buffer_list_bzero_free(result_chains_list);
+    if(ret < 0) {
+        for(i = 0; i < FAST_RATCHET_MAX_CHAINS; i++) {
+            signal_buffer_bzero_free(result_chains[i]);
+        }
+    }
+    else {
+        ret = 0;
+        *next_key = result;
+    }
+    return ret;
+}
+
+signal_buffer_list *fast_ratchet_sender_chain_key_get_seeds(const fast_ratchet_sender_chain_key *key)
+{
+    assert(key);
+    return key->chain_keys;
+}
+
+int fast_ratchet_sender_chain_key_get_derived_seeds(fast_ratchet_sender_chain_key *key, signal_buffer **derived_keys)
+{
+    int ret = 0;
+    unsigned int chain_count = 0;
+    unsigned int i = 0;
+
+    assert(key);
+
+    chain_count = signal_buffer_list_size(key->chain_keys);
+
+    if(key->iteration == 0 && chain_count > 1 && signal_buffer_len(signal_buffer_list_at(key->chain_keys, 1)) == 0) {
+        for(i = 0; i < chain_count - 1; i++) {
+            signal_buffer *current_key = (i == 0) ? signal_buffer_list_at(key->chain_keys, 0) : derived_keys[i];
+            signal_buffer *derivative_key = 0;
+
+            ret = sender_chain_key_get_derivative(&derivative_key, CHAIN_KEY_SEED + i + 1, current_key, key->global_context);
+            if(ret < 0) {
+                goto complete;
+            }
+
+            if(derived_keys[i + 1]) {
+                signal_buffer_bzero_free(derived_keys[i + 1]);
+            }
+            derived_keys[i + 1] = derivative_key;
+            derivative_key = 0;
+
+            ret = sender_chain_key_get_derivative(&derivative_key, CHAIN_KEY_SEED + i, current_key, key->global_context);
+            if(ret < 0) {
+                goto complete;
+            }
+
+            if(derived_keys[i]) {
+                signal_buffer_bzero_free(derived_keys[i]);
+            }
+            derived_keys[i] = derivative_key;
+        }
+    }
+    else {
+        for(i = 0; i < chain_count; i++) {
+            derived_keys[i] = signal_buffer_copy(signal_buffer_list_at(key->chain_keys, i));
+            if(!derived_keys[i]) {
+                ret = SG_ERR_NOMEM;
+                goto complete;
+            }
+        }
+    }
+
+complete:
+    return ret;
+}
+
+void fast_ratchet_sender_chain_key_destroy(signal_type_base *type)
+{
+    fast_ratchet_sender_chain_key *key = (fast_ratchet_sender_chain_key *)type;
+
+    signal_buffer_list_bzero_free(key->chain_keys);
+    free(key);
+}
diff --git a/src/fast_ratchet_sender_key.h b/src/fast_ratchet_sender_key.h
new file mode 100644
index 0000000..52e87f0
--- /dev/null
+++ b/src/fast_ratchet_sender_key.h
@@ -0,0 +1,32 @@
+#ifndef FAST_RATCHET_SENDER_KEY_H
+#define FAST_RATCHET_SENDER_KEY_H
+
+#include <stdint.h>
+#include <stddef.h>
+#include "signal_protocol_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int fast_ratchet_sender_chain_key_create_initial(fast_ratchet_sender_chain_key **key,
+        signal_buffer *base_chain_key, int scale,
+        signal_context *global_context);
+
+int fast_ratchet_sender_chain_key_create(fast_ratchet_sender_chain_key **key,
+        uint32_t iteration, signal_buffer_list *chain_keys,
+        signal_context *global_context);
+
+uint32_t fast_ratchet_sender_chain_key_get_iteration(const fast_ratchet_sender_chain_key *key);
+int fast_ratchet_sender_chain_key_create_message_key(fast_ratchet_sender_chain_key *key,
+        sender_message_key **message_key);
+int fast_ratchet_sender_chain_key_create_next(fast_ratchet_sender_chain_key *key,
+        fast_ratchet_sender_chain_key **next_key, uint32_t count);
+signal_buffer_list *fast_ratchet_sender_chain_key_get_seeds(const fast_ratchet_sender_chain_key *key);
+void fast_ratchet_sender_chain_key_destroy(signal_type_base *type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FAST_RATCHET_SENDER_KEY_H */
diff --git a/src/fast_ratchet_sender_key_record.c b/src/fast_ratchet_sender_key_record.c
new file mode 100644
index 0000000..a571a42
--- /dev/null
+++ b/src/fast_ratchet_sender_key_record.c
@@ -0,0 +1,343 @@
+#include "fast_ratchet_sender_key_record.h"
+
+#include <string.h>
+
+#include "fast_ratchet_sender_key_state.h"
+#include "fast_ratchet_sender_key.h"
+#include "utlist.h"
+#include "LocalStorageProtocol.pb-c.h"
+#include "signal_protocol_internal.h"
+
+#define MAX_STATES 5
+
+typedef struct fast_ratchet_sender_key_state_node {
+    fast_ratchet_sender_key_state *state;
+    struct fast_ratchet_sender_key_state_node *prev, *next;
+} fast_ratchet_sender_key_state_node;
+
+struct fast_ratchet_sender_key_record
+{
+    signal_type_base base;
+    fast_ratchet_sender_key_state_node *sender_key_states_head;
+    signal_context *global_context;
+};
+
+int fast_ratchet_sender_key_record_create(fast_ratchet_sender_key_record **record,
+        signal_context *global_context)
+{
+    fast_ratchet_sender_key_record *result = malloc(sizeof(fast_ratchet_sender_key_record));
+    if(!result) {
+        return SG_ERR_NOMEM;
+    }
+    memset(result, 0, sizeof(fast_ratchet_sender_key_record));
+    SIGNAL_INIT(result, fast_ratchet_sender_key_record_destroy);
+
+    result->global_context = global_context;
+
+    *record = result;
+    return 0;
+}
+
+int fast_ratchet_sender_key_record_serialize(signal_buffer **buffer, fast_ratchet_sender_key_record *record)
+{
+    int result = 0;
+    size_t result_size = 0;
+    unsigned int i = 0;
+    Textsecure__FastRatchetSenderKeyRecordStructure record_structure = TEXTSECURE__FAST_RATCHET_SENDER_KEY_RECORD_STRUCTURE__INIT;
+    fast_ratchet_sender_key_state_node *cur_node = 0;
+    signal_buffer *result_buf = 0;
+    uint8_t *data;
+    size_t len;
+
+    if(record->sender_key_states_head) {
+        size_t count;
+        DL_COUNT(record->sender_key_states_head, cur_node, count);
+
+        if(count > SIZE_MAX / sizeof(Textsecure__FastRatchetSenderKeyStateStructure *)) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+
+        record_structure.senderkeystates = malloc(sizeof(Textsecure__FastRatchetSenderKeyStateStructure *) * count);
+        if(!record_structure.senderkeystates) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+
+        i = 0;
+        DL_FOREACH(record->sender_key_states_head, cur_node) {
+            record_structure.senderkeystates[i] = malloc(sizeof(Textsecure__FastRatchetSenderKeyStateStructure));
+            if(!record_structure.senderkeystates[i]) {
+                result = SG_ERR_NOMEM;
+                break;
+            }
+            textsecure__fast_ratchet_sender_key_state_structure__init(record_structure.senderkeystates[i]);
+
+            result = fast_ratchet_sender_key_state_serialize_prepare(cur_node->state, record_structure.senderkeystates[i]);
+            if(result < 0) {
+                break;
+            }
+            i++;
+        }
+        record_structure.n_senderkeystates = i;
+        if(result < 0) {
+            goto complete;
+        }
+    }
+
+    len = textsecure__fast_ratchet_sender_key_record_structure__get_packed_size(&record_structure);
+
+    result_buf = signal_buffer_alloc(len);
+    if(!result_buf) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    data = signal_buffer_data(result_buf);
+    result_size = textsecure__fast_ratchet_sender_key_record_structure__pack(&record_structure, data);
+    if(result_size != len) {
+        signal_buffer_free(result_buf);
+        result = SG_ERR_INVALID_PROTO_BUF;
+        result_buf = 0;
+        goto complete;
+    }
+
+complete:
+    if(record_structure.senderkeystates) {
+        for(i = 0; i < record_structure.n_senderkeystates; i++) {
+            if(record_structure.senderkeystates[i]) {
+                fast_ratchet_sender_key_state_serialize_prepare_free(record_structure.senderkeystates[i]);
+            }
+        }
+        free(record_structure.senderkeystates);
+    }
+
+    if(result >= 0) {
+        *buffer = result_buf;
+    }
+    return result;
+}
+
+int fast_ratchet_sender_key_record_deserialize(fast_ratchet_sender_key_record **record, const uint8_t *data, size_t len, signal_context *global_context)
+{
+    int result = 0;
+    fast_ratchet_sender_key_record *result_record = 0;
+    Textsecure__FastRatchetSenderKeyRecordStructure *record_structure = 0;
+
+    record_structure = textsecure__fast_ratchet_sender_key_record_structure__unpack(0, len, data);
+    if(!record_structure) {
+        result = SG_ERR_INVALID_PROTO_BUF;
+        goto complete;
+    }
+
+    result = fast_ratchet_sender_key_record_create(&result_record, global_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+    if(record_structure->n_senderkeystates > 0) {
+        unsigned int i;
+        fast_ratchet_sender_key_state_node *state_node = 0;
+        fast_ratchet_sender_key_state *state_element = 0;
+        for(i = 0; i < record_structure->n_senderkeystates; i++) {
+            result = fast_ratchet_sender_key_state_deserialize_protobuf(&state_element, record_structure->senderkeystates[i], global_context);
+            if(result < 0) {
+                goto complete;
+            }
+
+            state_node = malloc(sizeof(fast_ratchet_sender_key_state_node));
+            if(!state_node) {
+                result = SG_ERR_NOMEM;
+                goto complete;
+            }
+
+            state_node->state = state_element;
+            DL_APPEND(result_record->sender_key_states_head, state_node);
+        }
+    }
+
+complete:
+    if(record_structure) {
+        textsecure__fast_ratchet_sender_key_record_structure__free_unpacked(record_structure, 0);
+    }
+    if(result_record) {
+        if(result < 0) {
+            SIGNAL_UNREF(result_record);
+        }
+        else {
+            *record = result_record;
+        }
+    }
+    return result;
+}
+
+int fast_ratchet_sender_key_record_copy(fast_ratchet_sender_key_record **record, fast_ratchet_sender_key_record *other_record, signal_context *global_context)
+{
+    int result = 0;
+    signal_buffer *buffer = 0;
+    uint8_t *data;
+    size_t len;
+
+    assert(other_record);
+    assert(global_context);
+
+    result = fast_ratchet_sender_key_record_serialize(&buffer, other_record);
+    if(result < 0) {
+        goto complete;
+    }
+
+    data = signal_buffer_data(buffer);
+    len = signal_buffer_len(buffer);
+
+    result = fast_ratchet_sender_key_record_deserialize(record, data, len, global_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+complete:
+    if(buffer) {
+        signal_buffer_free(buffer);
+    }
+    return result;
+}
+
+int fast_ratchet_sender_key_record_is_empty(fast_ratchet_sender_key_record *record)
+{
+    assert(record);
+    if(record->sender_key_states_head) {
+        return 0;
+    }
+    else {
+        return 1;
+    }
+}
+
+int fast_ratchet_sender_key_record_get_sender_key_state(fast_ratchet_sender_key_record *record, fast_ratchet_sender_key_state **state)
+{
+    assert(record);
+    if(record->sender_key_states_head) {
+        *state = record->sender_key_states_head->state;
+        return 0;
+    }
+    else {
+        signal_log(record->global_context, SG_LOG_ERROR, "No key state in record!");
+        return SG_ERR_INVALID_KEY_ID;
+    }
+}
+
+int fast_ratchet_sender_key_record_get_sender_key_state_by_id(fast_ratchet_sender_key_record *record, fast_ratchet_sender_key_state **state, uint32_t key_id)
+{
+    fast_ratchet_sender_key_state_node *cur_node;
+    assert(record);
+
+    DL_FOREACH(record->sender_key_states_head, cur_node) {
+        if(fast_ratchet_sender_key_state_get_key_id(cur_node->state) == key_id) {
+            *state = cur_node->state;
+            return 0;
+        }
+    }
+
+    signal_log(record->global_context, SG_LOG_ERROR, "No keys for: %d", key_id);
+    return SG_ERR_INVALID_KEY_ID;
+}
+
+static int fast_ratchet_sender_key_record_add_sender_key_state_impl(fast_ratchet_sender_key_record *record,
+        uint32_t id, uint32_t iteration, signal_buffer_list *chain_keys,
+        ec_public_key *signature_public_key, ec_private_key *signature_private_key)
+{
+    int result = 0;
+    fast_ratchet_sender_chain_key *chain_key_element = 0;
+    fast_ratchet_sender_key_state *state = 0;
+    fast_ratchet_sender_key_state_node *state_node = 0;
+    int count;
+    assert(record);
+
+    result = fast_ratchet_sender_chain_key_create(&chain_key_element, iteration, chain_keys, record->global_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = fast_ratchet_sender_key_state_create(&state, id, chain_key_element,
+            signature_public_key, signature_private_key,
+            record->global_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+    state_node = malloc(sizeof(fast_ratchet_sender_key_state_node));
+    if(!state_node) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    state_node->state = state;
+    DL_PREPEND(record->sender_key_states_head, state_node);
+
+    DL_COUNT(record->sender_key_states_head, state_node, count);
+    while(count > MAX_STATES) {
+        state_node = record->sender_key_states_head->prev;
+        DL_DELETE(record->sender_key_states_head, state_node);
+        if(state_node->state) {
+            SIGNAL_UNREF(state_node->state);
+        }
+        free(state_node);
+        --count;
+    }
+
+complete:
+    SIGNAL_UNREF(chain_key_element);
+    if(result < 0) {
+        SIGNAL_UNREF(state);
+    }
+    return result;
+}
+
+int fast_ratchet_sender_key_record_add_sender_key_state(fast_ratchet_sender_key_record *record,
+        uint32_t id, uint32_t iteration, signal_buffer_list *chain_keys, ec_public_key *signature_key)
+{
+    int result = fast_ratchet_sender_key_record_add_sender_key_state_impl(
+            record, id, iteration, chain_keys, signature_key, 0);
+    return result;
+}
+
+int fast_ratchet_sender_key_record_set_sender_key_state(fast_ratchet_sender_key_record *record,
+        uint32_t id, uint32_t iteration, signal_buffer_list *chain_keys, ec_key_pair *signature_key_pair)
+{
+    int result = 0;
+    fast_ratchet_sender_key_state_node *cur_node;
+    fast_ratchet_sender_key_state_node *tmp_node;
+    assert(record);
+
+    DL_FOREACH_SAFE(record->sender_key_states_head, cur_node, tmp_node) {
+        DL_DELETE(record->sender_key_states_head, cur_node);
+        if(cur_node->state) {
+            SIGNAL_UNREF(cur_node->state);
+        }
+        free(cur_node);
+    }
+    record->sender_key_states_head = 0;
+
+    result = fast_ratchet_sender_key_record_add_sender_key_state_impl(
+            record, id, iteration, chain_keys,
+            ec_key_pair_get_public(signature_key_pair),
+            ec_key_pair_get_private(signature_key_pair));
+    return result;
+}
+
+void fast_ratchet_sender_key_record_destroy(signal_type_base *type)
+{
+    fast_ratchet_sender_key_record *record = (fast_ratchet_sender_key_record *)type;
+    fast_ratchet_sender_key_state_node *cur_node;
+    fast_ratchet_sender_key_state_node *tmp_node;
+
+    DL_FOREACH_SAFE(record->sender_key_states_head, cur_node, tmp_node) {
+        DL_DELETE(record->sender_key_states_head, cur_node);
+        if(cur_node->state) {
+            SIGNAL_UNREF(cur_node->state);
+        }
+        free(cur_node);
+    }
+    record->sender_key_states_head = 0;
+
+    free(record);
+}
diff --git a/src/fast_ratchet_sender_key_record.h b/src/fast_ratchet_sender_key_record.h
new file mode 100644
index 0000000..a3fc768
--- /dev/null
+++ b/src/fast_ratchet_sender_key_record.h
@@ -0,0 +1,30 @@
+#ifndef FAST_RATCHET_SENDER_KEY_RECORD_H
+#define FAST_RATCHET_SENDER_KEY_RECORD_H
+
+#include "signal_protocol_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int fast_ratchet_sender_key_record_create(fast_ratchet_sender_key_record **record,
+        signal_context *global_context);
+int fast_ratchet_sender_key_record_serialize(signal_buffer **buffer, fast_ratchet_sender_key_record *record);
+int fast_ratchet_sender_key_record_deserialize(fast_ratchet_sender_key_record **record, const uint8_t *data, size_t len, signal_context *global_context);
+int fast_ratchet_sender_key_record_copy(fast_ratchet_sender_key_record **record, fast_ratchet_sender_key_record *other_record, signal_context *global_context);
+
+int fast_ratchet_sender_key_record_is_empty(fast_ratchet_sender_key_record *record);
+int fast_ratchet_sender_key_record_get_sender_key_state(fast_ratchet_sender_key_record *record, fast_ratchet_sender_key_state **state);
+int fast_ratchet_sender_key_record_get_sender_key_state_by_id(fast_ratchet_sender_key_record *record, fast_ratchet_sender_key_state **state, uint32_t key_id);
+int fast_ratchet_sender_key_record_add_sender_key_state(fast_ratchet_sender_key_record *record,
+        uint32_t id, uint32_t iteration, signal_buffer_list *chain_keys, ec_public_key *signature_key);
+int fast_ratchet_sender_key_record_set_sender_key_state(fast_ratchet_sender_key_record *record,
+        uint32_t id, uint32_t iteration, signal_buffer_list *chain_keys, ec_key_pair *signature_key_pair);
+
+void fast_ratchet_sender_key_record_destroy(signal_type_base *type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FAST_RATCHET_SENDER_KEY_RECORD_H */
diff --git a/src/fast_ratchet_sender_key_state.c b/src/fast_ratchet_sender_key_state.c
new file mode 100644
index 0000000..7df92b1
--- /dev/null
+++ b/src/fast_ratchet_sender_key_state.c
@@ -0,0 +1,429 @@
+#include "fast_ratchet_sender_key_state.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+
+#include "fast_ratchet_util.h"
+#include "fast_ratchet_sender_key.h"
+#include "LocalStorageProtocol.pb-c.h"
+#include "signal_protocol_internal.h"
+
+struct fast_ratchet_sender_key_state
+{
+    signal_type_base base;
+
+    uint32_t key_id;
+    fast_ratchet_sender_chain_key *chain_key;
+    ec_public_key *signature_public_key;
+    ec_private_key *signature_private_key;
+
+    signal_context *global_context;
+};
+
+int fast_ratchet_sender_key_state_create(fast_ratchet_sender_key_state **state,
+        uint32_t id, fast_ratchet_sender_chain_key *chain_key,
+        ec_public_key *signature_public_key, ec_private_key *signature_private_key,
+        signal_context *global_context)
+{
+    fast_ratchet_sender_key_state *result = 0;
+
+    if(!chain_key || !signature_public_key) {
+        return SG_ERR_INVAL;
+    }
+
+    result = malloc(sizeof(fast_ratchet_sender_key_state));
+    if(!result) {
+        return SG_ERR_NOMEM;
+    }
+    memset(result, 0, sizeof(fast_ratchet_sender_key_state));
+    SIGNAL_INIT(result, fast_ratchet_sender_key_state_destroy);
+
+    result->key_id = id;
+
+    SIGNAL_REF(chain_key);
+    result->chain_key = chain_key;
+
+    SIGNAL_REF(signature_public_key);
+    result->signature_public_key = signature_public_key;
+
+    if(signature_private_key) {
+        SIGNAL_REF(signature_private_key);
+        result->signature_private_key = signature_private_key;
+    }
+
+    result->global_context = global_context;
+
+    *state = result;
+    return 0;
+}
+
+int fast_ratchet_sender_key_state_serialize(signal_buffer **buffer, fast_ratchet_sender_key_state *state)
+{
+    int result = 0;
+    size_t result_size = 0;
+    uint8_t *data;
+    size_t len;
+    Textsecure__FastRatchetSenderKeyStateStructure *state_structure = 0;
+    signal_buffer *result_buf = 0;
+
+    state_structure = malloc(sizeof(Textsecure__FastRatchetSenderKeyStateStructure));
+    if(!state_structure) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+    textsecure__fast_ratchet_sender_key_state_structure__init(state_structure);
+
+    result = fast_ratchet_sender_key_state_serialize_prepare(state, state_structure);
+    if(result < 0) {
+        goto complete;
+    }
+
+    len = textsecure__fast_ratchet_sender_key_state_structure__get_packed_size(state_structure);
+
+    result_buf = signal_buffer_alloc(len);
+    if(!result_buf) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    data = signal_buffer_data(result_buf);
+    result_size = textsecure__fast_ratchet_sender_key_state_structure__pack(state_structure, data);
+    if(result_size != len) {
+        signal_buffer_free(result_buf);
+        result = SG_ERR_INVALID_PROTO_BUF;
+        result_buf = 0;
+        goto complete;
+    }
+
+complete:
+    if(state_structure) {
+        fast_ratchet_sender_key_state_serialize_prepare_free(state_structure);
+    }
+    if(result >= 0) {
+        *buffer = result_buf;
+    }
+    return result;
+}
+
+int fast_ratchet_sender_key_state_deserialize(fast_ratchet_sender_key_state **state, const uint8_t *data, size_t len, signal_context *global_context)
+{
+    int result = 0;
+    Textsecure__FastRatchetSenderKeyStateStructure *state_structure = 0;
+    fast_ratchet_sender_key_state *result_state = 0;
+
+    state_structure = textsecure__fast_ratchet_sender_key_state_structure__unpack(0, len, data);
+    if(!state_structure) {
+        result = SG_ERR_INVALID_PROTO_BUF;
+        goto complete;
+    }
+
+    result = fast_ratchet_sender_key_state_deserialize_protobuf(&result_state, state_structure, global_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+complete:
+    if(state_structure) {
+        textsecure__fast_ratchet_sender_key_state_structure__free_unpacked(state_structure, 0);
+    }
+    if(result_state) {
+        if(result < 0) {
+            SIGNAL_UNREF(result_state);
+        }
+        else {
+            *state = result_state;
+        }
+    }
+
+    return result;
+}
+
+int fast_ratchet_sender_key_state_serialize_prepare(fast_ratchet_sender_key_state *state, Textsecure__FastRatchetSenderKeyStateStructure *state_structure)
+{
+    int result = 0;
+    size_t chain_count = 0;
+    size_t i = 0;
+    Textsecure__SenderKeyStateStructure__SenderSigningKey *signing_key_structure = 0;
+    signal_buffer_list *chain_key_seeds = 0;
+    uint32_t chain_iterations[FAST_RATCHET_MAX_CHAINS];
+
+    assert(state);
+    assert(state_structure);
+
+    /* Sender key ID */
+    state_structure->has_senderkeyid = 1;
+    state_structure->senderkeyid = state->key_id;
+
+    /* Sender chain keys */
+    chain_key_seeds = fast_ratchet_sender_chain_key_get_seeds(state->chain_key);
+    chain_count = signal_buffer_list_size(chain_key_seeds);
+    fast_ratchet_decompose_chain_iterations(chain_iterations, chain_count,
+            fast_ratchet_sender_chain_key_get_iteration(state->chain_key));
+
+    if(chain_count > SIZE_MAX / sizeof(Textsecure__SenderKeyStateStructure__SenderChainKey *)) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    state_structure->senderchainkeys = malloc(sizeof(Textsecure__SenderKeyStateStructure__SenderChainKey *) * chain_count);
+    if(!state_structure->senderchainkeys) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    for(i = 0; i < chain_count; i++) {
+        signal_buffer *seed = 0;
+        state_structure->senderchainkeys[i] = malloc(sizeof(Textsecure__SenderKeyStateStructure__SenderChainKey));
+        if(!state_structure->senderchainkeys[i]) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+        textsecure__sender_key_state_structure__sender_chain_key__init(state_structure->senderchainkeys[i]);
+
+        state_structure->senderchainkeys[i]->iteration = chain_iterations[i];
+        state_structure->senderchainkeys[i]->has_iteration = 1;
+
+        seed = signal_buffer_list_at(chain_key_seeds, i);
+        state_structure->senderchainkeys[i]->seed.data = signal_buffer_data(seed);
+        state_structure->senderchainkeys[i]->seed.len = signal_buffer_len(seed);
+        state_structure->senderchainkeys[i]->has_seed = 1;
+        state_structure->n_senderchainkeys = i + 1;
+    }
+
+    /* Sender signing key */
+    signing_key_structure = malloc(sizeof(Textsecure__SenderKeyStateStructure__SenderSigningKey));
+    if(!signing_key_structure) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+    textsecure__sender_key_state_structure__sender_signing_key__init(signing_key_structure);
+    state_structure->sendersigningkey = signing_key_structure;
+
+    if(state->signature_public_key) {
+        result = ec_public_key_serialize_protobuf(&(signing_key_structure->public_), state->signature_public_key);
+        if(result < 0) {
+            goto complete;
+        }
+        signing_key_structure->has_public_ = 1;
+    }
+
+    if(state->signature_private_key) {
+        result = ec_private_key_serialize_protobuf(&(signing_key_structure->private_), state->signature_private_key);
+        if(result < 0) {
+            goto complete;
+        }
+        signing_key_structure->has_private_ = 1;
+    }
+
+complete:
+    return result;
+}
+
+void fast_ratchet_sender_key_state_serialize_prepare_free(Textsecure__FastRatchetSenderKeyStateStructure *state_structure)
+{
+    unsigned int i = 0;
+
+    if(state_structure->senderchainkeys) {
+        for(i = 0; i < state_structure->n_senderchainkeys; i++) {
+            if(state_structure->senderchainkeys[i]) {
+                free(state_structure->senderchainkeys[i]);
+            }
+        }
+        free(state_structure->senderchainkeys);
+    }
+
+    if(state_structure->sendersigningkey) {
+        if(state_structure->sendersigningkey->public_.data) {
+            free(state_structure->sendersigningkey->public_.data);
+        }
+        if(state_structure->sendersigningkey->private_.data) {
+            free(state_structure->sendersigningkey->private_.data);
+        }
+        free(state_structure->sendersigningkey);
+    }
+
+    free(state_structure);
+}
+
+int fast_ratchet_sender_key_state_deserialize_protobuf(fast_ratchet_sender_key_state **state, Textsecure__FastRatchetSenderKeyStateStructure *state_structure, signal_context *global_context)
+{
+    int result = 0;
+    fast_ratchet_sender_key_state *result_state = 0;
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    ec_public_key *signature_public_key = 0;
+    ec_private_key *signature_private_key = 0;
+    signal_buffer_list *chain_key_seeds = 0;
+    uint32_t chain_iterations[FAST_RATCHET_MAX_CHAINS];
+
+    if(state_structure->n_senderchainkeys > 0) {
+        unsigned int i;
+        uint32_t iteration;
+        chain_key_seeds = signal_buffer_list_alloc();
+        if(!chain_key_seeds) {
+            result = SG_ERR_NOMEM;
+            goto complete;
+        }
+
+        for(i = 0; i < state_structure->n_senderchainkeys; i++) {
+            signal_buffer *seed_buffer;
+
+            Textsecure__SenderKeyStateStructure__SenderChainKey *chain_key_structure =
+                    state_structure->senderchainkeys[i];
+
+            if(!chain_key_structure->has_iteration || !chain_key_structure->has_seed) {
+                continue;
+            }
+
+            seed_buffer = signal_buffer_create(
+                    chain_key_structure->seed.data,
+                    chain_key_structure->seed.len);
+            if(!seed_buffer) {
+                result = SG_ERR_NOMEM;
+                goto complete;
+            }
+
+            signal_buffer_list_push_back(chain_key_seeds, seed_buffer);
+            chain_iterations[i] = chain_key_structure->iteration;
+        }
+
+        iteration = fast_ratchet_compose_chain_iterations(chain_iterations, signal_buffer_list_size(chain_key_seeds));
+
+        result = fast_ratchet_sender_chain_key_create(&chain_key, iteration, chain_key_seeds, global_context);
+        if(result < 0) {
+            goto complete;
+        }
+    }
+
+    if(state_structure->sendersigningkey) {
+        if(state_structure->sendersigningkey->has_public_) {
+            result = curve_decode_point(&signature_public_key,
+                    state_structure->sendersigningkey->public_.data,
+                    state_structure->sendersigningkey->public_.len,
+                    global_context);
+            if(result < 0) {
+                goto complete;
+            }
+        }
+        if(state_structure->sendersigningkey->has_private_) {
+            result = curve_decode_private_point(&signature_private_key,
+                    state_structure->sendersigningkey->private_.data,
+                    state_structure->sendersigningkey->private_.len,
+                    global_context);
+            if(result < 0) {
+                goto complete;
+            }
+        }
+    }
+
+    if(state_structure->has_senderkeyid && chain_key && signature_public_key) {
+        result = fast_ratchet_sender_key_state_create(&result_state,
+                state_structure->senderkeyid, chain_key,
+                signature_public_key, signature_private_key,
+                global_context);
+        if(result < 0) {
+            goto complete;
+        }
+    }
+    else {
+        result = SG_ERR_INVALID_PROTO_BUF;
+    }
+
+complete:
+    signal_buffer_list_bzero_free(chain_key_seeds);
+    if(chain_key) {
+        SIGNAL_UNREF(chain_key);
+    }
+    if(signature_public_key) {
+        SIGNAL_UNREF(signature_public_key);
+    }
+    if(signature_private_key) {
+        SIGNAL_UNREF(signature_private_key);
+    }
+    if(result >= 0) {
+        *state = result_state;
+    }
+    else {
+        if(result_state) {
+            SIGNAL_UNREF(result_state);
+        }
+    }
+    return result;
+}
+
+int fast_ratchet_sender_key_state_copy(fast_ratchet_sender_key_state **state, fast_ratchet_sender_key_state *other_state, signal_context *global_context)
+{
+    int result = 0;
+    signal_buffer *buffer = 0;
+    uint8_t *data;
+    size_t len;
+
+    assert(other_state);
+    assert(global_context);
+
+    result = fast_ratchet_sender_key_state_serialize(&buffer, other_state);
+    if(result < 0) {
+        goto complete;
+    }
+
+    data = signal_buffer_data(buffer);
+    len = signal_buffer_len(buffer);
+
+    result = fast_ratchet_sender_key_state_deserialize(state, data, len, global_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+complete:
+    if(buffer) {
+        signal_buffer_free(buffer);
+    }
+    return result;
+}
+
+uint32_t fast_ratchet_sender_key_state_get_key_id(fast_ratchet_sender_key_state *state)
+{
+    assert(state);
+    return state->key_id;
+}
+
+fast_ratchet_sender_chain_key *fast_ratchet_sender_key_state_get_chain_key(fast_ratchet_sender_key_state *state)
+{
+    assert(state);
+    return state->chain_key;
+}
+
+void fast_ratchet_sender_key_state_set_chain_key(fast_ratchet_sender_key_state *state, fast_ratchet_sender_chain_key *chain_key)
+{
+    assert(state);
+    assert(chain_key);
+
+    if(state->chain_key) {
+        SIGNAL_UNREF(state->chain_key);
+    }
+    SIGNAL_REF(chain_key);
+    state->chain_key = chain_key;
+}
+
+ec_public_key *fast_ratchet_sender_key_state_get_signing_key_public(fast_ratchet_sender_key_state *state)
+{
+    assert(state);
+    return state->signature_public_key;
+}
+
+ec_private_key *fast_ratchet_sender_key_state_get_signing_key_private(fast_ratchet_sender_key_state *state)
+{
+    assert(state);
+    return state->signature_private_key;
+}
+
+void fast_ratchet_sender_key_state_destroy(signal_type_base *type)
+{
+    fast_ratchet_sender_key_state *state = (fast_ratchet_sender_key_state *)type;
+
+    SIGNAL_UNREF(state->chain_key);
+    SIGNAL_UNREF(state->signature_public_key);
+    SIGNAL_UNREF(state->signature_private_key);
+
+    free(state);
+}
diff --git a/src/fast_ratchet_sender_key_state.h b/src/fast_ratchet_sender_key_state.h
new file mode 100644
index 0000000..a0fa6fb
--- /dev/null
+++ b/src/fast_ratchet_sender_key_state.h
@@ -0,0 +1,31 @@
+#ifndef FAST_RATCHET_SENDER_KEY_STATE_H
+#define FAST_RATCHET_SENDER_KEY_STATE_H
+
+#include <stdint.h>
+#include "signal_protocol_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int fast_ratchet_sender_key_state_create(fast_ratchet_sender_key_state **state,
+        uint32_t id, fast_ratchet_sender_chain_key *chain_key,
+        ec_public_key *signature_public_key, ec_private_key *signature_private_key,
+        signal_context *global_context);
+int fast_ratchet_sender_key_state_serialize(signal_buffer **buffer, fast_ratchet_sender_key_state *state);
+int fast_ratchet_sender_key_state_deserialize(fast_ratchet_sender_key_state **state, const uint8_t *data, size_t len, signal_context *global_context);
+int fast_ratchet_sender_key_state_copy(fast_ratchet_sender_key_state **state, fast_ratchet_sender_key_state *other_state, signal_context *global_context);
+
+uint32_t fast_ratchet_sender_key_state_get_key_id(fast_ratchet_sender_key_state *state);
+fast_ratchet_sender_chain_key *fast_ratchet_sender_key_state_get_chain_key(fast_ratchet_sender_key_state *state);
+void fast_ratchet_sender_key_state_set_chain_key(fast_ratchet_sender_key_state *state, fast_ratchet_sender_chain_key *chain_key);
+ec_public_key *fast_ratchet_sender_key_state_get_signing_key_public(fast_ratchet_sender_key_state *state);
+ec_private_key *fast_ratchet_sender_key_state_get_signing_key_private(fast_ratchet_sender_key_state *state);
+
+void fast_ratchet_sender_key_state_destroy(signal_type_base *type);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FAST_RATCHET_SENDER_KEY_STATE_H */
diff --git a/src/fast_ratchet_util.c b/src/fast_ratchet_util.c
new file mode 100644
index 0000000..66f768c
--- /dev/null
+++ b/src/fast_ratchet_util.c
@@ -0,0 +1,62 @@
+#include "fast_ratchet_util.h"
+
+#include <stdio.h>
+
+#define MIN(a,b) (((a)<(b))?(a):(b))
+
+int fast_ratchet_scale_to_dimensions(int scale)
+{
+    return 1 << scale;
+}
+
+uint32_t fast_ratchet_compose_iterations(uint32_t *components, size_t len)
+{
+    size_t dimensions = MIN(len, FAST_RATCHET_MAX_CHAINS);
+    uint32_t bits = 32 / dimensions;
+    uint32_t mask = (1UL << bits) - 1;
+    uint32_t result = 0;
+    size_t i = 0;
+
+    for (i = 0; i < dimensions; i++) {
+      result += (components[dimensions - i - 1] & mask) << (bits * i);
+    }
+    return result;
+}
+
+uint32_t fast_ratchet_compose_chain_iterations(uint32_t *chain_iterations, size_t len)
+{
+    uint32_t result[FAST_RATCHET_MAX_CHAINS];
+    size_t dimensions = MIN(len, FAST_RATCHET_MAX_CHAINS);
+    size_t i = 0;
+
+    for (i = 0; i < dimensions - 1; i++) {
+        result[i] = chain_iterations[i] - 1;
+    }
+    result[dimensions - 1] = chain_iterations[dimensions - 1];
+
+    return fast_ratchet_compose_iterations(result, dimensions);
+}
+
+void fast_ratchet_decompose_iteration(uint32_t *components, size_t len, uint32_t iteration)
+{
+    size_t dimensions = MIN(len, FAST_RATCHET_MAX_CHAINS);
+    uint32_t bits = 32 / dimensions;
+    uint32_t mask = (1UL << bits) - 1;
+    size_t i = 0;
+
+    for (i = 0; i < dimensions; i++) {
+        components[dimensions - i - 1] = (iteration >> bits * i) & mask;
+    }
+}
+
+void fast_ratchet_decompose_chain_iterations(uint32_t *components, size_t len, uint32_t iteration)
+{
+    size_t count = MIN(len, FAST_RATCHET_MAX_CHAINS);
+    size_t i = 0;
+
+    fast_ratchet_decompose_iteration(components, count, iteration);
+
+    for (i = 0; i < count - 1; i++) {
+        components[i]++;
+    }
+}
diff --git a/src/fast_ratchet_util.h b/src/fast_ratchet_util.h
new file mode 100644
index 0000000..421b4d0
--- /dev/null
+++ b/src/fast_ratchet_util.h
@@ -0,0 +1,45 @@
+#ifndef FAST_RATCHET_UTIL_H
+#define FAST_RATCHET_UTIL_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define FAST_RATCHET_MAX_CHAINS 32
+
+/**
+ * Convert the "scale" parameter value into the number of actual key chains
+ * it should represent.
+ */
+int fast_ratchet_scale_to_dimensions(int scale);
+
+uint32_t fast_ratchet_compose_iterations(uint32_t *components, size_t len);
+
+/**
+ * Compose individual chain key iterations into the corresponding message
+ * iteration.
+ *
+ * @param chain_iterations Individual chain key iterations
+ * @return Message iteration
+ */
+uint32_t fast_ratchet_compose_chain_iterations(uint32_t *chain_iterations, size_t len);
+
+void fast_ratchet_decompose_iteration(uint32_t *components, size_t len, uint32_t iteration);
+
+/**
+ * Decompose a message iteration into the individual chain key iterations.
+ *
+ * @param components An array to be populated with the individual chain iterations
+ * @param len The size of the array, which is also the number of chain iterations to decompose
+ * @param iteration The iteration to decompose
+ */
+void fast_ratchet_decompose_chain_iterations(uint32_t *components, size_t len, uint32_t iteration);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* FAST_RATCHET_UTIL_H */
diff --git a/src/protocol.c b/src/protocol.c
index 9c8ce54..20a42ca 100644
--- a/src/protocol.c
+++ b/src/protocol.c
@@ -59,6 +59,15 @@ struct sender_key_distribution_message
     ec_public_key *signature_key;
 };
 
+struct fast_ratchet_sender_key_distribution_message
+{
+    ciphertext_message base_message;
+    uint32_t id;
+    uint32_t iteration;
+    signal_buffer_list *chain_keys;
+    ec_public_key *signature_key;
+};
+
 static int signal_message_serialize(signal_buffer **buffer, const signal_message *message);
 static int signal_message_get_mac(signal_buffer **buffer,
         uint8_t message_version,
@@ -72,6 +81,7 @@ static int pre_key_signal_message_serialize(signal_buffer **buffer, const pre_ke
 
 static int sender_key_message_serialize(signal_buffer **buffer, const sender_key_message *message, ec_private_key *signature_key, signal_context *global_context);
 static int sender_key_distribution_message_serialize(signal_buffer **buffer, const sender_key_distribution_message *message);
+static int fast_ratchet_sender_key_distribution_message_serialize(signal_buffer **buffer, const fast_ratchet_sender_key_distribution_message *message);
 
 /*------------------------------------------------------------------------*/
 
@@ -1439,3 +1449,318 @@ void sender_key_distribution_message_destroy(signal_type_base *type)
     SIGNAL_UNREF(message->signature_key);
     free(message);
 }
+
+int fast_ratchet_sender_key_distribution_message_create(fast_ratchet_sender_key_distribution_message **message,
+        uint32_t id, uint32_t iteration,
+        signal_buffer_list *chain_keys,
+        ec_public_key *signature_key,
+        signal_context *global_context)
+{
+    int result = 0;
+
+    fast_ratchet_sender_key_distribution_message *result_message = 0;
+    signal_buffer *message_buf = 0;
+
+    assert(global_context);
+
+    result_message = malloc(sizeof(fast_ratchet_sender_key_distribution_message));
+
+    if(!result_message) {
+        return SG_ERR_NOMEM;
+    }
+    memset(result_message, 0, sizeof(fast_ratchet_sender_key_distribution_message));
+    SIGNAL_INIT(result_message, fast_ratchet_sender_key_distribution_message_destroy);
+
+    result_message->base_message.message_type = CIPHERTEXT_FASTRATCHET_SENDERKEY_DISTRIBUTION_TYPE;
+    result_message->base_message.global_context = global_context;
+
+    result_message->id = id;
+    result_message->iteration = iteration;
+
+    result_message->chain_keys = signal_buffer_list_copy(chain_keys);
+    if(!result_message->chain_keys) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    SIGNAL_REF(signature_key);
+    result_message->signature_key = signature_key;
+
+    result = fast_ratchet_sender_key_distribution_message_serialize(&message_buf, result_message);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result_message->base_message.serialized = message_buf;
+
+complete:
+    if(result >= 0) {
+        result = 0;
+        *message = result_message;
+    }
+    else {
+        if(result_message) {
+            SIGNAL_UNREF(result_message);
+        }
+    }
+    return result;
+}
+
+static int fast_ratchet_sender_key_distribution_message_serialize(signal_buffer **buffer, const fast_ratchet_sender_key_distribution_message *message)
+{
+    int result = 0;
+    uint8_t version = (CIPHERTEXT_CURRENT_VERSION << 4) | CIPHERTEXT_CURRENT_VERSION;
+    size_t result_size = 0;
+    signal_buffer *result_buf = 0;
+    Textsecure__FastRatchetSenderKeyDistributionMessage message_structure = TEXTSECURE__FAST_RATCHET_SENDER_KEY_DISTRIBUTION_MESSAGE__INIT;
+    size_t len = 0;
+    uint8_t *data = 0;
+    size_t chain_count;
+    size_t i;
+
+    message_structure.id = message->id;
+    message_structure.has_id = 1;
+
+    message_structure.iteration = message->iteration;
+    message_structure.has_iteration = 1;
+
+    chain_count = signal_buffer_list_size(message->chain_keys);
+
+    if(chain_count > SIZE_MAX / sizeof(ProtobufCBinaryData *)) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    message_structure.chainkeys = malloc(sizeof(ProtobufCBinaryData) * chain_count);
+    if(!message_structure.chainkeys) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    for(i = 0; i < chain_count; i++) {
+        signal_buffer *chain_key = signal_buffer_list_at(message->chain_keys, i);
+        message_structure.chainkeys[i].data = signal_buffer_data(chain_key);
+        message_structure.chainkeys[i].len = signal_buffer_len(chain_key);
+        message_structure.n_chainkeys = i + 1;
+    }
+
+    result = ec_public_key_serialize_protobuf(&message_structure.signingkey, message->signature_key);
+    if(result < 0) {
+        goto complete;
+    }
+    message_structure.has_signingkey = 1;
+
+    len = textsecure__fast_ratchet_sender_key_distribution_message__get_packed_size(&message_structure);
+
+    result_buf = signal_buffer_alloc(sizeof(version) + len);
+    if(!result_buf) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    data = signal_buffer_data(result_buf);
+    data[0] = version;
+
+    result_size = textsecure__fast_ratchet_sender_key_distribution_message__pack(&message_structure, data + sizeof(version));
+    if(result_size != len) {
+        signal_buffer_free(result_buf);
+        result = SG_ERR_INVALID_PROTO_BUF;
+        result_buf = 0;
+        goto complete;
+    }
+
+complete:
+    if(message_structure.chainkeys) {
+        free(message_structure.chainkeys);
+    }
+    if(message_structure.has_signingkey) {
+        free(message_structure.signingkey.data);
+    }
+    if(result >= 0) {
+        *buffer = result_buf;
+    }
+    else {
+        signal_buffer_free(result_buf);
+    }
+    return result;
+}
+
+int fast_ratchet_sender_key_distribution_message_deserialize(fast_ratchet_sender_key_distribution_message **message,
+        const uint8_t *data, size_t len,
+        signal_context *global_context)
+{
+    int result = 0;
+    fast_ratchet_sender_key_distribution_message *result_message = 0;
+    uint8_t version = 0;
+    const uint8_t *message_data = 0;
+    size_t message_len = 0;
+    size_t i;
+    Textsecure__FastRatchetSenderKeyDistributionMessage *message_structure = 0;
+
+    assert(global_context);
+
+    if(!data || len <= sizeof(uint8_t)) {
+        result = SG_ERR_INVAL;
+        goto complete;
+    }
+
+    version = (data[0] & 0xF0) >> 4;
+    message_data = data + sizeof(uint8_t);
+    message_len = len - sizeof(uint8_t);
+
+    if(version < CIPHERTEXT_CURRENT_VERSION) {
+        signal_log(global_context, SG_LOG_WARNING, "Legacy message: %d", version);
+        result = SG_ERR_LEGACY_MESSAGE;
+        goto complete;
+    }
+
+    if(version > CIPHERTEXT_CURRENT_VERSION) {
+        signal_log(global_context, SG_LOG_WARNING, "Unknown version: %d", version);
+        result = SG_ERR_INVALID_VERSION;
+        goto complete;
+    }
+
+    message_structure = textsecure__fast_ratchet_sender_key_distribution_message__unpack(0, message_len, message_data);
+    if(!message_structure) {
+        result = SG_ERR_INVALID_PROTO_BUF;
+        goto complete;
+    }
+
+    if(!message_structure->has_id
+            || !message_structure->has_iteration
+            || !message_structure->chainkeys
+            || !message_structure->has_signingkey) {
+        signal_log(global_context, SG_LOG_WARNING, "Incomplete message");
+        result = SG_ERR_INVALID_MESSAGE;
+        goto complete;
+    }
+
+    result_message = malloc(sizeof(fast_ratchet_sender_key_distribution_message));
+    if(!result_message) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+    memset(result_message, 0, sizeof(fast_ratchet_sender_key_distribution_message));
+    SIGNAL_INIT(result_message, fast_ratchet_sender_key_distribution_message_destroy);
+
+    result_message->base_message.message_type = CIPHERTEXT_FASTRATCHET_SENDERKEY_DISTRIBUTION_TYPE;
+    result_message->base_message.global_context = global_context;
+
+    result_message->id = message_structure->id;
+    result_message->iteration = message_structure->iteration;
+
+    result_message->chain_keys = signal_buffer_list_alloc();
+    if(!result_message->chain_keys) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+    if(message_structure->n_chainkeys > 0) {
+        for(i = 0; i < message_structure->n_chainkeys; i++) {
+            signal_buffer *buffer;
+
+            buffer = signal_buffer_create(
+                    message_structure->chainkeys[i].data,
+                    message_structure->chainkeys[i].len);
+            if(!buffer) {
+                result = SG_ERR_NOMEM;
+                goto complete;
+            }
+
+            result = signal_buffer_list_push_back(result_message->chain_keys, buffer);
+            if(result < 0) {
+                signal_buffer_free(buffer);
+                result = SG_ERR_NOMEM;
+                goto complete;
+            }
+        }
+
+    }
+
+    result = curve_decode_point(&result_message->signature_key,
+            message_structure->signingkey.data,
+            message_structure->signingkey.len,
+            global_context);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result_message->base_message.serialized = signal_buffer_create(data, len);
+    if(!result_message->base_message.serialized) {
+        result = SG_ERR_NOMEM;
+        goto complete;
+    }
+
+complete:
+    if(message_structure) {
+        textsecure__fast_ratchet_sender_key_distribution_message__free_unpacked(message_structure, 0);
+    }
+    if(result >= 0) {
+        *message = result_message;
+    }
+    else {
+        if(result_message) {
+            SIGNAL_UNREF(result_message);
+        }
+    }
+    return result;
+}
+
+int fast_ratchet_sender_key_distribution_message_copy(fast_ratchet_sender_key_distribution_message **message, fast_ratchet_sender_key_distribution_message *other_message, signal_context *global_context)
+{
+    int result = 0;
+    fast_ratchet_sender_key_distribution_message *result_message = 0;
+
+    assert(other_message);
+    assert(global_context);
+
+    result = fast_ratchet_sender_key_distribution_message_deserialize(
+            &result_message,
+            signal_buffer_data(other_message->base_message.serialized),
+            signal_buffer_len(other_message->base_message.serialized),
+            global_context);
+    if(result >= 0) {
+        *message = result_message;
+    }
+
+    return result;
+}
+
+uint32_t fast_ratchet_sender_key_distribution_message_get_id(fast_ratchet_sender_key_distribution_message *message)
+{
+    assert(message);
+    return message->id;
+}
+
+uint32_t fast_ratchet_sender_key_distribution_message_get_iteration(fast_ratchet_sender_key_distribution_message *message)
+{
+    assert(message);
+    return message->iteration;
+}
+
+signal_buffer_list *fast_ratchet_sender_key_distribution_message_get_chain_keys(fast_ratchet_sender_key_distribution_message *message)
+{
+    assert(message);
+    return message->chain_keys;
+}
+
+ec_public_key *fast_ratchet_sender_key_distribution_message_get_signature_key(fast_ratchet_sender_key_distribution_message *message)
+{
+    assert(message);
+    return message->signature_key;
+}
+
+void fast_ratchet_sender_key_distribution_message_destroy(signal_type_base *type)
+{
+    fast_ratchet_sender_key_distribution_message *message = (fast_ratchet_sender_key_distribution_message *)type;
+
+    if(message->base_message.serialized) {
+        signal_buffer_free(message->base_message.serialized);
+    }
+
+    if(message->chain_keys) {
+        signal_buffer_list_free(message->chain_keys);
+    }
+    SIGNAL_UNREF(message->signature_key);
+    free(message);
+}
diff --git a/src/protocol.h b/src/protocol.h
index 68c3a70..450b1d8 100644
--- a/src/protocol.h
+++ b/src/protocol.h
@@ -13,13 +13,14 @@ extern "C" {
 #define KEY_EXCHANGE_RESPONSE_FLAG              0X02
 #define KEY_EXCHANGE_SIMULTAENOUS_INITIATE_FLAG 0x04
 
-#define CIPHERTEXT_UNSUPPORTED_VERSION         1
-#define CIPHERTEXT_CURRENT_VERSION             3
+#define CIPHERTEXT_UNSUPPORTED_VERSION 1
+#define CIPHERTEXT_CURRENT_VERSION     3
 
-#define CIPHERTEXT_SIGNAL_TYPE                 2
-#define CIPHERTEXT_PREKEY_TYPE                 3
-#define CIPHERTEXT_SENDERKEY_TYPE              4
-#define CIPHERTEXT_SENDERKEY_DISTRIBUTION_TYPE 5
+#define CIPHERTEXT_SIGNAL_TYPE                             2
+#define CIPHERTEXT_PREKEY_TYPE                             3
+#define CIPHERTEXT_SENDERKEY_TYPE                          4
+#define CIPHERTEXT_SENDERKEY_DISTRIBUTION_TYPE             5
+#define CIPHERTEXT_FASTRATCHET_SENDERKEY_DISTRIBUTION_TYPE 6
 
 /* Worst case overhead. Not always accurate, but good enough for padding. */
 #define CIPHERTEXT_ENCRYPTED_MESSAGE_OVERHEAD 53
@@ -120,6 +121,23 @@ ec_public_key *sender_key_distribution_message_get_signature_key(sender_key_dist
 
 void sender_key_distribution_message_destroy(signal_type_base *type);
 
+int fast_ratchet_sender_key_distribution_message_create(fast_ratchet_sender_key_distribution_message **message,
+        uint32_t id, uint32_t iteration,
+        signal_buffer_list *chain_keys,
+        ec_public_key *signature_key,
+        signal_context *global_context);
+int fast_ratchet_sender_key_distribution_message_deserialize(fast_ratchet_sender_key_distribution_message **message,
+        const uint8_t *data, size_t len,
+        signal_context *global_context);
+int fast_ratchet_sender_key_distribution_message_copy(fast_ratchet_sender_key_distribution_message **message, fast_ratchet_sender_key_distribution_message *other_message, signal_context *global_context);
+
+uint32_t fast_ratchet_sender_key_distribution_message_get_id(fast_ratchet_sender_key_distribution_message *message);
+uint32_t fast_ratchet_sender_key_distribution_message_get_iteration(fast_ratchet_sender_key_distribution_message *message);
+signal_buffer_list *fast_ratchet_sender_key_distribution_message_get_chain_keys(fast_ratchet_sender_key_distribution_message *message);
+ec_public_key *fast_ratchet_sender_key_distribution_message_get_signature_key(fast_ratchet_sender_key_distribution_message *message);
+
+void fast_ratchet_sender_key_distribution_message_destroy(signal_type_base *type);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/sender_key.c b/src/sender_key.c
index 31d7499..d13bfde 100644
--- a/src/sender_key.c
+++ b/src/sender_key.c
@@ -1,4 +1,5 @@
 #include "sender_key.h"
+#include "sender_key_internal.h"
 
 #include <assert.h>
 #include <string.h>
@@ -24,9 +25,6 @@ struct sender_chain_key {
     signal_context *global_context;
 };
 
-static int sender_chain_key_get_derivative(signal_buffer **derivative, uint8_t seed, signal_buffer *key,
-        signal_context *global_context);
-
 int sender_message_key_create(sender_message_key **key,
         uint32_t iteration, signal_buffer *seed,
         signal_context *global_context)
diff --git a/src/sender_key_internal.h b/src/sender_key_internal.h
new file mode 100644
index 0000000..ea8e668
--- /dev/null
+++ b/src/sender_key_internal.h
@@ -0,0 +1,7 @@
+#ifndef SENDER_KEY_INTERNAL_H
+#define SENDER_KEY_INTERNAL_H
+
+int sender_chain_key_get_derivative(signal_buffer **derivative, uint8_t seed, signal_buffer *key,
+        signal_context *global_context);
+
+#endif /* SENDER_KEY_INTERNAL_H */
diff --git a/src/signal_protocol.c b/src/signal_protocol.c
index 11b0c51..2ccc587 100644
--- a/src/signal_protocol.c
+++ b/src/signal_protocol.c
@@ -27,6 +27,7 @@ struct signal_protocol_store_context {
     signal_protocol_signed_pre_key_store signed_pre_key_store;
     signal_protocol_identity_key_store identity_key_store;
     signal_protocol_sender_key_store sender_key_store;
+    signal_protocol_fast_ratchet_sender_key_store fast_ratchet_sender_key_store;
 };
 
 void signal_type_init(signal_type_base *instance,
@@ -229,7 +230,7 @@ signal_buffer_list *signal_buffer_list_copy(const signal_buffer_list *list)
     for(i = 0; i < list_size; i++) {
         signal_buffer **buffer = (signal_buffer**)utarray_eltptr(list->values, i);
         buffer_copy = signal_buffer_copy(*buffer);
-        utarray_push_back(list->values, &buffer_copy);
+        utarray_push_back(result_list->values, &buffer_copy);
         buffer_copy = 0;
     }
 
@@ -672,6 +673,15 @@ int signal_protocol_store_context_set_sender_key_store(signal_protocol_store_con
     return 0;
 }
 
+int signal_protocol_store_context_set_fast_ratchet_sender_key_store(signal_protocol_store_context *context, const signal_protocol_fast_ratchet_sender_key_store *store)
+{
+    if(!store) {
+        return SG_ERR_INVAL;
+    }
+    memcpy(&(context->fast_ratchet_sender_key_store), store, sizeof(signal_protocol_fast_ratchet_sender_key_store));
+    return 0;
+}
+
 void signal_protocol_store_context_destroy(signal_protocol_store_context *context)
 {
     if(context) {
@@ -690,6 +700,9 @@ void signal_protocol_store_context_destroy(signal_protocol_store_context *contex
         if(context->sender_key_store.destroy_func) {
             context->sender_key_store.destroy_func(context->sender_key_store.user_data);
         }
+        if(context->fast_ratchet_sender_key_store.destroy_func) {
+            context->fast_ratchet_sender_key_store.destroy_func(context->fast_ratchet_sender_key_store.user_data);
+        }
         free(context);
     }
 }
@@ -1181,3 +1194,75 @@ complete:
     }
     return result;
 }
+
+int signal_protocol_fast_ratchet_sender_key_store_key(signal_protocol_store_context *context, const signal_protocol_sender_key_name *sender_key_name, fast_ratchet_sender_key_record *record)
+{
+    int result = 0;
+    signal_buffer *buffer = 0;
+
+    assert(context);
+    assert(context->fast_ratchet_sender_key_store.store_fast_ratchet_sender_key);
+    assert(record);
+
+    result = fast_ratchet_sender_key_record_serialize(&buffer, record);
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = context->fast_ratchet_sender_key_store.store_fast_ratchet_sender_key(
+            sender_key_name,
+            signal_buffer_data(buffer), signal_buffer_len(buffer),
+            context->fast_ratchet_sender_key_store.user_data);
+
+complete:
+    if(buffer) {
+        signal_buffer_free(buffer);
+    }
+
+    return result;
+}
+
+int signal_protocol_fast_ratchet_sender_key_load_key(signal_protocol_store_context *context, fast_ratchet_sender_key_record **record, const signal_protocol_sender_key_name *sender_key_name)
+{
+    int result = 0;
+    signal_buffer *buffer = 0;
+    fast_ratchet_sender_key_record *result_record = 0;
+
+    assert(context);
+    assert(context->fast_ratchet_sender_key_store.load_fast_ratchet_sender_key);
+
+    result = context->fast_ratchet_sender_key_store.load_fast_ratchet_sender_key(
+            &buffer, sender_key_name,
+            context->fast_ratchet_sender_key_store.user_data);
+    if(result < 0) {
+        goto complete;
+    }
+
+    if(result == 0) {
+        if(buffer) {
+            result = SG_ERR_UNKNOWN;
+            goto complete;
+        }
+        result = fast_ratchet_sender_key_record_create(&result_record, context->global_context);
+    }
+    else if(result == 1) {
+        if(!buffer) {
+            result = -1;
+            goto complete;
+        }
+        result = fast_ratchet_sender_key_record_deserialize(&result_record,
+                signal_buffer_data(buffer), signal_buffer_len(buffer), context->global_context);
+    }
+    else {
+        result = SG_ERR_UNKNOWN;
+    }
+
+complete:
+    if(buffer) {
+        signal_buffer_free(buffer);
+    }
+    if(result >= 0) {
+        *record = result_record;
+    }
+    return result;
+}
diff --git a/src/signal_protocol.h b/src/signal_protocol.h
index e2ff5d6..8e0f42b 100644
--- a/src/signal_protocol.h
+++ b/src/signal_protocol.h
@@ -10,6 +10,7 @@
 #include "session_record.h"
 #include "session_pre_key.h"
 #include "sender_key_record.h"
+#include "fast_ratchet_sender_key_record.h"
 #include "signal_protocol_types.h"
 
 #ifdef __cplusplus
@@ -666,6 +667,40 @@ typedef struct signal_protocol_sender_key_store {
     void *user_data;
 } signal_protocol_sender_key_store;
 
+typedef struct signal_protocol_fast_ratchet_sender_key_store {
+    /**
+     * Store a serialized fast ratchet sender key record for a given
+     * (groupId + senderId + deviceId) tuple.
+     *
+     * @param sender_key_name the (groupId + senderId + deviceId) tuple
+     * @param record pointer to a buffer containing the serialized record
+     * @param record_len length of the serialized record
+     * @return 0 on success, negative on failure
+     */
+    int (*store_fast_ratchet_sender_key)(const signal_protocol_sender_key_name *sender_key_name, uint8_t *record, size_t record_len, void *user_data);
+
+    /**
+     * Returns a copy of the fast ratchet sender key record corresponding to the
+     * (groupId + senderId + deviceId) tuple.
+     *
+     * @param record pointer to a newly allocated buffer containing the record,
+     *     if found. Unset if no record was found.
+     *     The Signal Protocol library is responsible for freeing this buffer.
+     * @param sender_key_name the (groupId + senderId + deviceId) tuple
+     * @return 1 if the record was loaded, 0 if the record was not found, negative on failure
+     */
+    int (*load_fast_ratchet_sender_key)(signal_buffer **record, const signal_protocol_sender_key_name *sender_key_name, void *user_data);
+
+    /**
+     * Function called to perform cleanup when the data store context is being
+     * destroyed.
+     */
+    void (*destroy_func)(void *user_data);
+
+    /** User data pointer */
+    void *user_data;
+} signal_protocol_fast_ratchet_sender_key_store;
+
 /**
  * Create a new instance of the global library context.
  */
@@ -714,6 +749,7 @@ int signal_protocol_store_context_set_pre_key_store(signal_protocol_store_contex
 int signal_protocol_store_context_set_signed_pre_key_store(signal_protocol_store_context *context, const signal_protocol_signed_pre_key_store *store);
 int signal_protocol_store_context_set_identity_key_store(signal_protocol_store_context *context, const signal_protocol_identity_key_store *store);
 int signal_protocol_store_context_set_sender_key_store(signal_protocol_store_context *context, const signal_protocol_sender_key_store *store);
+int signal_protocol_store_context_set_fast_ratchet_sender_key_store(signal_protocol_store_context *context, const signal_protocol_fast_ratchet_sender_key_store *store);
 
 void signal_protocol_store_context_destroy(signal_protocol_store_context *context);
 
@@ -781,6 +817,17 @@ int signal_protocol_identity_is_trusted_identity(signal_protocol_store_context *
 int signal_protocol_sender_key_store_key(signal_protocol_store_context *context, const signal_protocol_sender_key_name *sender_key_name, sender_key_record *record);
 int signal_protocol_sender_key_load_key(signal_protocol_store_context *context, sender_key_record **record, const signal_protocol_sender_key_name *sender_key_name);
 
+
+/*
+ * Interface to the fast ratchet sender key store.
+ * These functions will use the callbacks in the provided
+ * signal_protocol_store_context instance and operate in terms of higher level
+ * library data structures.
+ */
+
+int signal_protocol_fast_ratchet_sender_key_store_key(signal_protocol_store_context *context, const signal_protocol_sender_key_name *sender_key_name, fast_ratchet_sender_key_record *record);
+int signal_protocol_fast_ratchet_sender_key_load_key(signal_protocol_store_context *context, fast_ratchet_sender_key_record **record, const signal_protocol_sender_key_name *sender_key_name);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/signal_protocol_internal.h b/src/signal_protocol_internal.h
index 3a30a0f..d892e9b 100644
--- a/src/signal_protocol_internal.h
+++ b/src/signal_protocol_internal.h
@@ -81,6 +81,10 @@ int sender_key_state_serialize_prepare(sender_key_state *state, Textsecure__Send
 void sender_key_state_serialize_prepare_free(Textsecure__SenderKeyStateStructure *state_structure);
 int sender_key_state_deserialize_protobuf(sender_key_state **state, Textsecure__SenderKeyStateStructure *state_structure, signal_context *global_context);
 
+int fast_ratchet_sender_key_state_serialize_prepare(fast_ratchet_sender_key_state *state, Textsecure__FastRatchetSenderKeyStateStructure *state_structure);
+void fast_ratchet_sender_key_state_serialize_prepare_free(Textsecure__FastRatchetSenderKeyStateStructure *state_structure);
+int fast_ratchet_sender_key_state_deserialize_protobuf(fast_ratchet_sender_key_state **state, Textsecure__FastRatchetSenderKeyStateStructure *state_structure, signal_context *global_context);
+
 void signal_protocol_str_serialize_protobuf(ProtobufCBinaryData *buffer, const char *str);
 char *signal_protocol_str_deserialize_protobuf(ProtobufCBinaryData *buffer);
 
diff --git a/src/signal_protocol_types.h b/src/signal_protocol_types.h
index b45fa4c..2d4b4ba 100644
--- a/src/signal_protocol_types.h
+++ b/src/signal_protocol_types.h
@@ -77,6 +77,7 @@ typedef struct signal_message signal_message;
 typedef struct pre_key_signal_message pre_key_signal_message;
 typedef struct sender_key_message sender_key_message;
 typedef struct sender_key_distribution_message sender_key_distribution_message;
+typedef struct fast_ratchet_sender_key_distribution_message fast_ratchet_sender_key_distribution_message;
 
 /*
  * Ratchet types
@@ -119,6 +120,15 @@ typedef struct group_session_builder group_session_builder;
 typedef struct group_cipher group_cipher;
 
 /*
+ * Fast ratchet group types
+ */
+typedef struct fast_ratchet_sender_chain_key fast_ratchet_sender_chain_key;
+typedef struct fast_ratchet_sender_key_state fast_ratchet_sender_key_state;
+typedef struct fast_ratchet_sender_key_record fast_ratchet_sender_key_record;
+typedef struct fast_ratchet_group_session_builder fast_ratchet_group_session_builder;
+typedef struct fast_ratchet_group_cipher fast_ratchet_group_cipher;
+
+/*
  * Fingerprint types
  */
 typedef struct fingerprint fingerprint;
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index 5550b7e..e070c17 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -94,3 +94,15 @@ add_test(test_fingerprint ${TEST_PATH}/test_fingerprint)
 add_executable(test_device_consistency test_device_consistency.c ${common_SRCS})
 target_link_libraries(test_device_consistency ${LIBS})
 add_test(test_device_consistency ${TEST_PATH}/test_device_consistency)
+
+add_executable(test_fast_ratchet_util test_fast_ratchet_util.c ${common_SRCS})
+target_link_libraries(test_fast_ratchet_util ${LIBS})
+add_test(test_fast_ratchet_util ${TEST_PATH}/test_fast_ratchet_util)
+
+add_executable(test_fast_ratchet_sender_key_record test_fast_ratchet_sender_key_record.c ${common_SRCS})
+target_link_libraries(test_fast_ratchet_sender_key_record ${LIBS})
+add_test(test_fast_ratchet_sender_key_record ${TEST_PATH}/test_fast_ratchet_sender_key_record)
+
+add_executable(test_fast_ratchet_group_cipher test_fast_ratchet_group_cipher.c ${common_SRCS})
+target_link_libraries(test_fast_ratchet_group_cipher ${LIBS})
+add_test(test_fast_ratchet_group_cipher ${TEST_PATH}/test_fast_ratchet_group_cipher)
diff --git a/tests/test_common.c b/tests/test_common.c
index a904be3..4079ad6 100644
--- a/tests/test_common.c
+++ b/tests/test_common.c
@@ -513,6 +513,7 @@ void setup_test_store_context(signal_protocol_store_context **context, signal_co
     setup_test_signed_pre_key_store(store_context);
     setup_test_identity_key_store(store_context, global_context);
     setup_test_sender_key_store(store_context, global_context);
+    setup_test_fast_ratchet_sender_key_store(store_context, global_context);
 
     *context = store_context;
 }
@@ -1182,3 +1183,18 @@ void setup_test_sender_key_store(signal_protocol_store_context *context, signal_
 
     signal_protocol_store_context_set_sender_key_store(context, &store);
 }
+
+void setup_test_fast_ratchet_sender_key_store(signal_protocol_store_context *context, signal_context *global_context)
+{
+    test_sender_key_store_data *data = malloc(sizeof(test_sender_key_store_data));
+    memset(data, 0, sizeof(test_sender_key_store_data));
+
+    signal_protocol_fast_ratchet_sender_key_store store = {
+        .store_fast_ratchet_sender_key = test_sender_key_store_store_sender_key,
+        .load_fast_ratchet_sender_key = test_sender_key_store_load_sender_key,
+        .destroy_func = test_sender_key_store_destroy,
+        .user_data = data
+    };
+
+    signal_protocol_store_context_set_fast_ratchet_sender_key_store(context, &store);
+}
diff --git a/tests/test_common.h b/tests/test_common.h
index df95613..5a20cd3 100644
--- a/tests/test_common.h
+++ b/tests/test_common.h
@@ -84,4 +84,7 @@ int test_sender_key_store_load_sender_key(signal_buffer **record, const signal_p
 void test_sender_key_store_destroy(void *user_data);
 void setup_test_sender_key_store(signal_protocol_store_context *context, signal_context *global_context);
 
+/* Test fast ratchet sender key store */
+void setup_test_fast_ratchet_sender_key_store(signal_protocol_store_context *context, signal_context *global_context);
+
 #endif /* TEST_COMMON_H */
diff --git a/tests/test_fast_ratchet_group_cipher.c b/tests/test_fast_ratchet_group_cipher.c
new file mode 100644
index 0000000..97ea929
--- /dev/null
+++ b/tests/test_fast_ratchet_group_cipher.c
@@ -0,0 +1,1480 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <check.h>
+#include <pthread.h>
+
+#include "../src/signal_protocol.h"
+#include "../src/signal_protocol_internal.h"
+#include "protocol.h"
+#include "key_helper.h"
+#include "fast_ratchet_util.h"
+#include "fast_ratchet_sender_key.h"
+#include "fast_ratchet_sender_key_record.h"
+#include "fast_ratchet_sender_key_state.h"
+#include "fast_ratchet_group_cipher.h"
+#include "fast_ratchet_group_session_builder.h"
+#include "test_common.h"
+#include "test_utarray.h"
+
+signal_context *global_context;
+pthread_mutex_t global_mutex;
+pthread_mutexattr_t global_mutex_attr;
+
+static signal_protocol_sender_key_name GROUP_SENDER = {
+        "nihilist history broadcast group", 30,
+        {"+14150001111", 12, 1}
+};
+
+static void hmac_sha256(signal_buffer **derivative, uint8_t seed, signal_buffer *key,
+        signal_context *global_context);
+
+int fast_ratchet_sender_chain_key_get_derived_seeds(fast_ratchet_sender_chain_key *key, signal_buffer **derived_keys);
+
+void test_lock(void *user_data)
+{
+    pthread_mutex_lock(&global_mutex);
+}
+
+void test_unlock(void *user_data)
+{
+    pthread_mutex_unlock(&global_mutex);
+}
+
+void test_setup()
+{
+    int result;
+
+    pthread_mutexattr_init(&global_mutex_attr);
+    pthread_mutexattr_settype(&global_mutex_attr, PTHREAD_MUTEX_RECURSIVE);
+    pthread_mutex_init(&global_mutex, &global_mutex_attr);
+
+    result = signal_context_create(&global_context, 0);
+    ck_assert_int_eq(result, 0);
+    signal_context_set_log_function(global_context, test_log);
+
+    setup_test_crypto_provider(global_context);
+
+    result = signal_context_set_locking_functions(global_context, test_lock, test_unlock);
+    ck_assert_int_eq(result, 0);
+}
+
+void test_teardown()
+{
+    signal_context_destroy(global_context);
+}
+
+START_TEST(test_basic_encrypt_decrypt)
+{
+    int result = 0;
+
+    /* Create the test data stores */
+    signal_protocol_store_context *alice_store = 0;
+    setup_test_store_context(&alice_store, global_context);
+
+    signal_protocol_store_context *bob_store = 0;
+    setup_test_store_context(&bob_store, global_context);
+
+    /* Create the session builders */
+    fast_ratchet_group_session_builder *alice_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&alice_session_builder, alice_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_group_session_builder *bob_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&bob_session_builder, bob_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Create the group ciphers */
+    fast_ratchet_group_cipher *alice_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&alice_group_cipher, alice_store, &GROUP_SENDER, global_context);
+
+    fast_ratchet_group_cipher *bob_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&bob_group_cipher, bob_store, &GROUP_SENDER, global_context);
+
+    /* Create the sender key distribution messages */
+    fast_ratchet_sender_key_distribution_message *sent_alice_distribution_message = 0;
+    result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &sent_alice_distribution_message, &GROUP_SENDER, 2);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_sender_key_distribution_message *received_alice_distribution_message = 0;
+    signal_buffer *serialized_distribution_message =
+            ciphertext_message_get_serialized((ciphertext_message *)sent_alice_distribution_message);
+    result = fast_ratchet_sender_key_distribution_message_deserialize(&received_alice_distribution_message,
+            signal_buffer_data(serialized_distribution_message),
+            signal_buffer_len(serialized_distribution_message),
+            global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Processing Alice's distribution message */
+    result = fast_ratchet_group_session_builder_process_session(bob_session_builder, &GROUP_SENDER, received_alice_distribution_message);
+    ck_assert_int_eq(result, 0);
+
+    /* Encrypt a test message from Alice */
+    static const char alice_plaintext[] = "smert ze smert";
+    size_t alice_plaintext_len = sizeof(alice_plaintext) - 1;
+    ciphertext_message *ciphertext_from_alice = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)alice_plaintext, alice_plaintext_len,
+            &ciphertext_from_alice);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob decrypt the message */
+    signal_buffer *plaintext_from_alice = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext_from_alice, 0, &plaintext_from_alice);
+    ck_assert_int_eq(result, 0);
+
+    uint8_t *plaintext_data = signal_buffer_data(plaintext_from_alice);
+    size_t plaintext_len = signal_buffer_len(plaintext_from_alice);
+
+    ck_assert_int_eq(alice_plaintext_len, plaintext_len);
+    ck_assert_int_eq(memcmp(alice_plaintext, plaintext_data, plaintext_len), 0);
+
+    /* Cleanup */
+    signal_buffer_free(plaintext_from_alice);
+    SIGNAL_UNREF(ciphertext_from_alice);
+    SIGNAL_UNREF(received_alice_distribution_message);
+    SIGNAL_UNREF(sent_alice_distribution_message);
+    fast_ratchet_group_cipher_free(bob_group_cipher);
+    fast_ratchet_group_cipher_free(alice_group_cipher);
+    fast_ratchet_group_session_builder_free(bob_session_builder);
+    fast_ratchet_group_session_builder_free(alice_session_builder);
+    signal_protocol_store_context_destroy(bob_store);
+    signal_protocol_store_context_destroy(alice_store);
+}
+END_TEST
+
+START_TEST(test_basic_ratchet)
+{
+    int result = 0;
+
+    /* Create the test data stores */
+    signal_protocol_store_context *alice_store = 0;
+    setup_test_store_context(&alice_store, global_context);
+
+    signal_protocol_store_context *bob_store = 0;
+    setup_test_store_context(&bob_store, global_context);
+
+    /* Create the session builders */
+    fast_ratchet_group_session_builder *alice_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&alice_session_builder, alice_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_group_session_builder *bob_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&bob_session_builder, bob_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    signal_protocol_sender_key_name *alice_name = &GROUP_SENDER;
+
+    /* Create the group ciphers */
+    fast_ratchet_group_cipher *alice_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&alice_group_cipher, alice_store, alice_name, global_context);
+
+    fast_ratchet_group_cipher *bob_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&bob_group_cipher, bob_store, alice_name, global_context);
+
+    /* Create the sender key distribution messages */
+    fast_ratchet_sender_key_distribution_message *sent_alice_distribution_message = 0;
+    result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &sent_alice_distribution_message, alice_name, 2);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_sender_key_distribution_message *received_alice_distribution_message = 0;
+    signal_buffer *serialized_distribution_message =
+            ciphertext_message_get_serialized((ciphertext_message *)sent_alice_distribution_message);
+    result = fast_ratchet_sender_key_distribution_message_deserialize(&received_alice_distribution_message,
+            signal_buffer_data(serialized_distribution_message),
+            signal_buffer_len(serialized_distribution_message),
+            global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Processing Alice's distribution message */
+    result = fast_ratchet_group_session_builder_process_session(bob_session_builder, alice_name, received_alice_distribution_message);
+    ck_assert_int_eq(result, 0);
+
+    /* Prepare some text to encrypt */
+    static const char alice_plaintext[] = "smert ze smert";
+    size_t alice_plaintext_len = sizeof(alice_plaintext) - 1;
+    static const char alice_plaintext_2[] = "smert ze smert2";
+    size_t alice_plaintext_2_len = sizeof(alice_plaintext_2) - 1;
+    static const char alice_plaintext_3[] = "smert ze smert3";
+    size_t alice_plaintext_3_len = sizeof(alice_plaintext_3) - 1;
+
+    /* Encrypt a series of messages from Alice */
+    ciphertext_message *ciphertext_from_alice = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)alice_plaintext, alice_plaintext_len,
+            &ciphertext_from_alice);
+    ck_assert_int_eq(result, 0);
+
+    ciphertext_message *ciphertext_from_alice_2 = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)alice_plaintext_2, alice_plaintext_2_len,
+            &ciphertext_from_alice_2);
+    ck_assert_int_eq(result, 0);
+
+    ciphertext_message *ciphertext_from_alice_3 = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)alice_plaintext_3, alice_plaintext_3_len,
+            &ciphertext_from_alice_3);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob decrypt the message */
+    signal_buffer *plaintext_from_alice = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext_from_alice, 0, &plaintext_from_alice);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob attempt to decrypt the same message again */
+    signal_buffer *plaintext_from_alice_repeat = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext_from_alice, 0, &plaintext_from_alice_repeat);
+    ck_assert_int_eq(result, SG_ERR_DUPLICATE_MESSAGE); /* Should have ratcheted forward */
+    ck_assert_ptr_eq(plaintext_from_alice_repeat, 0);
+
+    /* Have Bob decrypt the remaining messages */
+    signal_buffer *plaintext_from_alice_2 = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext_from_alice_2, 0, &plaintext_from_alice_2);
+    ck_assert_int_eq(result, 0);
+
+    signal_buffer *plaintext_from_alice_3 = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext_from_alice_3, 0, &plaintext_from_alice_3);
+    ck_assert_int_eq(result, 0);
+
+    /* Verify that the plaintext matches */
+    uint8_t *plaintext_data = signal_buffer_data(plaintext_from_alice);
+    size_t plaintext_len = signal_buffer_len(plaintext_from_alice);
+    ck_assert_int_eq(alice_plaintext_len, plaintext_len);
+    ck_assert_int_eq(memcmp(alice_plaintext, plaintext_data, plaintext_len), 0);
+
+    plaintext_data = signal_buffer_data(plaintext_from_alice_2);
+    plaintext_len = signal_buffer_len(plaintext_from_alice_2);
+    ck_assert_int_eq(alice_plaintext_2_len, plaintext_len);
+    ck_assert_int_eq(memcmp(alice_plaintext_2, plaintext_data, plaintext_len), 0);
+
+    plaintext_data = signal_buffer_data(plaintext_from_alice_3);
+    plaintext_len = signal_buffer_len(plaintext_from_alice_3);
+    ck_assert_int_eq(alice_plaintext_3_len, plaintext_len);
+    ck_assert_int_eq(memcmp(alice_plaintext_3, plaintext_data, plaintext_len), 0);
+
+    /* Cleanup */
+    signal_buffer_free(plaintext_from_alice_3);
+    signal_buffer_free(plaintext_from_alice_2);
+    signal_buffer_free(plaintext_from_alice);
+    SIGNAL_UNREF(ciphertext_from_alice_3);
+    SIGNAL_UNREF(ciphertext_from_alice_2);
+    SIGNAL_UNREF(ciphertext_from_alice);
+    SIGNAL_UNREF(received_alice_distribution_message);
+    SIGNAL_UNREF(sent_alice_distribution_message);
+    fast_ratchet_group_cipher_free(bob_group_cipher);
+    fast_ratchet_group_cipher_free(alice_group_cipher);
+    fast_ratchet_group_session_builder_free(bob_session_builder);
+    fast_ratchet_group_session_builder_free(alice_session_builder);
+    signal_protocol_store_context_destroy(bob_store);
+    signal_protocol_store_context_destroy(alice_store);
+}
+END_TEST
+
+START_TEST(test_late_join)
+{
+    int result = 0;
+
+    /* Create the test data stores */
+    signal_protocol_store_context *alice_store = 0;
+    setup_test_store_context(&alice_store, global_context);
+
+    signal_protocol_store_context *bob_store = 0;
+    setup_test_store_context(&bob_store, global_context);
+
+    /* Create Alice's the session builder */
+    fast_ratchet_group_session_builder *alice_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&alice_session_builder, alice_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    signal_protocol_sender_key_name *alice_name = &GROUP_SENDER;
+
+    /* Create Alice's group cipher */
+    fast_ratchet_group_cipher *alice_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&alice_group_cipher, alice_store, alice_name, global_context);
+
+    /* Create Alice's sender key distribution message */
+    fast_ratchet_sender_key_distribution_message *alice_distribution_message = 0;
+    result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &alice_distribution_message, alice_name, 2);
+    ck_assert_int_eq(result, 0);
+    /* Pretend this was sent to some people other than Bob */
+
+    /* Encrypt a batch of messages that Bob never receives */
+    int i = 0;
+    for(i = 0; i < 100; i++) {
+        static const char alice_plaintext[] = "up the punks up the punks up the punks";
+        size_t alice_plaintext_len = sizeof(alice_plaintext) - 1;
+
+        ciphertext_message *ciphertext_from_alice = 0;
+        result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+                (const uint8_t *)alice_plaintext, alice_plaintext_len,
+                &ciphertext_from_alice);
+        ck_assert_int_eq(result, 0);
+        SIGNAL_UNREF(ciphertext_from_alice);
+    }
+
+    /* Now Bob Joins */
+    fast_ratchet_group_session_builder *bob_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&bob_session_builder, bob_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_group_cipher *bob_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&bob_group_cipher, bob_store, alice_name, global_context);
+
+    /* Create Alice's sender key distribution message for Bob */
+    fast_ratchet_sender_key_distribution_message *distribution_message_to_bob = 0;
+    result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &distribution_message_to_bob, alice_name, 2);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_sender_key_distribution_message *received_distribution_message_to_bob = 0;
+    signal_buffer *serialized_distribution_message =
+            ciphertext_message_get_serialized((ciphertext_message *)distribution_message_to_bob);
+    result = fast_ratchet_sender_key_distribution_message_deserialize(&received_distribution_message_to_bob,
+            signal_buffer_data(serialized_distribution_message),
+            signal_buffer_len(serialized_distribution_message),
+            global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob process Alice's distribution message */
+    result = fast_ratchet_group_session_builder_process_session(bob_session_builder, alice_name, received_distribution_message_to_bob);
+    ck_assert_int_eq(result, 0);
+
+    /* Alice sends a message welcoming Bob */
+    static const char welcome_plaintext[] = "welcome to the group";
+    size_t welcome_plaintext_len = sizeof(welcome_plaintext) - 1;
+
+    ciphertext_message *ciphertext = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)welcome_plaintext, welcome_plaintext_len,
+            &ciphertext);
+    ck_assert_int_eq(result, 0);
+
+    /* Bob decrypts the message */
+    signal_buffer *plaintext_from_alice = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message*)ciphertext, 0, &plaintext_from_alice);
+    ck_assert_int_eq(result, 0);
+
+    /* Verify that the plaintext matches */
+    uint8_t *plaintext_data = signal_buffer_data(plaintext_from_alice);
+    size_t plaintext_len = signal_buffer_len(plaintext_from_alice);
+    ck_assert_int_eq(welcome_plaintext_len, plaintext_len);
+    ck_assert_int_eq(memcmp(welcome_plaintext, plaintext_data, plaintext_len), 0);
+
+    /* Cleanup */
+    signal_buffer_free(plaintext_from_alice);
+    SIGNAL_UNREF(ciphertext);
+    SIGNAL_UNREF(received_distribution_message_to_bob);
+    SIGNAL_UNREF(distribution_message_to_bob);
+    fast_ratchet_group_cipher_free(bob_group_cipher);
+    fast_ratchet_group_session_builder_free(bob_session_builder);
+    SIGNAL_UNREF(alice_distribution_message);
+    fast_ratchet_group_cipher_free(alice_group_cipher);
+    fast_ratchet_group_session_builder_free(alice_session_builder);
+    signal_protocol_store_context_destroy(bob_store);
+    signal_protocol_store_context_destroy(alice_store);
+}
+END_TEST
+
+START_TEST(test_out_of_order_unsupported)
+{
+    int result = 0;
+
+    /* Create the test data stores */
+    signal_protocol_store_context *alice_store = 0;
+    setup_test_store_context(&alice_store, global_context);
+
+    signal_protocol_store_context *bob_store = 0;
+    setup_test_store_context(&bob_store, global_context);
+
+    /* Create the session builders */
+    fast_ratchet_group_session_builder *alice_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&alice_session_builder, alice_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_group_session_builder *bob_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&bob_session_builder, bob_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    signal_protocol_sender_key_name *alice_name = &GROUP_SENDER;
+
+    /* Create the group ciphers */
+    fast_ratchet_group_cipher *alice_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&alice_group_cipher, alice_store, alice_name, global_context);
+
+    fast_ratchet_group_cipher *bob_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&bob_group_cipher, bob_store, alice_name, global_context);
+
+    /* Create Alice's sender key distribution message */
+    fast_ratchet_sender_key_distribution_message *alice_distribution_message = 0;
+    result = fast_ratchet_group_session_builder_create_session(
+            alice_session_builder, &alice_distribution_message, alice_name, 3);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob process the distribution message */
+    result = fast_ratchet_group_session_builder_process_session(bob_session_builder, alice_name, alice_distribution_message);
+    ck_assert_int_eq(result, 0);
+
+    /* Prepare some text to encrypt */
+    static const char plaintext1[] = "up the punks1";
+    size_t plaintext1_len = sizeof(plaintext1) - 1;
+    static const char plaintext2[] = "up the punks2";
+    size_t plaintext2_len = sizeof(plaintext2) - 1;
+    static const char plaintext3[] = "up the punks3";
+    size_t plaintext3_len = sizeof(plaintext3) - 1;
+    static const char plaintext4[] = "up the punks4";
+    size_t plaintext4_len = sizeof(plaintext4) - 1;
+
+    /* Encrypt a series of messages from Alice */
+    ciphertext_message *ciphertext1 = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)plaintext1, plaintext1_len,
+            &ciphertext1);
+    ck_assert_int_eq(result, 0);
+
+    ciphertext_message *ciphertext2 = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)plaintext2, plaintext2_len,
+            &ciphertext2);
+    ck_assert_int_eq(result, 0);
+
+    ciphertext_message *ciphertext3 = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)plaintext3, plaintext3_len,
+            &ciphertext3);
+    ck_assert_int_eq(result, 0);
+
+    ciphertext_message *ciphertext4 = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)plaintext4, plaintext4_len,
+            &ciphertext4);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob decrypt message 2 */
+    signal_buffer *plaintext_from_alice_2 = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext2, 0, &plaintext_from_alice_2);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob attempt to decrypt message 1 */
+    signal_buffer *plaintext_from_alice_1 = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext1, 0, &plaintext_from_alice_1);
+    ck_assert_int_eq(result, SG_ERR_DUPLICATE_MESSAGE); /* Should have ratcheted forward */
+    ck_assert_ptr_eq(plaintext_from_alice_1, 0);
+
+    /* Have Bob decrypt message 4 */
+    signal_buffer *plaintext_from_alice_4 = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext4, 0, &plaintext_from_alice_4);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob attempt to decrypt message 3 */
+    signal_buffer *plaintext_from_alice_3 = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext3, 0, &plaintext_from_alice_3);
+    ck_assert_int_eq(result, SG_ERR_DUPLICATE_MESSAGE); /* Should have ratcheted forward */
+    ck_assert_ptr_eq(plaintext_from_alice_3, 0);
+
+    /* Verify that the plaintext matches */
+    uint8_t *plaintext_data = signal_buffer_data(plaintext_from_alice_2);
+    size_t plaintext_len = signal_buffer_len(plaintext_from_alice_2);
+    ck_assert_int_eq(plaintext2_len, plaintext_len);
+    ck_assert_int_eq(memcmp(plaintext2, plaintext_data, plaintext_len), 0);
+
+    plaintext_data = signal_buffer_data(plaintext_from_alice_4);
+    plaintext_len = signal_buffer_len(plaintext_from_alice_4);
+    ck_assert_int_eq(plaintext4_len, plaintext_len);
+    ck_assert_int_eq(memcmp(plaintext4, plaintext_data, plaintext_len), 0);
+
+    /* Cleanup */
+    SIGNAL_UNREF(ciphertext1);
+    SIGNAL_UNREF(ciphertext2);
+    SIGNAL_UNREF(ciphertext3);
+    SIGNAL_UNREF(ciphertext4);
+    signal_buffer_free(plaintext_from_alice_2);
+    signal_buffer_free(plaintext_from_alice_4);
+    SIGNAL_UNREF(alice_distribution_message);
+    fast_ratchet_group_cipher_free(bob_group_cipher);
+    fast_ratchet_group_cipher_free(alice_group_cipher);
+    fast_ratchet_group_session_builder_free(bob_session_builder);
+    fast_ratchet_group_session_builder_free(alice_session_builder);
+    signal_protocol_store_context_destroy(bob_store);
+    signal_protocol_store_context_destroy(alice_store);
+}
+END_TEST
+
+static void run_encrypt_with_lossy_decrypt(int scale, int skip1, int skip2, int skip3)
+{
+    int result = 0;
+
+    /* Create the test data stores */
+    signal_protocol_store_context *alice_store = 0;
+    setup_test_store_context(&alice_store, global_context);
+
+    signal_protocol_store_context *bob_store = 0;
+    setup_test_store_context(&bob_store, global_context);
+
+    /* Create the session builders */
+    fast_ratchet_group_session_builder *alice_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&alice_session_builder, alice_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_group_session_builder *bob_session_builder = 0;
+    result = fast_ratchet_group_session_builder_create(&bob_session_builder, bob_store, global_context);
+    ck_assert_int_eq(result, 0);
+
+    signal_protocol_sender_key_name *alice_name = &GROUP_SENDER;
+
+    /* Create the group ciphers */
+    fast_ratchet_group_cipher *alice_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&alice_group_cipher, alice_store, alice_name, global_context);
+
+    fast_ratchet_group_cipher *bob_group_cipher = 0;
+    result = fast_ratchet_group_cipher_create(&bob_group_cipher, bob_store, alice_name, global_context);
+
+    /* Create Alice's sender key distribution message */
+    fast_ratchet_sender_key_distribution_message *alice_distribution_message = 0;
+    result = fast_ratchet_group_session_builder_create_session(
+            alice_session_builder, &alice_distribution_message, alice_name, 3);
+    ck_assert_int_eq(result, 0);
+
+    /* Have Bob process the distribution message */
+    result = fast_ratchet_group_session_builder_process_session(bob_session_builder, alice_name, alice_distribution_message);
+    ck_assert_int_eq(result, 0);
+
+    int expected_iteration = 0;
+
+    /* Prepare some text to encrypt */
+    static const char missed_plaintext[] = "missed smert ze smert";
+    size_t missed_plaintext_len = sizeof(missed_plaintext) - 1;
+    static const char alice_plaintext1[] = "smert ze smert";
+    size_t alice_plaintext1_len = sizeof(alice_plaintext1) - 1;
+    static const char alice_plaintext2[] = "smert ze smert2";
+    size_t alice_plaintext2_len = sizeof(alice_plaintext2) - 1;
+    static const char alice_plaintext3[] = "smert ze smert3";
+    size_t alice_plaintext3_len = sizeof(alice_plaintext3) - 1;
+
+    /* Encrypt a series of messages, only retaining a few of them */
+    for(int i = 0; i < skip1; i++) {
+        ciphertext_message *ciphertext = 0;
+        result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+                (const uint8_t *)missed_plaintext, missed_plaintext_len,
+                &ciphertext);
+        ck_assert_int_eq(result, 0);
+        SIGNAL_UNREF(ciphertext);
+    }
+
+    ciphertext_message *ciphertext_from_alice = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)alice_plaintext1, alice_plaintext1_len,
+            &ciphertext_from_alice);
+    ck_assert_int_eq(result, 0);
+
+    expected_iteration += skip1 + 1;
+
+    for(int i = 0; i < skip2; i++) {
+        ciphertext_message *ciphertext = 0;
+        result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+                (const uint8_t *)missed_plaintext, missed_plaintext_len,
+                &ciphertext);
+        ck_assert_int_eq(result, 0);
+        SIGNAL_UNREF(ciphertext);
+    }
+
+    ciphertext_message *ciphertext_from_alice2 = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)alice_plaintext2, alice_plaintext2_len,
+            &ciphertext_from_alice2);
+    ck_assert_int_eq(result, 0);
+
+    expected_iteration += skip2 + 1;
+
+    for(int i = 0; i < skip3; i++) {
+        ciphertext_message *ciphertext = 0;
+        result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+                (const uint8_t *)missed_plaintext, missed_plaintext_len,
+                &ciphertext);
+        ck_assert_int_eq(result, 0);
+        SIGNAL_UNREF(ciphertext);
+    }
+
+    ciphertext_message *ciphertext_from_alice3 = 0;
+    result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+            (const uint8_t *)alice_plaintext3, alice_plaintext3_len,
+            &ciphertext_from_alice3);
+    ck_assert_int_eq(result, 0);
+
+    expected_iteration += skip3 + 1;
+
+    /* Verify that the sender is on the expected iteration */
+    fast_ratchet_sender_key_record *alice_record = 0;
+    result = signal_protocol_fast_ratchet_sender_key_load_key(alice_store, &alice_record, alice_name);
+    ck_assert_int_eq(result, 0);
+    fast_ratchet_sender_key_state *alice_state = 0;
+    result = fast_ratchet_sender_key_record_get_sender_key_state(alice_record, &alice_state);
+    ck_assert_int_eq(result, 0);
+
+    ck_assert_int_eq(expected_iteration,
+            fast_ratchet_sender_chain_key_get_iteration(
+                    fast_ratchet_sender_key_state_get_chain_key(alice_state)));
+
+    /* Decrypt the few messages we retained */
+    signal_buffer *plaintext_from_alice = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext_from_alice, 0, &plaintext_from_alice);
+    ck_assert_int_eq(result, 0);
+
+    signal_buffer *plaintext_from_alice2 = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext_from_alice2, 0, &plaintext_from_alice2);
+    ck_assert_int_eq(result, 0);
+
+    signal_buffer *plaintext_from_alice3 = 0;
+    result = fast_ratchet_group_cipher_decrypt(bob_group_cipher, (sender_key_message *)ciphertext_from_alice3, 0, &plaintext_from_alice3);
+    ck_assert_int_eq(result, 0);
+
+    /* Verify that the plaintext matches */
+    uint8_t *plaintext_data = signal_buffer_data(plaintext_from_alice);
+    size_t plaintext_len = signal_buffer_len(plaintext_from_alice);
+    ck_assert_int_eq(alice_plaintext1_len, plaintext_len);
+    ck_assert_int_eq(memcmp(alice_plaintext1, plaintext_data, plaintext_len), 0);
+
+    plaintext_data = signal_buffer_data(plaintext_from_alice2);
+    plaintext_len = signal_buffer_len(plaintext_from_alice2);
+    ck_assert_int_eq(alice_plaintext2_len, plaintext_len);
+    ck_assert_int_eq(memcmp(alice_plaintext2, plaintext_data, plaintext_len), 0);
+
+    plaintext_data = signal_buffer_data(plaintext_from_alice3);
+    plaintext_len = signal_buffer_len(plaintext_from_alice3);
+    ck_assert_int_eq(alice_plaintext3_len, plaintext_len);
+    ck_assert_int_eq(memcmp(alice_plaintext3, plaintext_data, plaintext_len), 0);
+
+    /* Verify that receiver is also on the expected iteration */
+    fast_ratchet_sender_key_record *bob_record = 0;
+    result = signal_protocol_fast_ratchet_sender_key_load_key(bob_store, &bob_record, alice_name);
+    ck_assert_int_eq(result, 0);
+    fast_ratchet_sender_key_state *bob_state = 0;
+    result = fast_ratchet_sender_key_record_get_sender_key_state(bob_record, &bob_state);
+    ck_assert_int_eq(result, 0);
+
+    ck_assert_int_eq(expected_iteration,
+            fast_ratchet_sender_chain_key_get_iteration(
+                    fast_ratchet_sender_key_state_get_chain_key(bob_state)));
+
+    /* Cleanup */
+    SIGNAL_UNREF(bob_record);
+    signal_buffer_free(plaintext_from_alice);
+    signal_buffer_free(plaintext_from_alice2);
+    signal_buffer_free(plaintext_from_alice3);
+    SIGNAL_UNREF(alice_record);
+    SIGNAL_UNREF(alice_distribution_message);
+    SIGNAL_UNREF(ciphertext_from_alice);
+    SIGNAL_UNREF(ciphertext_from_alice2);
+    SIGNAL_UNREF(ciphertext_from_alice3);
+    fast_ratchet_group_cipher_free(bob_group_cipher);
+    fast_ratchet_group_cipher_free(alice_group_cipher);
+    fast_ratchet_group_session_builder_free(bob_session_builder);
+    fast_ratchet_group_session_builder_free(alice_session_builder);
+    signal_protocol_store_context_destroy(bob_store);
+    signal_protocol_store_context_destroy(alice_store);
+}
+
+START_TEST(test_encrypt_with_lossy_decrypt)
+{
+    run_encrypt_with_lossy_decrypt(0, 1, 2, 10);
+    run_encrypt_with_lossy_decrypt(1, 10, 20, 30);
+    run_encrypt_with_lossy_decrypt(2, 100, 100, 100);
+    run_encrypt_with_lossy_decrypt(3, 16, 48, 18);
+    run_encrypt_with_lossy_decrypt(4, 99, 14, 6);
+    run_encrypt_with_lossy_decrypt(5, 126, 1, 1);
+}
+END_TEST
+
+START_TEST(test_initial_single_chain_state)
+{
+    int result = 0;
+
+    signal_buffer *initial_seed = 0;
+    result = signal_protocol_key_helper_generate_sender_key(&initial_seed, global_context);
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    result = fast_ratchet_sender_chain_key_create_initial(&chain_key, initial_seed, 0, global_context);
+    ck_assert_int_eq(result, 0);
+
+    ck_assert_int_eq(0, fast_ratchet_sender_chain_key_get_iteration(chain_key));
+
+    signal_buffer_list *seeds = fast_ratchet_sender_chain_key_get_seeds(chain_key);
+    ck_assert_int_eq(1, signal_buffer_list_size(seeds));
+
+    ck_assert_int_eq(0, signal_buffer_compare(initial_seed, signal_buffer_list_at(seeds, 0)));
+    ck_assert_ptr_ne(initial_seed, signal_buffer_list_at(seeds, 0));
+
+    /* Cleanup */
+    signal_buffer_free(initial_seed);
+    SIGNAL_UNREF(chain_key);
+}
+END_TEST
+
+START_TEST(test_initial_multi_chain_state)
+{
+    int result = 0;
+
+    signal_buffer *initial_seed = 0;
+    result = signal_protocol_key_helper_generate_sender_key(&initial_seed, global_context);
+    ck_assert_int_eq(result, 0);
+
+    for(int i = 1; i <= 5; i++) {
+        fast_ratchet_sender_chain_key *chain_key = 0;
+        result = fast_ratchet_sender_chain_key_create_initial(&chain_key, initial_seed, i, global_context);
+        ck_assert_int_eq(result, 0);
+
+        int expected_chains = fast_ratchet_scale_to_dimensions(i);
+
+        ck_assert_int_eq(0, fast_ratchet_sender_chain_key_get_iteration(chain_key));
+
+        signal_buffer *derived_seeds[FAST_RATCHET_MAX_CHAINS];
+        memset(derived_seeds, 0, sizeof(derived_seeds));
+
+        signal_buffer_list *seeds = fast_ratchet_sender_chain_key_get_seeds(chain_key);
+        ck_assert_int_eq(expected_chains, signal_buffer_list_size(seeds));
+
+        result = fast_ratchet_sender_chain_key_get_derived_seeds(chain_key, derived_seeds);
+        ck_assert_int_eq(result, 0);
+
+        for(int j = 0; j < expected_chains; j++) {
+            ck_assert_int_ne(0, signal_buffer_compare(initial_seed, derived_seeds[j]));
+            signal_buffer_free(derived_seeds[j]);
+        }
+
+        SIGNAL_UNREF(chain_key);
+    }
+
+    /* Cleanup */
+    signal_buffer_free(initial_seed);
+}
+END_TEST
+
+START_TEST(test_initial_chain_state)
+{
+    int result = 0;
+
+    signal_buffer *initial_seed = 0;
+    result = signal_protocol_key_helper_generate_sender_key(&initial_seed, global_context);
+    ck_assert_int_eq(result, 0);
+
+    signal_buffer *CK1 = 0;
+    signal_buffer *CK2 = 0;
+    signal_buffer *CK3 = 0;
+    signal_buffer *CK4 = 0;
+
+    // Create the expected chains
+    CK1 = signal_buffer_copy(initial_seed);
+    ck_assert_ptr_ne(0, CK1);
+
+    hmac_sha256(&CK2, 0x03, CK1, global_context);
+    hmac_sha256(&CK1, 0x02, CK1, global_context);
+
+    hmac_sha256(&CK3, 0x04, CK2, global_context);
+    hmac_sha256(&CK2, 0x03, CK2, global_context);
+
+    hmac_sha256(&CK4, 0x05, CK3, global_context);
+    hmac_sha256(&CK3, 0x04, CK3, global_context);
+
+    // Compute and verify the actual chains
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    result = fast_ratchet_sender_chain_key_create_initial(&chain_key, initial_seed, 2, global_context);
+    ck_assert_int_eq(result, 0);
+
+    ck_assert_int_eq(0, fast_ratchet_sender_chain_key_get_iteration(chain_key));
+    signal_buffer_list *seeds = fast_ratchet_sender_chain_key_get_seeds(chain_key);
+    ck_assert_int_eq(4, signal_buffer_list_size(seeds));
+
+    signal_buffer *derived_seeds[FAST_RATCHET_MAX_CHAINS];
+    memset(derived_seeds, 0, sizeof(derived_seeds));
+
+    result = fast_ratchet_sender_chain_key_get_derived_seeds(chain_key, derived_seeds);
+    ck_assert_int_eq(result, 0);
+
+    ck_assert_int_eq(0, signal_buffer_compare(CK1, derived_seeds[0]));
+    ck_assert_int_eq(0, signal_buffer_compare(CK2, derived_seeds[1]));
+    ck_assert_int_eq(0, signal_buffer_compare(CK3, derived_seeds[2]));
+    ck_assert_int_eq(0, signal_buffer_compare(CK4, derived_seeds[3]));
+
+    /* Cleanup */
+    signal_buffer_free(initial_seed);
+    signal_buffer_free(CK1);
+    signal_buffer_free(CK2);
+    signal_buffer_free(CK3);
+    signal_buffer_free(CK4);
+    signal_buffer_free(derived_seeds[0]);
+    signal_buffer_free(derived_seeds[1]);
+    signal_buffer_free(derived_seeds[2]);
+    signal_buffer_free(derived_seeds[3]);
+    SIGNAL_UNREF(chain_key);
+}
+END_TEST
+
+START_TEST(test_intermediate_ratchet)
+{
+    int result = 0;
+
+    signal_buffer *CK1 = 0;
+    signal_buffer *CK2 = 0;
+    signal_buffer *CK3 = 0;
+    signal_buffer *CK4 = 0;
+
+    result = signal_protocol_key_helper_generate_sender_key(&CK1, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK2, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK3, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK4, global_context);
+    ck_assert_int_eq(result, 0);
+
+    uint32_t initial_iteration = 356;
+    uint32_t final_iteration = 66306;
+
+    signal_buffer_list *chain_seeds = signal_buffer_list_alloc();
+    ck_assert_ptr_ne(0, chain_seeds);
+
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK1));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK2));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK3));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK4));
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    result = fast_ratchet_sender_chain_key_create(&chain_key, initial_iteration, chain_seeds, global_context);
+    ck_assert_int_eq(result, 0);
+
+    // Create the expected chain operation results
+    // New CK3 from CK2
+    hmac_sha256(&CK3, 0x04, CK2, global_context);
+
+    // Ratchet CK2
+    hmac_sha256(&CK2, 0x03, CK2, global_context);
+
+    // Ratchet CK3
+    hmac_sha256(&CK3, 0x04, CK3, global_context);
+    hmac_sha256(&CK3, 0x04, CK3, global_context);
+    hmac_sha256(&CK3, 0x04, CK3, global_context);
+
+    // New CK4 from CK3
+    hmac_sha256(&CK4, 0x05, CK3, global_context);
+
+    // Ratchet CK3 one last time
+    hmac_sha256(&CK3, 0x04, CK3, global_context);
+
+    // Ratchet CK4
+    hmac_sha256(&CK4, 0x05, CK4, global_context);
+    hmac_sha256(&CK4, 0x05, CK4, global_context);
+
+    // Compare to actual results
+    fast_ratchet_sender_chain_key *final_key = 0;
+    result = fast_ratchet_sender_chain_key_create_next(chain_key, &final_key, final_iteration - initial_iteration);
+    ck_assert_int_eq(result, 0);
+
+    ck_assert_int_eq(final_iteration, fast_ratchet_sender_chain_key_get_iteration(final_key));
+
+    signal_buffer_list *seeds = fast_ratchet_sender_chain_key_get_seeds(final_key);
+    ck_assert_int_eq(4, signal_buffer_list_size(seeds));
+
+    ck_assert_int_eq(0, signal_buffer_compare(CK1, signal_buffer_list_at(seeds, 0)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK2, signal_buffer_list_at(seeds, 1)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK3, signal_buffer_list_at(seeds, 2)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK4, signal_buffer_list_at(seeds, 3)));
+
+    /* Cleanup */
+    signal_buffer_free(CK1);
+    signal_buffer_free(CK2);
+    signal_buffer_free(CK3);
+    signal_buffer_free(CK4);
+    signal_buffer_list_free(chain_seeds);
+    SIGNAL_UNREF(chain_key);
+    SIGNAL_UNREF(final_key);
+}
+END_TEST
+
+START_TEST(test_large_scale_ratchet)
+{
+    int result = 0;
+
+    signal_buffer *CK1 = 0;
+    signal_buffer *CK2 = 0;
+    signal_buffer *CK3 = 0;
+    signal_buffer *CK4 = 0;
+    signal_buffer *CK5 = 0;
+    signal_buffer *CK6 = 0;
+    signal_buffer *CK7 = 0;
+    signal_buffer *CK8 = 0;
+    signal_buffer *CK9 = 0;
+    signal_buffer *CK10 = 0;
+    signal_buffer *CK11 = 0;
+    signal_buffer *CK12 = 0;
+    signal_buffer *CK13 = 0;
+    signal_buffer *CK14 = 0;
+    signal_buffer *CK15 = 0;
+    signal_buffer *CK16 = 0;
+
+    result = signal_protocol_key_helper_generate_sender_key(&CK1, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK2, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK3, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK4, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK5, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK6, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK7, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK8, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK9, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK10, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK11, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK12, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK13, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK14, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK15, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK16, global_context);
+    ck_assert_int_eq(result, 0);
+
+    uint32_t initial_iteration = 0;
+    uint32_t final_iteration = 85;
+
+    signal_buffer_list *chain_seeds = signal_buffer_list_alloc();
+    ck_assert_ptr_ne(0, chain_seeds);
+
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK1));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK2));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK3));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK4));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK5));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK6));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK7));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK8));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK9));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK10));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK11));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK12));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK13));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK14));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK15));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK16));
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    result = fast_ratchet_sender_chain_key_create(&chain_key, initial_iteration, chain_seeds, global_context);
+    ck_assert_int_eq(result, 0);
+
+    // Create the expected chain operation results
+    // CK:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
+    // From: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
+    // To:   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1]
+
+    // New CK14 from CK13
+    hmac_sha256(&CK14, 0x0F, CK13, global_context);
+
+    // Ratchet CK13
+    hmac_sha256(&CK13, 0x0E, CK13, global_context);
+
+    // Ratchet CK14
+    hmac_sha256(&CK14, 0x0F, CK14, global_context);
+
+    // New CK15 from CK14
+    hmac_sha256(&CK15, 0x10, CK14, global_context);
+
+    // Ratchet CK14 one last time
+    hmac_sha256(&CK14, 0x0F, CK14, global_context);
+
+    // Ratchet CK15
+    hmac_sha256(&CK15, 0x10, CK15, global_context);
+
+    // New CK16 from CK15
+    hmac_sha256(&CK16, 0x11, CK15, global_context);
+
+    // Ratchet CK15 one last time
+    hmac_sha256(&CK15, 0x10, CK15, global_context);
+
+    // Ratchet CK16
+    hmac_sha256(&CK16, 0x11, CK16, global_context);
+
+    // Compare to actual results
+    fast_ratchet_sender_chain_key *final_key = 0;
+    result = fast_ratchet_sender_chain_key_create_next(chain_key, &final_key, final_iteration - initial_iteration);
+    ck_assert_int_eq(result, 0);
+
+    ck_assert_int_eq(final_iteration, fast_ratchet_sender_chain_key_get_iteration(final_key));
+
+    signal_buffer_list *seeds = fast_ratchet_sender_chain_key_get_seeds(final_key);
+    ck_assert_int_eq(16, signal_buffer_list_size(seeds));
+
+    ck_assert_int_eq(0, signal_buffer_compare(CK1, signal_buffer_list_at(seeds, 0)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK2, signal_buffer_list_at(seeds, 1)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK3, signal_buffer_list_at(seeds, 2)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK4, signal_buffer_list_at(seeds, 3)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK5, signal_buffer_list_at(seeds, 4)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK6, signal_buffer_list_at(seeds, 5)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK7, signal_buffer_list_at(seeds, 6)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK8, signal_buffer_list_at(seeds, 7)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK9, signal_buffer_list_at(seeds, 8)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK10, signal_buffer_list_at(seeds, 9)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK11, signal_buffer_list_at(seeds, 10)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK12, signal_buffer_list_at(seeds, 11)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK13, signal_buffer_list_at(seeds, 12)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK14, signal_buffer_list_at(seeds, 13)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK15, signal_buffer_list_at(seeds, 14)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK16, signal_buffer_list_at(seeds, 15)));
+
+    /* Cleanup */
+    signal_buffer_free(CK1);
+    signal_buffer_free(CK2);
+    signal_buffer_free(CK3);
+    signal_buffer_free(CK4);
+    signal_buffer_free(CK5);
+    signal_buffer_free(CK6);
+    signal_buffer_free(CK7);
+    signal_buffer_free(CK8);
+    signal_buffer_free(CK9);
+    signal_buffer_free(CK10);
+    signal_buffer_free(CK11);
+    signal_buffer_free(CK12);
+    signal_buffer_free(CK13);
+    signal_buffer_free(CK14);
+    signal_buffer_free(CK15);
+    signal_buffer_free(CK16);
+    signal_buffer_list_free(chain_seeds);
+    SIGNAL_UNREF(chain_key);
+    SIGNAL_UNREF(final_key);
+}
+END_TEST
+
+START_TEST(test_large_scale_ratchet_with_rollover)
+{
+    int result = 0;
+
+    signal_buffer *CK1 = 0;
+    signal_buffer *CK2 = 0;
+    signal_buffer *CK3 = 0;
+    signal_buffer *CK4 = 0;
+    signal_buffer *CK5 = 0;
+    signal_buffer *CK6 = 0;
+    signal_buffer *CK7 = 0;
+    signal_buffer *CK8 = 0;
+    signal_buffer *CK9 = 0;
+    signal_buffer *CK10 = 0;
+    signal_buffer *CK11 = 0;
+    signal_buffer *CK12 = 0;
+    signal_buffer *CK13 = 0;
+    signal_buffer *CK14 = 0;
+    signal_buffer *CK15 = 0;
+    signal_buffer *CK16 = 0;
+
+    result = signal_protocol_key_helper_generate_sender_key(&CK1, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK2, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK3, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK4, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK5, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK6, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK7, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK8, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK9, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK10, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK11, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK12, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK13, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK14, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK15, global_context);
+    ck_assert_int_eq(result, 0);
+    result = signal_protocol_key_helper_generate_sender_key(&CK16, global_context);
+    ck_assert_int_eq(result, 0);
+
+    uint32_t initial_iteration = 0;
+    uint32_t final_iteration = 174;
+
+    signal_buffer_list *chain_seeds = signal_buffer_list_alloc();
+    ck_assert_ptr_ne(0, chain_seeds);
+
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK1));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK2));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK3));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK4));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK5));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK6));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK7));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK8));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK9));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK10));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK11));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK12));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK13));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK14));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK15));
+    ck_assert_int_eq(result, 0);
+    result = signal_buffer_list_push_back(chain_seeds, signal_buffer_copy(CK16));
+    ck_assert_int_eq(result, 0);
+
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    result = fast_ratchet_sender_chain_key_create(&chain_key, initial_iteration, chain_seeds, global_context);
+    ck_assert_int_eq(result, 0);
+
+    // Create the expected chain operation results
+    // CK:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
+    // From: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
+    // To:   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 4, 2]
+
+    // Ratchet CK13
+    hmac_sha256(&CK13, 0x0E, CK13, global_context);
+
+    // New CK14 from CK13
+    hmac_sha256(&CK14, 0x0F, CK13, global_context);
+
+    // Ratchet CK13
+    hmac_sha256(&CK13, 0x0E, CK13, global_context);
+
+    // Ratchet CK14 twice
+    hmac_sha256(&CK14, 0x0F, CK14, global_context);
+    hmac_sha256(&CK14, 0x0F, CK14, global_context);
+
+    // New CK15 from CK14
+    hmac_sha256(&CK15, 0x10, CK14, global_context);
+
+    // Ratchet CK14
+    hmac_sha256(&CK14, 0x0F, CK14, global_context);
+
+    // Ratchet CK15 three times
+    hmac_sha256(&CK15, 0x10, CK15, global_context);
+    hmac_sha256(&CK15, 0x10, CK15, global_context);
+    hmac_sha256(&CK15, 0x10, CK15, global_context);
+
+    // New CK16 from CK15
+    hmac_sha256(&CK16, 0x11, CK15, global_context);
+
+    // Ratchet CK15
+    hmac_sha256(&CK15, 0x10, CK15, global_context);
+
+    // Ratchet CK16 twice
+    hmac_sha256(&CK16, 0x11, CK16, global_context);
+    hmac_sha256(&CK16, 0x11, CK16, global_context);
+
+    // Compare to actual results
+    fast_ratchet_sender_chain_key *final_key = 0;
+    result = fast_ratchet_sender_chain_key_create_next(chain_key, &final_key, final_iteration - initial_iteration);
+    ck_assert_int_eq(result, 0);
+
+    ck_assert_int_eq(final_iteration, fast_ratchet_sender_chain_key_get_iteration(final_key));
+
+    signal_buffer_list *seeds = fast_ratchet_sender_chain_key_get_seeds(final_key);
+    ck_assert_int_eq(16, signal_buffer_list_size(seeds));
+
+    ck_assert_int_eq(0, signal_buffer_compare(CK1, signal_buffer_list_at(seeds, 0)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK2, signal_buffer_list_at(seeds, 1)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK3, signal_buffer_list_at(seeds, 2)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK4, signal_buffer_list_at(seeds, 3)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK5, signal_buffer_list_at(seeds, 4)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK6, signal_buffer_list_at(seeds, 5)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK7, signal_buffer_list_at(seeds, 6)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK8, signal_buffer_list_at(seeds, 7)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK9, signal_buffer_list_at(seeds, 8)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK10, signal_buffer_list_at(seeds, 9)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK11, signal_buffer_list_at(seeds, 10)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK12, signal_buffer_list_at(seeds, 11)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK13, signal_buffer_list_at(seeds, 12)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK14, signal_buffer_list_at(seeds, 13)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK15, signal_buffer_list_at(seeds, 14)));
+    ck_assert_int_eq(0, signal_buffer_compare(CK16, signal_buffer_list_at(seeds, 15)));
+
+    /* Cleanup */
+    signal_buffer_free(CK1);
+    signal_buffer_free(CK2);
+    signal_buffer_free(CK3);
+    signal_buffer_free(CK4);
+    signal_buffer_free(CK5);
+    signal_buffer_free(CK6);
+    signal_buffer_free(CK7);
+    signal_buffer_free(CK8);
+    signal_buffer_free(CK9);
+    signal_buffer_free(CK10);
+    signal_buffer_free(CK11);
+    signal_buffer_free(CK12);
+    signal_buffer_free(CK13);
+    signal_buffer_free(CK14);
+    signal_buffer_free(CK15);
+    signal_buffer_free(CK16);
+    signal_buffer_list_free(chain_seeds);
+    SIGNAL_UNREF(chain_key);
+    SIGNAL_UNREF(final_key);
+}
+END_TEST
+
+void hmac_sha256(signal_buffer **derivative, uint8_t seed, signal_buffer *key,
+        signal_context *global_context)
+{
+    int result = 0;
+    signal_buffer *output_buffer = 0;
+    void *hmac_context = 0;
+
+    result = signal_hmac_sha256_init(global_context, &hmac_context,
+            signal_buffer_data(key), signal_buffer_len(key));
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = signal_hmac_sha256_update(global_context, hmac_context, &seed, sizeof(seed));
+    if(result < 0) {
+        goto complete;
+    }
+
+    result = signal_hmac_sha256_final(global_context, hmac_context, &output_buffer);
+    if(result < 0) {
+        goto complete;
+    }
+
+complete:
+    signal_hmac_sha256_cleanup(global_context, hmac_context);
+
+    if(result < 0) {
+        signal_buffer_free(output_buffer);
+    }
+    else {
+        if(*derivative) {
+            signal_buffer_free(*derivative);
+        }
+        *derivative = output_buffer;
+    }
+    ck_assert_int_eq(result, 0);
+}
+
+START_TEST(test_distribution_message_sizes)
+{
+    int result = 0;
+
+     /* Create the test data store */
+     signal_protocol_store_context *alice_store = 0;
+     setup_test_store_context(&alice_store, global_context);
+
+     /* Create the session builder */
+     fast_ratchet_group_session_builder *alice_session_builder = 0;
+     result = fast_ratchet_group_session_builder_create(&alice_session_builder, alice_store, global_context);
+     ck_assert_int_eq(result, 0);
+
+     /* Create the group cipher */
+     fast_ratchet_group_cipher *alice_group_cipher = 0;
+     result = fast_ratchet_group_cipher_create(&alice_group_cipher, alice_store, &GROUP_SENDER, global_context);
+
+     /* Create the sender key distribution messages for iteration 0 */
+     fast_ratchet_sender_key_distribution_message *distribution_message_0 = 0;
+     result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &distribution_message_0, &GROUP_SENDER, 2);
+     ck_assert_int_eq(result, 0);
+
+     signal_buffer *serialized_distribution_message_0 =
+             ciphertext_message_get_serialized((ciphertext_message *)distribution_message_0);
+
+     /* Encrypt a test message from Alice */
+     static const char alice_plaintext[] = "smert ze smert";
+     size_t alice_plaintext_len = sizeof(alice_plaintext) - 1;
+     ciphertext_message *ciphertext_from_alice = 0;
+     result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+             (const uint8_t *)alice_plaintext, alice_plaintext_len,
+             &ciphertext_from_alice);
+     ck_assert_int_eq(result, 0);
+     SIGNAL_UNREF(ciphertext_from_alice);
+
+     /* Create the sender key distribution messages for iteration 1 */
+     fast_ratchet_sender_key_distribution_message *distribution_message_1 = 0;
+     result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &distribution_message_1, &GROUP_SENDER, 2);
+     ck_assert_int_eq(result, 0);
+
+     signal_buffer *serialized_distribution_message_1 =
+             ciphertext_message_get_serialized((ciphertext_message *)distribution_message_1);
+
+     /* Encrypt another test message from Alice */
+     result = fast_ratchet_group_cipher_encrypt(alice_group_cipher,
+             (const uint8_t *)alice_plaintext, alice_plaintext_len,
+             &ciphertext_from_alice);
+     ck_assert_int_eq(result, 0);
+     SIGNAL_UNREF(ciphertext_from_alice);
+
+     /* Create the sender key distribution messages for iteration 2 */
+     fast_ratchet_sender_key_distribution_message *distribution_message_2 = 0;
+     result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &distribution_message_2, &GROUP_SENDER, 2);
+     ck_assert_int_eq(result, 0);
+
+     signal_buffer *serialized_distribution_message_2 =
+             ciphertext_message_get_serialized((ciphertext_message *)distribution_message_2);
+
+     ck_assert_int_lt(
+             signal_buffer_len(serialized_distribution_message_0),
+             signal_buffer_len(serialized_distribution_message_1));
+
+     ck_assert_int_eq(
+             signal_buffer_len(serialized_distribution_message_1),
+             signal_buffer_len(serialized_distribution_message_2));
+
+     /* Cleanup */
+     SIGNAL_UNREF(distribution_message_0);
+     SIGNAL_UNREF(distribution_message_1);
+     SIGNAL_UNREF(distribution_message_2);
+     fast_ratchet_group_cipher_free(alice_group_cipher);
+     fast_ratchet_group_session_builder_free(alice_session_builder);
+     signal_protocol_store_context_destroy(alice_store);
+}
+END_TEST
+
+START_TEST(test_distribution_message_scale_change)
+{
+    int result = 0;
+
+     /* Create the test data store */
+     signal_protocol_store_context *alice_store = 0;
+     setup_test_store_context(&alice_store, global_context);
+
+     /* Create the session builder */
+     fast_ratchet_group_session_builder *alice_session_builder = 0;
+     result = fast_ratchet_group_session_builder_create(&alice_session_builder, alice_store, global_context);
+     ck_assert_int_eq(result, 0);
+
+     /* Create two sender key distribution messages for scale 2 */
+     fast_ratchet_sender_key_distribution_message *distribution_message_0 = 0;
+     result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &distribution_message_0, &GROUP_SENDER, 2);
+     ck_assert_int_eq(result, 0);
+
+     signal_buffer *serialized_distribution_message_0 =
+             ciphertext_message_get_serialized((ciphertext_message *)distribution_message_0);
+
+     fast_ratchet_sender_key_distribution_message *distribution_message_1 = 0;
+     result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &distribution_message_1, &GROUP_SENDER, 2);
+     ck_assert_int_eq(result, 0);
+
+     signal_buffer *serialized_distribution_message_1 =
+             ciphertext_message_get_serialized((ciphertext_message *)distribution_message_1);
+
+     /* Create two sender key distribution messages for scale 3 */
+     fast_ratchet_sender_key_distribution_message *distribution_message_2 = 0;
+     result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &distribution_message_2, &GROUP_SENDER, 3);
+     ck_assert_int_eq(result, 0);
+
+     signal_buffer *serialized_distribution_message_2 =
+             ciphertext_message_get_serialized((ciphertext_message *)distribution_message_2);
+
+     fast_ratchet_sender_key_distribution_message *distribution_message_3 = 0;
+     result = fast_ratchet_group_session_builder_create_session(alice_session_builder, &distribution_message_3, &GROUP_SENDER, 3);
+     ck_assert_int_eq(result, 0);
+
+     signal_buffer *serialized_distribution_message_3 =
+             ciphertext_message_get_serialized((ciphertext_message *)distribution_message_3);
+
+     ck_assert_int_eq(0, signal_buffer_compare(
+             serialized_distribution_message_0,
+             serialized_distribution_message_1));
+
+     ck_assert_int_ne(0, signal_buffer_compare(
+             serialized_distribution_message_1,
+             serialized_distribution_message_2));
+     ck_assert_int_lt(
+             signal_buffer_len(serialized_distribution_message_1),
+             signal_buffer_len(serialized_distribution_message_2));
+
+     ck_assert_int_eq(0, signal_buffer_compare(
+             serialized_distribution_message_2,
+             serialized_distribution_message_3));
+
+     /* Cleanup */
+     SIGNAL_UNREF(distribution_message_0);
+     SIGNAL_UNREF(distribution_message_1);
+     SIGNAL_UNREF(distribution_message_2);
+     SIGNAL_UNREF(distribution_message_3);
+     fast_ratchet_group_session_builder_free(alice_session_builder);
+     signal_protocol_store_context_destroy(alice_store);
+}
+END_TEST
+
+Suite *fast_ratchet_group_cipher_suite(void)
+{
+    Suite *suite = suite_create("fast_ratchet_group_cipher");
+
+    TCase *tcase = tcase_create("case");
+    tcase_add_checked_fixture(tcase, test_setup, test_teardown);
+    tcase_add_test(tcase, test_basic_encrypt_decrypt);
+    tcase_add_test(tcase, test_basic_ratchet);
+    tcase_add_test(tcase, test_late_join);
+    tcase_add_test(tcase, test_out_of_order_unsupported);
+    tcase_add_test(tcase, test_encrypt_with_lossy_decrypt);
+    tcase_add_test(tcase, test_initial_single_chain_state);
+    tcase_add_test(tcase, test_initial_multi_chain_state);
+    tcase_add_test(tcase, test_initial_chain_state);
+    tcase_add_test(tcase, test_intermediate_ratchet);
+    tcase_add_test(tcase, test_large_scale_ratchet);
+    tcase_add_test(tcase, test_large_scale_ratchet_with_rollover);
+    tcase_add_test(tcase, test_distribution_message_sizes);
+    tcase_add_test(tcase, test_distribution_message_scale_change);
+    suite_add_tcase(suite, tcase);
+
+    return suite;
+}
+
+int main(void)
+{
+    int number_failed;
+    Suite *suite;
+    SRunner *runner;
+
+    suite = fast_ratchet_group_cipher_suite();
+    runner = srunner_create(suite);
+
+    srunner_run_all(runner, CK_VERBOSE);
+    number_failed = srunner_ntests_failed(runner);
+    srunner_free(runner);
+    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/tests/test_fast_ratchet_sender_key_record.c b/tests/test_fast_ratchet_sender_key_record.c
new file mode 100644
index 0000000..f7adf11
--- /dev/null
+++ b/tests/test_fast_ratchet_sender_key_record.c
@@ -0,0 +1,345 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <check.h>
+
+#include "../src/signal_protocol.h"
+#include "key_helper.h"
+#include "curve.h"
+#include "fast_ratchet_sender_key.h"
+#include "fast_ratchet_sender_key_state.h"
+#include "fast_ratchet_sender_key_record.h"
+#include "test_common.h"
+
+signal_context *global_context;
+
+void test_setup()
+{
+    int result;
+    result = signal_context_create(&global_context, 0);
+    ck_assert_int_eq(result, 0);
+    signal_context_set_log_function(global_context, test_log);
+
+    setup_test_crypto_provider(global_context);
+}
+
+void test_teardown()
+{
+    signal_context_destroy(global_context);
+}
+
+fast_ratchet_sender_key_state *create_test_fast_ratchet_sender_key_state(int id, int iteration)
+{
+    int result = 0;
+    fast_ratchet_sender_key_state *state = 0;
+    signal_buffer *buffer = 0;
+    fast_ratchet_sender_chain_key *chain_key = 0;
+    ec_key_pair *key_pair = 0;
+
+    result = signal_protocol_key_helper_generate_sender_key(&buffer, global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fast_ratchet_sender_chain_key_create_initial(&chain_key, buffer, 2, global_context);
+    ck_assert_int_eq(result, 0);
+
+    if(iteration > 0) {
+        fast_ratchet_sender_chain_key *chain_key_next = 0;
+        result = fast_ratchet_sender_chain_key_create_next(chain_key, &chain_key_next, iteration);
+        ck_assert_int_eq(result, 0);
+        SIGNAL_UNREF(chain_key);
+        chain_key = chain_key_next;
+    }
+
+    result = signal_protocol_key_helper_generate_sender_signing_key(&key_pair, global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fast_ratchet_sender_key_state_create(&state, id, chain_key,
+            ec_key_pair_get_public(key_pair), ec_key_pair_get_private(key_pair), global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Cleanup */
+    signal_buffer_free(buffer);
+    SIGNAL_UNREF(chain_key);
+    SIGNAL_UNREF(key_pair);
+
+    return state;
+}
+
+signal_buffer_list *create_test_chain_key_seed_list(int count)
+{
+    int result = 0;
+    signal_buffer_list *buffer_list = signal_buffer_list_alloc();
+    ck_assert_ptr_ne(0, buffer_list);
+
+    for(int i = 0; i < count; i++) {
+        signal_buffer *buffer = 0;
+        result = signal_protocol_key_helper_generate_sender_key(&buffer, global_context);
+        ck_assert_int_eq(result, 0);
+        signal_buffer_list_push_back(buffer_list, buffer);
+    }
+
+    return buffer_list;
+}
+
+void compare_fast_ratchet_sender_chain_keys(fast_ratchet_sender_chain_key *chain_key1, fast_ratchet_sender_chain_key *chain_key2)
+{
+    int iteration1 = fast_ratchet_sender_chain_key_get_iteration(chain_key1);
+    int iteration2 = fast_ratchet_sender_chain_key_get_iteration(chain_key2);
+    ck_assert_int_eq(iteration1, iteration2);
+
+    signal_buffer_list *seed_list1 = fast_ratchet_sender_chain_key_get_seeds(chain_key1);
+    signal_buffer_list *seed_list2 = fast_ratchet_sender_chain_key_get_seeds(chain_key2);
+
+    ck_assert_int_eq(signal_buffer_list_size(seed_list1), signal_buffer_list_size(seed_list2));
+
+    for(int i = signal_buffer_list_size(seed_list1) - 1; i >= 0; --i) {
+        signal_buffer *seed1 = signal_buffer_list_at(seed_list1, i);
+        signal_buffer *seed2 = signal_buffer_list_at(seed_list2, i);
+        ck_assert_int_eq(signal_buffer_compare(seed1, seed2), 0);
+    }
+}
+
+void compare_fast_ratchet_sender_key_states(fast_ratchet_sender_key_state *state1, fast_ratchet_sender_key_state *state2)
+{
+    /* Compare key IDs */
+    int key_id1 = fast_ratchet_sender_key_state_get_key_id(state1);
+    int key_id2 = fast_ratchet_sender_key_state_get_key_id(state2);
+    ck_assert_int_eq(key_id1, key_id2);
+
+    /* Compare chain keys */
+    fast_ratchet_sender_chain_key *chain_key1 = fast_ratchet_sender_key_state_get_chain_key(state1);
+    fast_ratchet_sender_chain_key *chain_key2 = fast_ratchet_sender_key_state_get_chain_key(state2);
+    compare_fast_ratchet_sender_chain_keys(chain_key1, chain_key2);
+
+    /* Compare public signing keys */
+    ec_public_key *key_public1 = fast_ratchet_sender_key_state_get_signing_key_public(state1);
+    ec_public_key *key_public2 = fast_ratchet_sender_key_state_get_signing_key_public(state2);
+    ck_assert_int_eq(ec_public_key_compare(key_public1, key_public2), 0);
+
+    /* Compare private signing keys */
+    ec_private_key *key_private1 = fast_ratchet_sender_key_state_get_signing_key_private(state1);
+    ec_private_key *key_private2 = fast_ratchet_sender_key_state_get_signing_key_private(state2);
+    ck_assert_int_eq(ec_private_key_compare(key_private1, key_private2), 0);
+}
+
+START_TEST(test_serialize_fast_ratchet_sender_key_state)
+{
+    int result = 0;
+    fast_ratchet_sender_key_state *state = create_test_fast_ratchet_sender_key_state(1234, 1);
+
+    /* Serialize the state */
+    signal_buffer *buffer = 0;
+    result = fast_ratchet_sender_key_state_serialize(&buffer, state);
+    ck_assert_int_ge(result, 0);
+
+    /* Deserialize the state */
+    uint8_t *data = signal_buffer_data(buffer);
+    int len = signal_buffer_len(buffer);
+    fast_ratchet_sender_key_state *state_deserialized = 0;
+    result = fast_ratchet_sender_key_state_deserialize(&state_deserialized, data, len, global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Verify that the initial and deserialized states match */
+    compare_fast_ratchet_sender_key_states(state, state_deserialized);
+
+    /* Cleanup */
+    SIGNAL_UNREF(state);
+    signal_buffer_free(buffer);
+    SIGNAL_UNREF(state_deserialized);
+}
+END_TEST
+
+void compare_fast_ratchet_sender_key_records(fast_ratchet_sender_key_record *record1, fast_ratchet_sender_key_record *record2)
+{
+    int empty1 = fast_ratchet_sender_key_record_is_empty(record1);
+    int empty2 = fast_ratchet_sender_key_record_is_empty(record2);
+    ck_assert_int_eq(empty1, empty2);
+
+    /* Sender key states not compared, since there is no way to iterate across them */
+}
+
+void compare_fast_ratchet_sender_key_record_states(fast_ratchet_sender_key_record *record1, fast_ratchet_sender_key_record *record2, int id)
+{
+    int result = 0;
+    fast_ratchet_sender_key_state *state1 = 0;
+    fast_ratchet_sender_key_state *state2 = 0;
+
+    result = fast_ratchet_sender_key_record_get_sender_key_state_by_id(record1, &state1, id);
+    ck_assert_int_eq(result, 0);
+    ck_assert_ptr_ne(state1, 0);
+
+    result = fast_ratchet_sender_key_record_get_sender_key_state_by_id(record2, &state2, id);
+    ck_assert_int_eq(result, 0);
+    ck_assert_ptr_ne(state2, 0);
+
+    ck_assert_ptr_ne(state1, state2);
+
+    compare_fast_ratchet_sender_key_states(state1, state2);
+}
+
+START_TEST(test_serialize_fast_ratchet_sender_key_record)
+{
+    int result = 0;
+    fast_ratchet_sender_key_record *record = 0;
+
+    result = fast_ratchet_sender_key_record_create(&record, global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Serialize the record */
+    signal_buffer *buffer = 0;
+    result = fast_ratchet_sender_key_record_serialize(&buffer, record);
+    ck_assert_int_ge(result, 0);
+
+    /* Deserialize the record */
+    uint8_t *data = signal_buffer_data(buffer);
+    int len = signal_buffer_len(buffer);
+    fast_ratchet_sender_key_record *record_deserialized = 0;
+    result = fast_ratchet_sender_key_record_deserialize(&record_deserialized, data, len, global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Verify that the initial and deserialized records match */
+    compare_fast_ratchet_sender_key_records(record, record_deserialized);
+
+    /* Cleanup */
+    SIGNAL_UNREF(record);
+    signal_buffer_free(buffer);
+    SIGNAL_UNREF(record_deserialized);
+}
+END_TEST
+
+START_TEST(test_serialize_fast_ratchet_sender_key_record_with_states)
+{
+    int result = 0;
+    fast_ratchet_sender_key_record *record = 0;
+    signal_buffer *buffer = 0;
+    signal_buffer_list *buffer_list = 0;
+    ec_key_pair *key_pair = 0;
+
+    /* Create the record */
+    result = fast_ratchet_sender_key_record_create(&record, global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Create and set state id=1000, iteration=1 */
+    buffer_list = create_test_chain_key_seed_list(4);
+    ck_assert_ptr_ne(0, buffer_list);
+    result = signal_protocol_key_helper_generate_sender_signing_key(&key_pair, global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fast_ratchet_sender_key_record_set_sender_key_state(record, 1000, 1, buffer_list, key_pair);
+    ck_assert_int_eq(result, 0);
+
+    signal_buffer_list_free(buffer_list);
+    SIGNAL_UNREF(key_pair);
+
+    /* Create and add state id=1001, iteration=2 */
+    buffer_list = create_test_chain_key_seed_list(4);
+    ck_assert_ptr_ne(0, buffer_list);
+    result = signal_protocol_key_helper_generate_sender_signing_key(&key_pair, global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fast_ratchet_sender_key_record_add_sender_key_state(record, 1001, 2, buffer_list, ec_key_pair_get_public(key_pair));
+    ck_assert_int_eq(result, 0);
+
+    signal_buffer_list_free(buffer_list);
+    SIGNAL_UNREF(key_pair);
+
+    /* Serialize the record */
+    result = fast_ratchet_sender_key_record_serialize(&buffer, record);
+    ck_assert_int_ge(result, 0);
+
+    /* Deserialize the record */
+    uint8_t *data = signal_buffer_data(buffer);
+    int len = signal_buffer_len(buffer);
+    fast_ratchet_sender_key_record *record_deserialized = 0;
+    result = fast_ratchet_sender_key_record_deserialize(&record_deserialized, data, len, global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Verify that the initial and deserialized records match */
+    compare_fast_ratchet_sender_key_records(record, record_deserialized);
+    compare_fast_ratchet_sender_key_record_states(record, record_deserialized, 1000);
+    compare_fast_ratchet_sender_key_record_states(record, record_deserialized, 1001);
+
+    /* Cleanup */
+    SIGNAL_UNREF(record);
+    signal_buffer_free(buffer);
+    SIGNAL_UNREF(record_deserialized);
+}
+END_TEST
+
+START_TEST(test_fast_ratchet_sender_key_record_too_many_states)
+{
+    int result = 0;
+    int i;
+    fast_ratchet_sender_key_record *record = 0;
+    fast_ratchet_sender_key_state *state = 0;
+    signal_buffer_list *buffer_list = 0;
+    ec_key_pair *key_pair = 0;
+
+    /* Create the record */
+    result = fast_ratchet_sender_key_record_create(&record, global_context);
+    ck_assert_int_eq(result, 0);
+
+    /* Create and set state id=1000, iteration=1 */
+    buffer_list = create_test_chain_key_seed_list(4);
+    ck_assert_ptr_ne(0, buffer_list);
+    result = signal_protocol_key_helper_generate_sender_signing_key(&key_pair, global_context);
+    ck_assert_int_eq(result, 0);
+
+    result = fast_ratchet_sender_key_record_set_sender_key_state(record, 1000, 1, buffer_list, key_pair);
+    ck_assert_int_eq(result, 0);
+
+    signal_buffer_list_free(buffer_list);
+    SIGNAL_UNREF(key_pair);
+
+    /* Create and set states id=1001..1010, iteration=2..11 */
+    for(i = 0; i < 10; i++) {
+        buffer_list = create_test_chain_key_seed_list(4);
+        ck_assert_ptr_ne(0, buffer_list);
+        result = signal_protocol_key_helper_generate_sender_signing_key(&key_pair, global_context);
+        ck_assert_int_eq(result, 0);
+
+        fast_ratchet_sender_key_record_add_sender_key_state(record, 1001 + i, 2 + i, buffer_list, ec_key_pair_get_public(key_pair));
+        ck_assert_int_eq(result, 0);
+
+        signal_buffer_list_free(buffer_list);
+        SIGNAL_UNREF(key_pair);
+    }
+
+    /* Get the latest state from the record */
+    result = fast_ratchet_sender_key_record_get_sender_key_state(record, &state);
+    ck_assert_int_eq(result, 0);
+    ck_assert_int_eq(fast_ratchet_sender_key_state_get_key_id(state), 1010);
+
+    /* Cleanup */
+    SIGNAL_UNREF(record);
+}
+END_TEST
+
+Suite *fast_ratchet_sender_key_record_suite(void)
+{
+    Suite *suite = suite_create("fast_ratchet_sender_key_record");
+
+    TCase *tcase = tcase_create("case");
+    tcase_add_checked_fixture(tcase, test_setup, test_teardown);
+    tcase_add_test(tcase, test_serialize_fast_ratchet_sender_key_state);
+    tcase_add_test(tcase, test_serialize_fast_ratchet_sender_key_record);
+    tcase_add_test(tcase, test_serialize_fast_ratchet_sender_key_record_with_states);
+    tcase_add_test(tcase, test_fast_ratchet_sender_key_record_too_many_states);
+    suite_add_tcase(suite, tcase);
+
+    return suite;
+}
+
+int main(void)
+{
+    int number_failed;
+    Suite *suite;
+    SRunner *runner;
+
+    suite = fast_ratchet_sender_key_record_suite();
+    runner = srunner_create(suite);
+
+    srunner_run_all(runner, CK_VERBOSE);
+    number_failed = srunner_ntests_failed(runner);
+    srunner_free(runner);
+    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/tests/test_fast_ratchet_util.c b/tests/test_fast_ratchet_util.c
new file mode 100644
index 0000000..a6693f2
--- /dev/null
+++ b/tests/test_fast_ratchet_util.c
@@ -0,0 +1,188 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <check.h>
+
+#include "fast_ratchet_util.h"
+#include "test_common.h"
+
+void test_setup()
+{
+}
+
+void test_teardown()
+{
+}
+
+START_TEST(test_compose_iteration_scale0)
+{
+    uint32_t input0[] = { 0x00 };
+    ck_assert_uint_eq(0, fast_ratchet_compose_iterations(input0, 1));
+
+    uint32_t input1[] = { 0x01 };
+    ck_assert_uint_eq(1, fast_ratchet_compose_iterations(input1, 1));
+}
+END_TEST
+
+START_TEST(test_compose_iteration_scale4)
+{
+    uint32_t input0[] = { 0x00, 0x00, 0x00, 0x04 };
+    ck_assert_uint_eq(4, fast_ratchet_compose_iterations(input0, 4));
+
+    uint32_t input1[] = { 0x00, 0x00, 0x03, 0x04 };
+    ck_assert_uint_eq(772, fast_ratchet_compose_iterations(input1, 4));
+
+    uint32_t input2[] = { 0x00, 0x02, 0x03, 0x04 };
+    ck_assert_uint_eq(131844, fast_ratchet_compose_iterations(input2, 4));
+
+    uint32_t input3[] = { 0x01, 0x02, 0x03, 0x04 };
+    ck_assert_uint_eq(16909060, fast_ratchet_compose_iterations(input3, 4));
+
+    uint32_t input4[] = { 0x00, 0x00, 0xFF, 0x00 };
+    ck_assert_uint_eq(65280, fast_ratchet_compose_iterations(input4, 4));
+}
+END_TEST
+
+START_TEST(test_decompose_iteration_scale0)
+{
+    uint32_t components[1];
+
+    uint32_t expected0[] = { 0x00 };
+    fast_ratchet_decompose_iteration(components, 1, 0);
+    ck_assert_int_eq(memcmp(components, expected0, sizeof(components)), 0);
+
+    uint32_t expected1[] = { 0x01 };
+    fast_ratchet_decompose_iteration(components, 1, 1);
+    ck_assert_int_eq(memcmp(components, expected1, sizeof(components)), 0);
+}
+END_TEST
+
+START_TEST(test_decompose_iteration_scale4)
+{
+    uint32_t components[4];
+
+    uint32_t expected0[] = {0x00, 0x00, 0x00, 0x04};
+    fast_ratchet_decompose_iteration(components, 4, 4);
+    ck_assert_int_eq(memcmp(components, expected0, sizeof(components)), 0);
+
+    uint32_t expected1[] = {0x00, 0x00, 0x03, 0x04};
+    fast_ratchet_decompose_iteration(components, 4, 772);
+    ck_assert_int_eq(memcmp(components, expected1, sizeof(components)), 0);
+
+    uint32_t expected2[] = {0x00, 0x02, 0x03, 0x04};
+    fast_ratchet_decompose_iteration(components, 4, 131844);
+    ck_assert_int_eq(memcmp(components, expected2, sizeof(components)), 0);
+
+    uint32_t expected3[] = {0x01, 0x02, 0x03, 0x04};
+    fast_ratchet_decompose_iteration(components, 4, 16909060);
+    ck_assert_int_eq(memcmp(components, expected3, sizeof(components)), 0);
+
+    uint32_t expected4[] = {0x00, 0x00, 0xFF, 0x00};
+    fast_ratchet_decompose_iteration(components, 4, 65280);
+    ck_assert_int_eq(memcmp(components, expected4, sizeof(components)), 0);
+}
+END_TEST
+
+START_TEST(test_compose_chain_iterations_scale0)
+{
+    uint32_t input0[] = { 0x00 };
+    ck_assert_uint_eq(0, fast_ratchet_compose_chain_iterations(input0, 1));
+
+    uint32_t input1[] = { 0x01 };
+    ck_assert_uint_eq(1, fast_ratchet_compose_chain_iterations(input1, 1));
+}
+END_TEST
+
+START_TEST(test_compose_chain_iterations_scale4)
+{
+    uint32_t input0[] = { 0x01, 0x01, 0x01, 0x04 };
+    ck_assert_uint_eq(4, fast_ratchet_compose_chain_iterations(input0, 4));
+
+    uint32_t input1[] = { 0x01, 0x01, 0x04, 0x04 };
+    ck_assert_uint_eq(772, fast_ratchet_compose_chain_iterations(input1, 4));
+
+    uint32_t input2[] = { 0x01, 0x03, 0x04, 0x04 };
+    ck_assert_uint_eq(131844, fast_ratchet_compose_chain_iterations(input2, 4));
+
+    uint32_t input3[] = { 0x02, 0x03, 0x04, 0x04 };
+    ck_assert_uint_eq(16909060, fast_ratchet_compose_chain_iterations(input3, 4));
+
+    uint32_t input4[] = { 0x01, 0x01, 0x100, 0x00 };
+    ck_assert_uint_eq(65280, fast_ratchet_compose_chain_iterations(input4, 4));
+}
+END_TEST
+
+START_TEST(test_decompose_chain_iterations_scale0)
+{
+    uint32_t components[1];
+
+    uint32_t expected0[] = { 0x00 };
+    fast_ratchet_decompose_chain_iterations(components, 1, 0);
+    ck_assert_int_eq(memcmp(components, expected0, sizeof(components)), 0);
+
+    uint32_t expected1[] = { 0x01 };
+    fast_ratchet_decompose_chain_iterations(components, 1, 1);
+    ck_assert_int_eq(memcmp(components, expected1, sizeof(components)), 0);
+}
+END_TEST
+
+START_TEST(test_decompose_chain_iterations_scale4)
+{
+    uint32_t components[4];
+
+    uint32_t expected0[] = {0x01, 0x01, 0x01, 0x04};
+    fast_ratchet_decompose_chain_iterations(components, 4, 4);
+    ck_assert_int_eq(memcmp(components, expected0, sizeof(components)), 0);
+
+    uint32_t expected1[] = {0x01, 0x01, 0x04, 0x04};
+    fast_ratchet_decompose_chain_iterations(components, 4, 772);
+    ck_assert_int_eq(memcmp(components, expected1, sizeof(components)), 0);
+
+    uint32_t expected2[] = {0x01, 0x03, 0x04, 0x04};
+    fast_ratchet_decompose_chain_iterations(components, 4, 131844);
+    ck_assert_int_eq(memcmp(components, expected2, sizeof(components)), 0);
+
+    uint32_t expected3[] = {0x02, 0x03, 0x04, 0x04};
+    fast_ratchet_decompose_chain_iterations(components, 4, 16909060);
+    ck_assert_int_eq(memcmp(components, expected3, sizeof(components)), 0);
+
+    uint32_t expected4[] = {0x01, 0x01, 0x100, 0x00};
+    fast_ratchet_decompose_chain_iterations(components, 4, 65280);
+    ck_assert_int_eq(memcmp(components, expected4, sizeof(components)), 0);
+}
+END_TEST
+
+Suite *fast_ratchet_util_suite(void)
+{
+    Suite *suite = suite_create("fast_ratchet_util");
+
+    TCase *tcase = tcase_create("case");
+    tcase_add_checked_fixture(tcase, test_setup, test_teardown);
+    tcase_add_test(tcase, test_compose_iteration_scale0);
+    tcase_add_test(tcase, test_compose_iteration_scale4);
+    tcase_add_test(tcase, test_decompose_iteration_scale0);
+    tcase_add_test(tcase, test_decompose_iteration_scale4);
+    tcase_add_test(tcase, test_compose_chain_iterations_scale0);
+    tcase_add_test(tcase, test_compose_chain_iterations_scale4);
+    tcase_add_test(tcase, test_decompose_chain_iterations_scale0);
+    tcase_add_test(tcase, test_decompose_chain_iterations_scale4);
+
+    suite_add_tcase(suite, tcase);
+
+    return suite;
+}
+
+int main(void)
+{
+    int number_failed;
+    Suite *suite;
+    SRunner *runner;
+
+    suite = fast_ratchet_util_suite();
+    runner = srunner_create(suite);
+
+    srunner_run_all(runner, CK_VERBOSE);
+    number_failed = srunner_ntests_failed(runner);
+    srunner_free(runner);
+    return (number_failed == 0) ? EXIT_SUCCESS : EXIT_FAILURE;
+}
diff --git a/tests/test_protocol.c b/tests/test_protocol.c
index d00c5f4..a1995e5 100644
--- a/tests/test_protocol.c
+++ b/tests/test_protocol.c
@@ -288,6 +288,76 @@ START_TEST(test_serialize_sender_key_distribution_message)
 }
 END_TEST
 
+START_TEST(test_serialize_fast_ratchet_sender_key_distribution_message)
+{
+    int result = 0;
+    fast_ratchet_sender_key_distribution_message *message = 0;
+    fast_ratchet_sender_key_distribution_message *result_message = 0;
+    static const char chain_seed1[] = "WhisperChainKey1";
+    static const char chain_seed2[] = "WhisperChainKey2";
+    signal_buffer *buffer;
+    signal_buffer_list *chain_keys;
+    ec_public_key *signature_key = create_test_ec_public_key(global_context);
+
+    chain_keys = signal_buffer_list_alloc();
+    ck_assert_ptr_ne(chain_keys, 0);
+
+    buffer = signal_buffer_create((uint8_t *)chain_seed1, sizeof(chain_seed1) - 1);
+    ck_assert_ptr_ne(buffer, 0);
+    signal_buffer_list_push_back(chain_keys, buffer);
+
+    buffer = signal_buffer_create((uint8_t *)chain_seed2, sizeof(chain_seed2) - 1);
+    ck_assert_ptr_ne(buffer, 0);
+    signal_buffer_list_push_back(chain_keys, buffer);
+
+    result = fast_ratchet_sender_key_distribution_message_create(&message,
+            10, /* id */
+            1,  /* iteration */
+            chain_keys,
+            signature_key,
+            global_context);
+    ck_assert_int_eq(result, 0);
+
+    signal_buffer *serialized = ciphertext_message_get_serialized((ciphertext_message *)message);
+    ck_assert_ptr_ne(serialized, 0);
+
+    result = fast_ratchet_sender_key_distribution_message_deserialize(&result_message,
+            signal_buffer_data(serialized),
+            signal_buffer_len(serialized),
+            global_context);
+    ck_assert_int_eq(result, 0);
+
+    int id1 = fast_ratchet_sender_key_distribution_message_get_id(message);
+    int id2 = fast_ratchet_sender_key_distribution_message_get_id(result_message);
+    ck_assert_int_eq(id1, id2);
+
+    int iteration1 = fast_ratchet_sender_key_distribution_message_get_iteration(message);
+    int iteration2 = fast_ratchet_sender_key_distribution_message_get_iteration(result_message);
+    ck_assert_int_eq(iteration1, iteration2);
+
+    signal_buffer_list *chain_keys1 = fast_ratchet_sender_key_distribution_message_get_chain_keys(message);
+    signal_buffer_list *chain_keys2 = fast_ratchet_sender_key_distribution_message_get_chain_keys(result_message);
+
+    ck_assert_int_eq(signal_buffer_list_size(chain_keys1), signal_buffer_list_size(chain_keys2));
+
+    for(int i = signal_buffer_list_size(chain_keys1) - 1; i >= 0; --i) {
+        signal_buffer *chain_key1 = signal_buffer_list_at(chain_keys1, i);
+        signal_buffer *chain_key2 = signal_buffer_list_at(chain_keys2, i);
+        ck_assert_int_eq(signal_buffer_compare(chain_key1, chain_key2), 0);
+    }
+
+    ec_public_key *signature_key1 = fast_ratchet_sender_key_distribution_message_get_signature_key(message);
+    ec_public_key *signature_key2 = fast_ratchet_sender_key_distribution_message_get_signature_key(result_message);
+    ck_assert_int_eq(ec_public_key_compare(signature_key1, signature_key2), 0);
+
+    /* Cleanup */
+    SIGNAL_UNREF(message);
+    SIGNAL_UNREF(result_message);
+    SIGNAL_UNREF(signature_key);
+    signal_buffer_list_free(chain_keys);
+}
+END_TEST
+
 Suite *protocol_suite(void)
 {
     Suite *suite = suite_create("protocol");
@@ -298,6 +368,7 @@ Suite *protocol_suite(void)
     tcase_add_test(tcase, test_serialize_pre_key_signal_message);
     tcase_add_test(tcase, test_serialize_sender_key_message);
     tcase_add_test(tcase, test_serialize_sender_key_distribution_message);
+    tcase_add_test(tcase, test_serialize_fast_ratchet_sender_key_distribution_message);
     suite_add_tcase(suite, tcase);
 
     return suite;
-- 
2.7.4

