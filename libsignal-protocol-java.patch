From 203899049fd9c1f55e81f1fdc55a9e316f82c67d Mon Sep 17 00:00:00 2001
From: WhatsApp Security <security@whatsapp.com>
Date: Mon, 27 Feb 2017 09:59:25 -0800
Subject: [PATCH] Changes to libsignal-protocol-java from Open Whisper Systems

Copyright (C) 2017 WhatsApp Inc. All rights reserved.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
---
 .gitignore                                         |    3 +-
 .idea/codeStyleSettings.xml                        |  244 +++
 android/build.gradle                               |   38 -
 java/build.gradle                                  |   41 +-
 .../libsignal/groups/FastRatchetGroupCipher.java   |  205 +++
 .../groups/FastRatchetGroupSessionBuilder.java     |   98 ++
 .../groups/ratchet/FastRatchetSenderChainKey.java  |  175 +++
 .../groups/state/FastRatchetSenderKeyRecord.java   |   82 +
 .../groups/state/FastRatchetSenderKeyState.java    |  112 ++
 .../groups/state/FastRatchetSenderKeyStore.java    |   37 +
 .../libsignal/protocol/CiphertextMessage.java      |    9 +-
 .../FastRatchetSenderKeyDistributionMessage.java   |  114 ++
 .../libsignal/protocol/SignalProtos.java           |  751 ++++++++-
 .../libsignal/state/StorageProtos.java             | 1660 +++++++++++++++++++-
 .../libsignal/util/FastRatchetUtil.java            |   79 +
 protobuf/LocalStorageProtocol.proto                |   10 +
 protobuf/WhisperTextProtocol.proto                 |    7 +
 .../groups/FastRatchetGroupCipherTest.java         |  562 +++++++
 .../groups/InMemoryFastRatchetSenderKeyStore.java  |   33 +
 .../libsignal/util/FastRatchetUtilTest.java        |   60 +
 20 files changed, 4222 insertions(+), 98 deletions(-)
 create mode 100644 .idea/codeStyleSettings.xml
 create mode 100644 java/src/main/java/org/whispersystems/libsignal/groups/FastRatchetGroupCipher.java
 create mode 100644 java/src/main/java/org/whispersystems/libsignal/groups/FastRatchetGroupSessionBuilder.java
 create mode 100644 java/src/main/java/org/whispersystems/libsignal/groups/ratchet/FastRatchetSenderChainKey.java
 create mode 100644 java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyRecord.java
 create mode 100644 java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyState.java
 create mode 100644 java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyStore.java
 create mode 100644 java/src/main/java/org/whispersystems/libsignal/protocol/FastRatchetSenderKeyDistributionMessage.java
 create mode 100644 java/src/main/java/org/whispersystems/libsignal/util/FastRatchetUtil.java
 create mode 100644 tests/src/test/java/org/whispersystems/libsignal/groups/FastRatchetGroupCipherTest.java
 create mode 100644 tests/src/test/java/org/whispersystems/libsignal/groups/InMemoryFastRatchetSenderKeyStore.java
 create mode 100644 tests/src/test/java/org/whispersystems/libsignal/util/FastRatchetUtilTest.java

diff --git a/.gitignore b/.gitignore
index b7e3f28..3e03bfd 100644
--- a/.gitignore
+++ b/.gitignore
@@ -2,6 +2,7 @@ build
 /obj
 *.iml
 .gradle
-.idea
+/.idea/**
+!/.idea/codeStyleSettings.xml
 gradle.properties
 local.properties
diff --git a/.idea/codeStyleSettings.xml b/.idea/codeStyleSettings.xml
new file mode 100644
index 0000000..7b1ca24
--- /dev/null
+++ b/.idea/codeStyleSettings.xml
@@ -0,0 +1,244 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="ProjectCodeStyleSettingsManager">
+    <option name="PER_PROJECT_SETTINGS">
+      <value>
+        <option name="CLASS_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+        <option name="NAMES_COUNT_TO_USE_IMPORT_ON_DEMAND" value="99" />
+        <option name="PACKAGES_TO_USE_IMPORT_ON_DEMAND">
+          <value />
+        </option>
+        <option name="IMPORT_LAYOUT_TABLE">
+          <value>
+            <package name="android" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="com" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="junit" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="net" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="org" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="java" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="javax" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="" withSubpackages="true" static="false" />
+            <emptyLine />
+            <package name="" withSubpackages="true" static="true" />
+            <emptyLine />
+          </value>
+        </option>
+        <option name="RIGHT_MARGIN" value="100" />
+        <option name="JD_P_AT_EMPTY_LINES" value="false" />
+        <AndroidXmlCodeStyleSettings>
+          <option name="USE_CUSTOM_SETTINGS" value="true" />
+        </AndroidXmlCodeStyleSettings>
+        <Objective-C-extensions>
+          <option name="GENERATE_INSTANCE_VARIABLES_FOR_PROPERTIES" value="ASK" />
+          <option name="RELEASE_STYLE" value="IVAR" />
+          <option name="TYPE_QUALIFIERS_PLACEMENT" value="BEFORE" />
+          <file>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Import" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Macro" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Typedef" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Enum" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Constant" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Global" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Struct" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="FunctionPredecl" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Function" />
+          </file>
+          <class>
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Property" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="Synthesize" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InitMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="StaticMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="InstanceMethod" />
+            <option name="com.jetbrains.cidr.lang.util.OCDeclarationKind" value="DeallocMethod" />
+          </class>
+          <extensions>
+            <pair source="cpp" header="h" />
+            <pair source="c" header="h" />
+          </extensions>
+        </Objective-C-extensions>
+        <XML>
+          <option name="XML_LEGACY_SETTINGS_IMPORTED" value="true" />
+        </XML>
+        <codeStyleSettings language="JAVA">
+          <option name="BRACE_STYLE" value="5" />
+          <option name="METHOD_BRACE_STYLE" value="5" />
+          <option name="ALIGN_MULTILINE_CHAINED_METHODS" value="true" />
+          <option name="ALIGN_MULTILINE_PARAMETERS_IN_CALLS" value="true" />
+          <option name="ALIGN_GROUP_FIELD_DECLARATIONS" value="true" />
+          <option name="ALIGN_CONSECUTIVE_VARIABLE_DECLARATIONS" value="true" />
+          <option name="SPACE_BEFORE_ARRAY_INITIALIZER_LBRACE" value="true" />
+          <indentOptions>
+            <option name="INDENT_SIZE" value="2" />
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+            <option name="TAB_SIZE" value="2" />
+          </indentOptions>
+        </codeStyleSettings>
+        <codeStyleSettings language="XML">
+          <option name="FORCE_REARRANGE_MODE" value="1" />
+          <indentOptions>
+            <option name="CONTINUATION_INDENT_SIZE" value="4" />
+          </indentOptions>
+          <arrangement>
+            <rules>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:android</NAME>
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>xmlns:.*</NAME>
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:id</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:name</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>name</NAME>
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>style</NAME>
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>^$</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_width</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_height</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:layout_.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:width</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*:height</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>http://schemas.android.com/apk/res/android</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+              <section>
+                <rule>
+                  <match>
+                    <AND>
+                      <NAME>.*</NAME>
+                      <XML_NAMESPACE>.*</XML_NAMESPACE>
+                    </AND>
+                  </match>
+                  <order>BY_NAME</order>
+                </rule>
+              </section>
+            </rules>
+          </arrangement>
+        </codeStyleSettings>
+      </value>
+    </option>
+    <option name="USE_PER_PROJECT_SETTINGS" value="true" />
+  </component>
+</project>
\ No newline at end of file
diff --git a/android/build.gradle b/android/build.gradle
index 2270358..a07fe05 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -54,44 +54,6 @@ signing {
     sign configurations.archives
 }
 
-uploadArchives {
-    configuration = configurations.archives
-    repositories.mavenDeployer {
-        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
-
-        repository(url: sonatypeRepo) {
-            authentication(userName: whisperSonatypeUsername, password: whisperSonatypePassword)
-        }
-
-        pom.project {
-            name 'signal-protocol-android'
-            packaging 'aar'
-            description 'Signal Protocol cryptography library for Android'
-            url 'https://github.com/WhisperSystems/libsignal-android'
-
-            scm {
-                url 'scm:git@github.com:WhisperSystems/libsignal-android.git'
-                connection 'scm:git@github.com:WhisperSystems/libsignal-android.git'
-                developerConnection 'scm:git@github.com:WhisperSystems/libsignal-android.git'
-            }
-
-            licenses {
-                license {
-                    name 'GPLv3'
-                    url 'https://www.gnu.org/licenses/gpl-3.0.txt'
-                    distribution 'repo'
-                }
-            }
-
-            developers {
-                developer {
-                    name 'Moxie Marlinspike'
-                }
-            }
-        }
-    }
-}
-
 task installArchives(type: Upload) {
     description "Installs the artifacts to the local Maven repository."
     configuration = configurations['archives']
diff --git a/java/build.gradle b/java/build.gradle
index 001c679..25369ff 100644
--- a/java/build.gradle
+++ b/java/build.gradle
@@ -15,7 +15,8 @@ repositories {
 sourceSets {
     test {
         java {
-            srcDirs = ['src/test/java/', project(':tests').file('src/test/java')]
+            if (findProject(':tests'))
+                srcDirs = ['src/test/java/', project(':tests').file('src/test/java')]
         }
     }
 }
@@ -42,44 +43,6 @@ signing {
     sign configurations.archives
 }
 
-uploadArchives {
-    configuration = configurations.archives
-    repositories.mavenDeployer {
-        beforeDeployment { MavenDeployment deployment -> signing.signPom(deployment) }
-
-        repository(url: sonatypeRepo) {
-            authentication(userName: whisperSonatypeUsername, password: whisperSonatypePassword)
-        }
-
-        pom.project {
-            name 'signal-protocol-java'
-            packaging 'jar'
-            description 'Signal Protocol cryptography library for Java'
-            url 'https://github.com/WhisperSystems/libsignal-android'
-
-            scm {
-                url 'scm:git@github.com:WhisperSystems/libsignal-android.git'
-                connection 'scm:git@github.com:WhisperSystems/libsignal-android.git'
-                developerConnection 'scm:git@github.com:WhisperSystems/libsignal-android.git'
-            }
-
-            licenses {
-                license {
-                    name 'GPLv3'
-                    url 'https://www.gnu.org/licenses/gpl-3.0.txt'
-                    distribution 'repo'
-                }
-            }
-
-            developers {
-                developer {
-                    name 'Moxie Marlinspike'
-                }
-            }
-        }
-    }
-}
-
 task installArchives(type: Upload) {
     description "Installs the artifacts to the local Maven repository."
     configuration = configurations['archives']
diff --git a/java/src/main/java/org/whispersystems/libsignal/groups/FastRatchetGroupCipher.java b/java/src/main/java/org/whispersystems/libsignal/groups/FastRatchetGroupCipher.java
new file mode 100644
index 0000000..ed621c8
--- /dev/null
+++ b/java/src/main/java/org/whispersystems/libsignal/groups/FastRatchetGroupCipher.java
@@ -0,0 +1,205 @@
+/**
+ * Copyright (C) 2017 WhatsApp Inc. All rights reserved.
+ *
+ * Licensed according to the LICENSE file in this repository.
+ */
+package org.whispersystems.libsignal.groups;
+
+import org.whispersystems.libsignal.DecryptionCallback;
+import org.whispersystems.libsignal.DuplicateMessageException;
+import org.whispersystems.libsignal.InvalidKeyIdException;
+import org.whispersystems.libsignal.InvalidMessageException;
+import org.whispersystems.libsignal.LegacyMessageException;
+import org.whispersystems.libsignal.NoSessionException;
+import org.whispersystems.libsignal.groups.ratchet.FastRatchetSenderChainKey;
+import org.whispersystems.libsignal.groups.ratchet.SenderMessageKey;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyRecord;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyState;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyStore;
+import org.whispersystems.libsignal.protocol.SenderKeyMessage;
+
+import java.security.InvalidAlgorithmParameterException;
+import java.security.NoSuchAlgorithmException;
+
+import javax.crypto.BadPaddingException;
+import javax.crypto.Cipher;
+import javax.crypto.IllegalBlockSizeException;
+import javax.crypto.NoSuchPaddingException;
+import javax.crypto.spec.IvParameterSpec;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * The main entry point for Signal Protocol fast ratchet group encrypt/decrypt operations.
+ *
+ * Once a session has been established with {@link org.whispersystems.libsignal.groups.FastRatchetGroupSessionBuilder}
+ * and a {@link org.whispersystems.libsignal.protocol.SenderKeyDistributionMessage} has been
+ * distributed to each member of the group, this class can be used for all subsequent encrypt/decrypt
+ * operations within that session (ie: until group membership changes).
+ */
+public class FastRatchetGroupCipher {
+
+  static final Object LOCK = new Object();
+
+  private final FastRatchetSenderKeyStore senderKeyStore;
+  private final SenderKeyName             senderKeyId;
+
+  /**
+   * Creates a new instance of the fast ratchet group cipher.
+   *
+   * @param senderKeyStore Key store used for keeping track of sessions.
+   * @param senderKeyId ID for the sender key.
+   */
+  public FastRatchetGroupCipher(FastRatchetSenderKeyStore senderKeyStore, SenderKeyName senderKeyId) {
+    this.senderKeyStore     = senderKeyStore;
+    this.senderKeyId        = senderKeyId;
+  }
+
+  /**
+   * Encrypt a message.
+   *
+   * @param paddedPlaintext The plaintext message bytes, optionally padded.
+   * @return Ciphertext.
+   * @throws NoSessionException
+   */
+  public byte[] encrypt(byte[] paddedPlaintext) throws NoSessionException {
+    synchronized (LOCK) {
+      try {
+        FastRatchetSenderKeyRecord record         = senderKeyStore.loadFastRatchetSenderKey(senderKeyId);
+        FastRatchetSenderKeyState  senderKeyState = record.getSenderKeyState();
+        SenderMessageKey           senderKey      = senderKeyState.getSenderChainKey().getSenderMessageKey();
+        byte[]                     ciphertext     = getCipherText(senderKey.getIv(), senderKey.getCipherKey(), paddedPlaintext);
+
+        SenderKeyMessage senderKeyMessage = new SenderKeyMessage(senderKeyState.getKeyId(),
+                                                                 senderKey.getIteration(),
+                                                                 ciphertext,
+                                                                 senderKeyState.getSigningKeyPrivate());
+
+        senderKeyState.setSenderChainKey(senderKeyState.getSenderChainKey().getNext());
+
+        senderKeyStore.storeFastRatchetSenderKey(senderKeyId, record);
+
+        return senderKeyMessage.serialize();
+      } catch (InvalidKeyIdException e) {
+        throw new NoSessionException(e);
+      }
+    }
+  }
+
+  /**
+   * Decrypt a SenderKey group message.
+   *
+   * @param senderKeyMessageBytes The received ciphertext.
+   * @return Plaintext
+   * @throws LegacyMessageException
+   * @throws InvalidMessageException
+   * @throws DuplicateMessageException
+   */
+  public byte[] decrypt(byte[] senderKeyMessageBytes)
+      throws LegacyMessageException, DuplicateMessageException, InvalidMessageException, NoSessionException
+  {
+    return decrypt(senderKeyMessageBytes, new NullDecryptionCallback());
+  }
+
+  /**
+   * Decrypt a SenderKey group message.
+   *
+   * @param senderKeyMessageBytes The received ciphertext.
+   * @param callback   A callback that is triggered after decryption is complete,
+   *                    but before the updated session state has been committed to the session
+   *                    DB.  This allows some implementations to store the committed plaintext
+   *                    to a DB first, in case they are concerned with a crash happening between
+   *                    the time the session state is updated but before they're able to store
+   *                    the plaintext to disk.
+   * @return Plaintext
+   * @throws LegacyMessageException
+   * @throws InvalidMessageException
+   * @throws DuplicateMessageException
+   */
+  public byte[] decrypt(byte[] senderKeyMessageBytes, DecryptionCallback callback)
+      throws LegacyMessageException, InvalidMessageException, DuplicateMessageException,
+             NoSessionException
+  {
+    synchronized (LOCK) {
+      try {
+        FastRatchetSenderKeyRecord record = senderKeyStore.loadFastRatchetSenderKey(senderKeyId);
+
+        if (record.isEmpty()) {
+          throw new NoSessionException("No sender key for: " + senderKeyId);
+        }
+
+        SenderKeyMessage          senderKeyMessage = new SenderKeyMessage(senderKeyMessageBytes);
+        FastRatchetSenderKeyState senderKeyState   = record.getSenderKeyState(senderKeyMessage.getKeyId());
+
+        senderKeyMessage.verifySignature(senderKeyState.getSigningKeyPublic());
+
+        SenderMessageKey senderKey = getSenderKey(senderKeyState, senderKeyMessage.getIteration());
+
+        byte[] plaintext = getPlainText(senderKey.getIv(), senderKey.getCipherKey(), senderKeyMessage.getCipherText());
+
+        callback.handlePlaintext(plaintext);
+
+        senderKeyStore.storeFastRatchetSenderKey(senderKeyId, record);
+
+        return plaintext;
+      } catch (org.whispersystems.libsignal.InvalidKeyException | InvalidKeyIdException e) {
+        throw new InvalidMessageException(e);
+      }
+    }
+  }
+
+  private SenderMessageKey getSenderKey(FastRatchetSenderKeyState senderKeyState, int iteration)
+      throws DuplicateMessageException, InvalidMessageException
+  {
+    FastRatchetSenderChainKey senderChainKey = senderKeyState.getSenderChainKey();
+
+    if (senderChainKey.getIteration() > iteration) {
+      throw new DuplicateMessageException("Received message with old counter: " +
+                                          senderChainKey.getIteration() + " , " + iteration);
+    } else if (senderChainKey.getIteration() < iteration) {
+      senderChainKey = senderChainKey.getNext(iteration - senderChainKey.getIteration());
+    }
+
+    senderKeyState.setSenderChainKey(senderChainKey.getNext());
+    return senderChainKey.getSenderMessageKey();
+  }
+
+  private byte[] getPlainText(byte[] iv, byte[] key, byte[] ciphertext)
+      throws InvalidMessageException
+  {
+    try {
+      IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
+      Cipher          cipher          = Cipher.getInstance("AES/CBC/PKCS5Padding");
+
+      cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(key, "AES"), ivParameterSpec);
+
+      return cipher.doFinal(ciphertext);
+    } catch (NoSuchAlgorithmException | NoSuchPaddingException | java.security.InvalidKeyException |
+             InvalidAlgorithmParameterException e)
+    {
+      throw new AssertionError(e);
+    } catch (IllegalBlockSizeException | BadPaddingException e) {
+      throw new InvalidMessageException(e);
+    }
+  }
+
+  private byte[] getCipherText(byte[] iv, byte[] key, byte[] plaintext) {
+    try {
+      IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
+      Cipher          cipher          = Cipher.getInstance("AES/CBC/PKCS5Padding");
+
+      cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(key, "AES"), ivParameterSpec);
+
+      return cipher.doFinal(plaintext);
+    } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidAlgorithmParameterException |
+             IllegalBlockSizeException | BadPaddingException | java.security.InvalidKeyException e)
+    {
+      throw new AssertionError(e);
+    }
+  }
+
+  private static class NullDecryptionCallback implements DecryptionCallback {
+    @Override
+    public void handlePlaintext(byte[] plaintext) {}
+  }
+
+}
diff --git a/java/src/main/java/org/whispersystems/libsignal/groups/FastRatchetGroupSessionBuilder.java b/java/src/main/java/org/whispersystems/libsignal/groups/FastRatchetGroupSessionBuilder.java
new file mode 100644
index 0000000..bab425c
--- /dev/null
+++ b/java/src/main/java/org/whispersystems/libsignal/groups/FastRatchetGroupSessionBuilder.java
@@ -0,0 +1,98 @@
+/**
+ * Copyright (C) 2017 WhatsApp Inc. All rights reserved.
+ *
+ * Licensed according to the LICENSE file in this repository.
+ */
+package org.whispersystems.libsignal.groups;
+
+import org.whispersystems.libsignal.InvalidKeyException;
+import org.whispersystems.libsignal.InvalidKeyIdException;
+import org.whispersystems.libsignal.groups.ratchet.FastRatchetSenderChainKey;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyRecord;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyState;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyStore;
+import org.whispersystems.libsignal.protocol.FastRatchetSenderKeyDistributionMessage;
+import org.whispersystems.libsignal.util.FastRatchetUtil;
+import org.whispersystems.libsignal.util.KeyHelper;
+
+/**
+ * FastRatchetGroupSessionBuilder is responsible for setting up group SenderKey encrypted sessions.
+ *
+ * Once a session has been established, {@link org.whispersystems.libsignal.groups.FastRatchetGroupCipher}
+ * can be used to encrypt/decrypt messages in that session.
+ * <p>
+ * The built sessions are unidirectional: they can be used either for sending or for receiving,
+ * but not both.
+ *
+ * Sessions are constructed per (groupId + senderId + deviceId) tuple.  Remote logical users
+ * are identified by their senderId, and each logical recipientId can have multiple physical
+ * devices.
+ */
+public class FastRatchetGroupSessionBuilder {
+
+  private final FastRatchetSenderKeyStore senderKeyStore;
+
+  public FastRatchetGroupSessionBuilder(FastRatchetSenderKeyStore senderKeyStore) {
+    this.senderKeyStore = senderKeyStore;
+  }
+
+  /**
+   * Construct a group session for receiving messages from senderKeyName.
+   *
+   * @param senderKeyName The (groupId, senderId, deviceId) tuple associated with the FastRatchetSenderKeyDistributionMessage.
+   * @param senderKeyDistributionMessage A received FastRatchetSenderKeyDistributionMessage.
+   */
+  public void process(SenderKeyName senderKeyName, FastRatchetSenderKeyDistributionMessage senderKeyDistributionMessage) {
+    synchronized (FastRatchetGroupCipher.LOCK) {
+      FastRatchetSenderKeyRecord senderKeyRecord = senderKeyStore.loadFastRatchetSenderKey(senderKeyName);
+      senderKeyRecord.addSenderKeyState(senderKeyDistributionMessage.getId(),
+                                        senderKeyDistributionMessage.getIteration(),
+                                        senderKeyDistributionMessage.getChainKeys(),
+                                        senderKeyDistributionMessage.getSignatureKey());
+      senderKeyStore.storeFastRatchetSenderKey(senderKeyName, senderKeyRecord);
+    }
+  }
+
+  /**
+   * Construct a group session for sending messages.
+   *
+   * @param senderKeyName The (groupId, senderId, deviceId) tuple.  In this case, 'senderId' should be the caller.
+   * @param scale Value from which the number of dimensions for the chain key ratchet is derived.
+   *              Valid values are from [0..5]. (Dimensions is 2^scale.)
+   * @return A SenderKeyDistributionMessage that is individually distributed to each member of the group.
+   */
+  public FastRatchetSenderKeyDistributionMessage create(SenderKeyName senderKeyName, int scale) {
+    if (scale < 0 || scale > 5) {
+      throw new IllegalArgumentException("scale must be between 0 and 5");
+    }
+
+    synchronized (FastRatchetGroupCipher.LOCK) {
+      try {
+        FastRatchetSenderKeyRecord senderKeyRecord = senderKeyStore.loadFastRatchetSenderKey(senderKeyName);
+
+        if (senderKeyRecord.isEmpty()) {
+          FastRatchetSenderChainKey initialChainKey = new FastRatchetSenderChainKey(KeyHelper.generateSenderKey(), scale);
+          senderKeyRecord.setSenderKeyState(KeyHelper.generateSenderKeyId(),
+                                            0,
+                                            initialChainKey.getSeeds(),
+                                            KeyHelper.generateSenderSigningKey());
+          senderKeyStore.storeFastRatchetSenderKey(senderKeyName, senderKeyRecord);
+        }
+
+        FastRatchetSenderKeyState state = senderKeyRecord.getSenderKeyState();
+
+        if (FastRatchetUtil.scaleToDimensions(scale) != state.getSenderChainKey().getSeeds().length) {
+          throw new IllegalArgumentException("scale does not match the saved state");
+        }
+
+        return new FastRatchetSenderKeyDistributionMessage(state.getKeyId(),
+                                                           state.getSenderChainKey().getIteration(),
+                                                           state.getSenderChainKey().getSeeds(),
+                                                           state.getSigningKeyPublic());
+
+      } catch (InvalidKeyIdException | InvalidKeyException e) {
+        throw new AssertionError(e);
+      }
+    }
+  }
+}
diff --git a/java/src/main/java/org/whispersystems/libsignal/groups/ratchet/FastRatchetSenderChainKey.java b/java/src/main/java/org/whispersystems/libsignal/groups/ratchet/FastRatchetSenderChainKey.java
new file mode 100644
index 0000000..138c58d
--- /dev/null
+++ b/java/src/main/java/org/whispersystems/libsignal/groups/ratchet/FastRatchetSenderChainKey.java
@@ -0,0 +1,175 @@
+/**
+ * Copyright (C) 2017 WhatsApp Inc. All rights reserved.
+ *
+ * Licensed according to the LICENSE file in this repository.
+ */
+package org.whispersystems.libsignal.groups.ratchet;
+
+import org.whispersystems.libsignal.state.StorageProtos;
+import org.whispersystems.libsignal.util.FastRatchetUtil;
+
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.List;
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+/**
+ * Each SenderKey is a "chain" of keys, each derived from the previous.
+ *
+ * At any given point in time, the state of a SenderKey can be represented
+ * as the current chain key value, along with its iteration count.  From there,
+ * subsequent iterations can be derived, as well as individual message keys from
+ * each chain key.
+ */
+public class FastRatchetSenderChainKey {
+
+  private static final byte MESSAGE_KEY_SEED = (byte) 0x01;
+  private static final byte CHAIN_KEY_SEED   = (byte) 0x02;
+
+  private final int      iteration;
+  private final byte[][] chainKeys;
+
+  public FastRatchetSenderChainKey(byte[] baseChainKey, int scale) {
+    if (scale < 0 || scale > 5) {
+      throw new IllegalArgumentException("scale must be between 0 and 5");
+    }
+
+    int count = FastRatchetUtil.scaleToDimensions(scale);
+    this.iteration = 0;
+
+    this.chainKeys = new byte[count][];
+    this.chainKeys[0] = baseChainKey;
+
+    for (int i = 1; i < count; i++) {
+      this.chainKeys[i] = new byte[0];
+    }
+  }
+
+  public FastRatchetSenderChainKey(int iteration, byte[][] chainKeys) {
+    if (chainKeys.length == 0 || 32 % chainKeys.length != 0) {
+      throw new IllegalArgumentException("Invalid number of chain keys: " + chainKeys.length);
+    }
+
+    validateChainKeyParameters(iteration, chainKeys);
+
+    this.iteration = iteration;
+    this.chainKeys = chainKeys;
+  }
+
+  public FastRatchetSenderChainKey(List<StorageProtos.SenderKeyStateStructure.SenderChainKey> senderChainKeysList) {
+    if (senderChainKeysList.isEmpty() || 32 % senderChainKeysList.size() != 0) {
+      throw new IllegalArgumentException("Invalid number of chain keys: " + senderChainKeysList.size());
+    }
+
+    int   chainCount          = senderChainKeysList.size();
+    int[] iterationComponents = new int[chainCount];
+    this.chainKeys = new byte[chainCount][];
+
+    for (int i = 0; i < chainCount; i++) {
+      iterationComponents[i] = senderChainKeysList.get(i).getIteration();
+      this.chainKeys[i] = senderChainKeysList.get(i).getSeed().toByteArray();
+    }
+
+    this.iteration = FastRatchetUtil.composeChainIterations(iterationComponents);
+
+    validateChainKeyParameters(this.iteration, this.chainKeys);
+  }
+
+  private static void validateChainKeyParameters(int iteration, byte[][] chainKeys) {
+    if (iteration == 0 && chainKeys.length > 1 && chainKeys[1].length == 0) {
+      for (int i = 2; i < chainKeys.length; i++) {
+        if (chainKeys[i].length > 0) {
+          throw new IllegalArgumentException("Invalid chain key values for starting iteration");
+        }
+      }
+    } else {
+      for (int i = 0; i < chainKeys.length; i++) {
+        if (chainKeys[i].length == 0) {
+          throw new IllegalArgumentException("Invalid chain key values");
+        }
+      }
+    }
+  }
+
+  public int getIteration() {
+    return iteration;
+  }
+
+  public SenderMessageKey getSenderMessageKey() {
+    byte[][] chainKeysToUse = getDerivedSeeds();
+    return new SenderMessageKey(getIteration(), getDerivative(MESSAGE_KEY_SEED, chainKeysToUse[chainKeysToUse.length - 1]));
+  }
+
+  public FastRatchetSenderChainKey getNext() {
+    return getNext(1);
+  }
+
+  public FastRatchetSenderChainKey getNext(int count) {
+    if (count <= 0) {
+      throw new IllegalArgumentException("count must be a positive number: " + count);
+    }
+
+    int   nextIteration        = iteration + count;
+    int[] currentDecomposition = FastRatchetUtil.decomposeChainIterations(iteration, chainKeys.length);
+    int[] nextDecomposition    = FastRatchetUtil.decomposeChainIterations(nextIteration, chainKeys.length);
+
+    byte[][] chainKeysToUse = getDerivedSeeds();
+
+    ratchetChainKeys(currentDecomposition, nextDecomposition, chainKeysToUse);
+
+    return new FastRatchetSenderChainKey(nextIteration, chainKeysToUse);
+  }
+
+  private void ratchetChainKeys(int[] currentDecomposition, int[] nextDecomposition, byte[][] chains) {
+    for (int i = 0; i < chains.length; i++) {
+      while (nextDecomposition[i] > currentDecomposition[i]) {
+        if (i < chains.length - 1 && nextDecomposition[i] - 1 == currentDecomposition[i]) {
+          chains[i + 1] = getDerivative((byte) (CHAIN_KEY_SEED + i + 1), chains[i]);
+          currentDecomposition[i + 1] = 0;
+        }
+        chains[i] = getDerivative((byte) (CHAIN_KEY_SEED + i), chains[i]);
+        currentDecomposition[i]++;
+      }
+    }
+  }
+
+  public byte[][] getSeeds() {
+    return chainKeys;
+  }
+
+  /**
+   * This method is only exposed for testing.
+   */
+  public byte[][] getDerivedSeeds() {
+    byte[][] seeds = new byte[chainKeys.length][];
+
+    if (iteration == 0 && chainKeys.length > 1 && chainKeys[1].length == 0) {
+      for (int i = 0; i < chainKeys.length - 1; i++) {
+        byte[] currentKey = (i == 0) ? chainKeys[0] : seeds[i];
+        seeds[i + 1] = getDerivative((byte) (CHAIN_KEY_SEED + i + 1), currentKey);
+        seeds[i] = getDerivative((byte) (CHAIN_KEY_SEED + i), currentKey);
+      }
+    } else {
+      for (int i = 0; i < chainKeys.length; i++) {
+        seeds[i] = new byte[chainKeys[i].length];
+        System.arraycopy(chainKeys[i], 0, seeds[i], 0, chainKeys[i].length);
+      }
+    }
+
+    return seeds;
+  }
+
+  private byte[] getDerivative(byte seed, byte[] key) {
+    try {
+      Mac mac = Mac.getInstance("HmacSHA256");
+      mac.init(new SecretKeySpec(key, "HmacSHA256"));
+      mac.update(seed);
+      return mac.doFinal();
+    } catch (NoSuchAlgorithmException | InvalidKeyException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+}
diff --git a/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyRecord.java b/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyRecord.java
new file mode 100644
index 0000000..463bf7f
--- /dev/null
+++ b/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyRecord.java
@@ -0,0 +1,82 @@
+/**
+ * Copyright (C) 2017 WhatsApp Inc. All rights reserved.
+ *
+ * Licensed according to the LICENSE file in this repository.
+ */
+package org.whispersystems.libsignal.groups.state;
+
+import org.whispersystems.libsignal.InvalidKeyIdException;
+import org.whispersystems.libsignal.ecc.ECKeyPair;
+import org.whispersystems.libsignal.ecc.ECPublicKey;
+import org.whispersystems.libsignal.state.StorageProtos;
+
+import java.io.IOException;
+import java.util.LinkedList;
+
+/**
+ * A durable representation of a set of FastRatchetSenderKeyStates for a specific
+ * SenderKeyName.
+ */
+public class FastRatchetSenderKeyRecord {
+
+  private static final int MAX_STATES = 5;
+
+  private LinkedList<FastRatchetSenderKeyState> senderKeyStates = new LinkedList<>();
+
+  public FastRatchetSenderKeyRecord() {}
+
+  public FastRatchetSenderKeyRecord(byte[] serialized) throws IOException {
+    StorageProtos.FastRatchetSenderKeyRecordStructure senderKeyRecordStructure =
+            StorageProtos.FastRatchetSenderKeyRecordStructure.parseFrom(serialized);
+
+    for (StorageProtos.FastRatchetSenderKeyStateStructure structure : senderKeyRecordStructure.getSenderKeyStatesList()) {
+      this.senderKeyStates.add(new FastRatchetSenderKeyState(structure));
+    }
+  }
+
+  public boolean isEmpty() {
+    return senderKeyStates.isEmpty();
+  }
+
+  public FastRatchetSenderKeyState getSenderKeyState() throws InvalidKeyIdException {
+    if (!senderKeyStates.isEmpty()) {
+      return senderKeyStates.get(0);
+    } else {
+      throw new InvalidKeyIdException("No key state in record!");
+    }
+  }
+
+  public FastRatchetSenderKeyState getSenderKeyState(int keyId) throws InvalidKeyIdException {
+    for (FastRatchetSenderKeyState state : senderKeyStates) {
+      if (state.getKeyId() == keyId) {
+        return state;
+      }
+    }
+
+    throw new InvalidKeyIdException("No keys for: " + keyId);
+  }
+
+  public void addSenderKeyState(int id, int iteration, byte[][] chainKeys, ECPublicKey signatureKey) {
+    senderKeyStates.addFirst(new FastRatchetSenderKeyState(id, iteration, chainKeys, signatureKey));
+
+    if (senderKeyStates.size() > MAX_STATES) {
+      senderKeyStates.removeLast();
+    }
+  }
+
+  public void setSenderKeyState(int id, int iteration, byte[][] chainKeys, ECKeyPair signatureKey) {
+    senderKeyStates.clear();
+    senderKeyStates.add(new FastRatchetSenderKeyState(id, iteration, chainKeys, signatureKey));
+  }
+
+  public byte[] serialize() {
+    StorageProtos.FastRatchetSenderKeyRecordStructure.Builder recordStructure =
+            StorageProtos.FastRatchetSenderKeyRecordStructure.newBuilder();
+
+    for (FastRatchetSenderKeyState senderKeyState : senderKeyStates) {
+      recordStructure.addSenderKeyStates(senderKeyState.getStructure());
+    }
+
+    return recordStructure.build().toByteArray();
+  }
+}
diff --git a/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyState.java b/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyState.java
new file mode 100644
index 0000000..b2ba4c4
--- /dev/null
+++ b/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyState.java
@@ -0,0 +1,112 @@
+/**
+ * Copyright (C) 2017 WhatsApp Inc. All rights reserved.
+ *
+ * Licensed according to the LICENSE file in this repository.
+ */
+package org.whispersystems.libsignal.groups.state;
+
+import com.google.protobuf.ByteString;
+
+import org.whispersystems.libsignal.InvalidKeyException;
+import org.whispersystems.libsignal.ecc.Curve;
+import org.whispersystems.libsignal.ecc.ECKeyPair;
+import org.whispersystems.libsignal.ecc.ECPrivateKey;
+import org.whispersystems.libsignal.ecc.ECPublicKey;
+import org.whispersystems.libsignal.groups.ratchet.FastRatchetSenderChainKey;
+import org.whispersystems.libsignal.util.FastRatchetUtil;
+import org.whispersystems.libsignal.util.guava.Optional;
+
+import org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure;
+import org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure;
+
+/**
+ * Represents the state of an individual SenderKey ratchet.
+ */
+public class FastRatchetSenderKeyState {
+
+  private FastRatchetSenderKeyStateStructure senderKeyStateStructure;
+
+  public FastRatchetSenderKeyState(int id, int iteration, byte[][] chainKeys, ECPublicKey signatureKey) {
+    this(id, iteration, chainKeys, signatureKey, Optional.<ECPrivateKey>absent());
+  }
+
+  public FastRatchetSenderKeyState(int id, int iteration, byte[][] chainKeys, ECKeyPair signatureKey) {
+    this(id, iteration, chainKeys, signatureKey.getPublicKey(), Optional.of(signatureKey.getPrivateKey()));
+  }
+
+  private FastRatchetSenderKeyState(int id, int iteration, byte[][] chainKeys,
+                                    ECPublicKey signatureKeyPublic,
+                                    Optional<ECPrivateKey> signatureKeyPrivate)
+  {
+    SenderKeyStateStructure.SenderSigningKey.Builder signingKeyStructure =
+        SenderKeyStateStructure.SenderSigningKey.newBuilder()
+                                                .setPublic(ByteString.copyFrom(signatureKeyPublic.serialize()));
+
+    if (signatureKeyPrivate.isPresent()) {
+      signingKeyStructure.setPrivate(ByteString.copyFrom(signatureKeyPrivate.get().serialize()));
+    }
+
+    FastRatchetSenderKeyStateStructure.Builder builder =
+        FastRatchetSenderKeyStateStructure.newBuilder()
+                                          .setSenderKeyId(id)
+                                          .setSenderSigningKey(signingKeyStructure);
+
+    int[] chainIterations = FastRatchetUtil.decomposeChainIterations(iteration, chainKeys.length);
+    for (int i = 0; i < chainKeys.length; i++) {
+      SenderKeyStateStructure.SenderChainKey senderChainKeyStructure =
+          SenderKeyStateStructure.SenderChainKey.newBuilder()
+                                                .setIteration(chainIterations[i])
+                                                .setSeed(ByteString.copyFrom(chainKeys[i]))
+                                                .build();
+      builder.addSenderChainKeys(senderChainKeyStructure);
+    }
+
+    this.senderKeyStateStructure = builder.build();
+  }
+
+  public FastRatchetSenderKeyState(FastRatchetSenderKeyStateStructure senderKeyStateStructure) {
+    this.senderKeyStateStructure = senderKeyStateStructure;
+  }
+
+  public int getKeyId() {
+    return senderKeyStateStructure.getSenderKeyId();
+  }
+
+  public FastRatchetSenderChainKey getSenderChainKey() {
+    return new FastRatchetSenderChainKey(senderKeyStateStructure.getSenderChainKeysList());
+  }
+
+  public void setSenderChainKey(FastRatchetSenderChainKey chainKey) {
+    byte[][] seeds          = chainKey.getSeeds();
+    int[]    seedIterations = FastRatchetUtil.decomposeChainIterations(chainKey.getIteration(), seeds.length);
+
+    FastRatchetSenderKeyStateStructure.Builder builder = senderKeyStateStructure.toBuilder()
+                                                                                .clearSenderChainKeys();
+
+    for (int i = 0; i < seeds.length; i++) {
+      SenderKeyStateStructure.SenderChainKey senderChainKeyStructure =
+          SenderKeyStateStructure.SenderChainKey.newBuilder()
+                                                .setIteration(seedIterations[i])
+                                                .setSeed(ByteString.copyFrom(seeds[i]))
+                                                .build();
+      builder.addSenderChainKeys(senderChainKeyStructure);
+    }
+
+    this.senderKeyStateStructure = builder.build();
+  }
+
+  public ECPublicKey getSigningKeyPublic() throws InvalidKeyException {
+    return Curve.decodePoint(senderKeyStateStructure.getSenderSigningKey()
+                                                    .getPublic()
+                                                    .toByteArray(), 0);
+  }
+
+  public ECPrivateKey getSigningKeyPrivate() {
+    return Curve.decodePrivatePoint(senderKeyStateStructure.getSenderSigningKey()
+                                                           .getPrivate().toByteArray());
+  }
+
+  public FastRatchetSenderKeyStateStructure getStructure() {
+    return senderKeyStateStructure;
+  }
+}
diff --git a/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyStore.java b/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyStore.java
new file mode 100644
index 0000000..5031e9e
--- /dev/null
+++ b/java/src/main/java/org/whispersystems/libsignal/groups/state/FastRatchetSenderKeyStore.java
@@ -0,0 +1,37 @@
+/**
+ * Copyright (C) 2017 WhatsApp Inc. All rights reserved.
+ *
+ * Licensed according to the LICENSE file in this repository.
+ */
+package org.whispersystems.libsignal.groups.state;
+
+import org.whispersystems.libsignal.groups.SenderKeyName;
+
+public interface FastRatchetSenderKeyStore {
+
+  /**
+   * Commit to storage the {@link org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyRecord}
+   * for a given (groupId + senderId + deviceId) tuple.
+   *
+   * @param senderKeyName the (groupId + senderId + deviceId) tuple.
+   * @param record the current FastRatchetSenderKeyRecord for the specified senderKeyName.
+   */
+  public void storeFastRatchetSenderKey(SenderKeyName senderKeyName, FastRatchetSenderKeyRecord record);
+
+  /**
+   * Returns a copy of the {@link org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyRecord}
+   * corresponding to the (groupId + senderId + deviceId) tuple, or a new FastRatchetSenderKeyRecord if
+   * one does not currently exist.
+   * <p>
+   * It is important that implementations return a copy of the current durable information.  The
+   * returned FastRatchetSenderKeyRecord may be modified, but those changes should not have an
+   * effect on the durable session state (what is returned by subsequent calls to this method)
+   * without the store method being called here first.
+   *
+   * @param senderKeyName The (groupId + senderId + deviceId) tuple.
+   * @return a copy of the FastRatchetSenderKeyRecord corresponding to the (groupId + senderId + deviceId
+   *         tuple, or a new SenderKeyRecord if one does not currently exist.
+   */
+
+  public FastRatchetSenderKeyRecord loadFastRatchetSenderKey(SenderKeyName senderKeyName);
+}
diff --git a/java/src/main/java/org/whispersystems/libsignal/protocol/CiphertextMessage.java b/java/src/main/java/org/whispersystems/libsignal/protocol/CiphertextMessage.java
index 4584261..59c9a10 100644
--- a/java/src/main/java/org/whispersystems/libsignal/protocol/CiphertextMessage.java
+++ b/java/src/main/java/org/whispersystems/libsignal/protocol/CiphertextMessage.java
@@ -10,10 +10,11 @@ public interface CiphertextMessage {
   public static final int UNSUPPORTED_VERSION = 1;
   public static final int CURRENT_VERSION     = 3;
 
-  public static final int WHISPER_TYPE                = 2;
-  public static final int PREKEY_TYPE                 = 3;
-  public static final int SENDERKEY_TYPE              = 4;
-  public static final int SENDERKEY_DISTRIBUTION_TYPE = 5;
+  public static final int WHISPER_TYPE                            = 2;
+  public static final int PREKEY_TYPE                             = 3;
+  public static final int SENDERKEY_TYPE                          = 4;
+  public static final int SENDERKEY_DISTRIBUTION_TYPE             = 5;
+  public static final int FASTRATCHET_SENDERKEY_DISTRIBUTION_TYPE = 6;
 
   // This should be the worst case (worse than V2).  So not always accurate, but good enough for padding.
   public static final int ENCRYPTED_MESSAGE_OVERHEAD = 53;
diff --git a/java/src/main/java/org/whispersystems/libsignal/protocol/FastRatchetSenderKeyDistributionMessage.java b/java/src/main/java/org/whispersystems/libsignal/protocol/FastRatchetSenderKeyDistributionMessage.java
new file mode 100644
index 0000000..35e6a3c
--- /dev/null
+++ b/java/src/main/java/org/whispersystems/libsignal/protocol/FastRatchetSenderKeyDistributionMessage.java
@@ -0,0 +1,114 @@
+/**
+ * Copyright (C) 2017 WhatsApp Inc. All rights reserved.
+ *
+ * Licensed according to the LICENSE file in this repository.
+ */
+package org.whispersystems.libsignal.protocol;
+
+import com.google.protobuf.ByteString;
+import com.google.protobuf.InvalidProtocolBufferException;
+
+import org.whispersystems.libsignal.InvalidKeyException;
+import org.whispersystems.libsignal.InvalidMessageException;
+import org.whispersystems.libsignal.LegacyMessageException;
+import org.whispersystems.libsignal.ecc.Curve;
+import org.whispersystems.libsignal.ecc.ECPublicKey;
+import org.whispersystems.libsignal.util.ByteUtil;
+
+import java.util.List;
+
+public class FastRatchetSenderKeyDistributionMessage implements CiphertextMessage {
+
+  private final int         id;
+  private final int         iteration;
+  private final byte[][]    chainKeys;
+  private final ECPublicKey signatureKey;
+  private final byte[]      serialized;
+
+  public FastRatchetSenderKeyDistributionMessage(int id, int iteration, byte[][] chainKeys, ECPublicKey signatureKey) {
+    byte[] version = {ByteUtil.intsToByteHighAndLow(CURRENT_VERSION, CURRENT_VERSION)};
+
+    SignalProtos.FastRatchetSenderKeyDistributionMessage.Builder builder = SignalProtos.FastRatchetSenderKeyDistributionMessage.newBuilder()
+            .setId(id)
+            .setIteration(iteration)
+            .setSigningKey(ByteString.copyFrom(signatureKey.serialize()));
+
+    for (byte[] chainKey : chainKeys) {
+      builder.addChainKeys(ByteString.copyFrom(chainKey));
+    }
+
+    byte[] protobuf = builder.build().toByteArray();
+
+    this.id           = id;
+    this.iteration    = iteration;
+    this.chainKeys    = chainKeys;
+    this.signatureKey = signatureKey;
+    this.serialized   = ByteUtil.combine(version, protobuf);
+  }
+
+  public FastRatchetSenderKeyDistributionMessage(byte[] serialized) throws LegacyMessageException, InvalidMessageException {
+    try {
+      byte[][] messageParts = ByteUtil.split(serialized, 1, serialized.length - 1);
+      byte     version      = messageParts[0][0];
+      byte[]   message      = messageParts[1];
+
+      if (ByteUtil.highBitsToInt(version) < CiphertextMessage.CURRENT_VERSION) {
+        throw new LegacyMessageException("Legacy message: " + ByteUtil.highBitsToInt(version));
+      }
+
+      if (ByteUtil.highBitsToInt(version) > CURRENT_VERSION) {
+        throw new InvalidMessageException("Unknown version: " + ByteUtil.highBitsToInt(version));
+      }
+
+      SignalProtos.FastRatchetSenderKeyDistributionMessage distributionMessage = SignalProtos.FastRatchetSenderKeyDistributionMessage.parseFrom(message);
+
+      if (!distributionMessage.hasId()        ||
+              !distributionMessage.hasIteration() ||
+              distributionMessage.getChainKeysCount() <= 0 ||
+              !distributionMessage.hasSigningKey())
+      {
+        throw new InvalidMessageException("Incomplete message.");
+      }
+
+      this.serialized   = serialized;
+      this.id           = distributionMessage.getId();
+      this.iteration    = distributionMessage.getIteration();
+      this.signatureKey = Curve.decodePoint(distributionMessage.getSigningKey().toByteArray(), 0);
+
+      List<ByteString> chainKeyList = distributionMessage.getChainKeysList();
+      this.chainKeys = new byte[chainKeyList.size()][];
+      for (int i = 0; i < this.chainKeys.length; i++) {
+        this.chainKeys[i] = chainKeyList.get(i).toByteArray();
+      }
+
+    } catch (InvalidProtocolBufferException | InvalidKeyException e) {
+      throw new InvalidMessageException(e);
+    }
+  }
+
+  @Override
+  public byte[] serialize() {
+    return serialized;
+  }
+
+  @Override
+  public int getType() {
+    return FASTRATCHET_SENDERKEY_DISTRIBUTION_TYPE;
+  }
+
+  public int getIteration() {
+    return iteration;
+  }
+
+  public byte[][] getChainKeys() {
+    return chainKeys;
+  }
+
+  public ECPublicKey getSignatureKey() {
+    return signatureKey;
+  }
+
+  public int getId() {
+    return id;
+  }
+}
diff --git a/java/src/main/java/org/whispersystems/libsignal/protocol/SignalProtos.java b/java/src/main/java/org/whispersystems/libsignal/protocol/SignalProtos.java
index 82e1140..fd28548 100644
--- a/java/src/main/java/org/whispersystems/libsignal/protocol/SignalProtos.java
+++ b/java/src/main/java/org/whispersystems/libsignal/protocol/SignalProtos.java
@@ -711,7 +711,7 @@ public final class SignalProtos {
      * <code>optional bytes message = 4;</code>
      *
      * <pre>
-     * WhisperMessage
+     * SignalMessage
      * </pre>
      */
     boolean hasMessage();
@@ -719,7 +719,7 @@ public final class SignalProtos {
      * <code>optional bytes message = 4;</code>
      *
      * <pre>
-     * WhisperMessage
+     * SignalMessage
      * </pre>
      */
     com.google.protobuf.ByteString getMessage();
@@ -932,7 +932,7 @@ public final class SignalProtos {
      * <code>optional bytes message = 4;</code>
      *
      * <pre>
-     * WhisperMessage
+     * SignalMessage
      * </pre>
      */
     public boolean hasMessage() {
@@ -942,7 +942,7 @@ public final class SignalProtos {
      * <code>optional bytes message = 4;</code>
      *
      * <pre>
-     * WhisperMessage
+     * SignalMessage
      * </pre>
      */
     public com.google.protobuf.ByteString getMessage() {
@@ -1438,7 +1438,7 @@ public final class SignalProtos {
        * <code>optional bytes message = 4;</code>
        *
        * <pre>
-       * WhisperMessage
+       * SignalMessage
        * </pre>
        */
       public boolean hasMessage() {
@@ -1448,7 +1448,7 @@ public final class SignalProtos {
        * <code>optional bytes message = 4;</code>
        *
        * <pre>
-       * WhisperMessage
+       * SignalMessage
        * </pre>
        */
       public com.google.protobuf.ByteString getMessage() {
@@ -1458,7 +1458,7 @@ public final class SignalProtos {
        * <code>optional bytes message = 4;</code>
        *
        * <pre>
-       * WhisperMessage
+       * SignalMessage
        * </pre>
        */
       public Builder setMessage(com.google.protobuf.ByteString value) {
@@ -1474,7 +1474,7 @@ public final class SignalProtos {
        * <code>optional bytes message = 4;</code>
        *
        * <pre>
-       * WhisperMessage
+       * SignalMessage
        * </pre>
        */
       public Builder clearMessage() {
@@ -3433,6 +3433,717 @@ public final class SignalProtos {
     // @@protoc_insertion_point(class_scope:textsecure.SenderKeyDistributionMessage)
   }
 
+  public interface FastRatchetSenderKeyDistributionMessageOrBuilder
+      extends com.google.protobuf.MessageOrBuilder {
+
+    // optional uint32 id = 1;
+    /**
+     * <code>optional uint32 id = 1;</code>
+     */
+    boolean hasId();
+    /**
+     * <code>optional uint32 id = 1;</code>
+     */
+    int getId();
+
+    // optional uint32 iteration = 2;
+    /**
+     * <code>optional uint32 iteration = 2;</code>
+     */
+    boolean hasIteration();
+    /**
+     * <code>optional uint32 iteration = 2;</code>
+     */
+    int getIteration();
+
+    // repeated bytes chainKeys = 3;
+    /**
+     * <code>repeated bytes chainKeys = 3;</code>
+     */
+    java.util.List<com.google.protobuf.ByteString> getChainKeysList();
+    /**
+     * <code>repeated bytes chainKeys = 3;</code>
+     */
+    int getChainKeysCount();
+    /**
+     * <code>repeated bytes chainKeys = 3;</code>
+     */
+    com.google.protobuf.ByteString getChainKeys(int index);
+
+    // optional bytes signingKey = 4;
+    /**
+     * <code>optional bytes signingKey = 4;</code>
+     */
+    boolean hasSigningKey();
+    /**
+     * <code>optional bytes signingKey = 4;</code>
+     */
+    com.google.protobuf.ByteString getSigningKey();
+  }
+  /**
+   * Protobuf type {@code textsecure.FastRatchetSenderKeyDistributionMessage}
+   */
+  public static final class FastRatchetSenderKeyDistributionMessage extends
+      com.google.protobuf.GeneratedMessage
+      implements FastRatchetSenderKeyDistributionMessageOrBuilder {
+    // Use FastRatchetSenderKeyDistributionMessage.newBuilder() to construct.
+    private FastRatchetSenderKeyDistributionMessage(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
+      super(builder);
+      this.unknownFields = builder.getUnknownFields();
+    }
+    private FastRatchetSenderKeyDistributionMessage(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
+
+    private static final FastRatchetSenderKeyDistributionMessage defaultInstance;
+    public static FastRatchetSenderKeyDistributionMessage getDefaultInstance() {
+      return defaultInstance;
+    }
+
+    public FastRatchetSenderKeyDistributionMessage getDefaultInstanceForType() {
+      return defaultInstance;
+    }
+
+    private final com.google.protobuf.UnknownFieldSet unknownFields;
+    @java.lang.Override
+    public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+      return this.unknownFields;
+    }
+    private FastRatchetSenderKeyDistributionMessage(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      initFields();
+      int mutable_bitField0_ = 0;
+      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+          com.google.protobuf.UnknownFieldSet.newBuilder();
+      try {
+        boolean done = false;
+        while (!done) {
+          int tag = input.readTag();
+          switch (tag) {
+            case 0:
+              done = true;
+              break;
+            default: {
+              if (!parseUnknownField(input, unknownFields,
+                                     extensionRegistry, tag)) {
+                done = true;
+              }
+              break;
+            }
+            case 8: {
+              bitField0_ |= 0x00000001;
+              id_ = input.readUInt32();
+              break;
+            }
+            case 16: {
+              bitField0_ |= 0x00000002;
+              iteration_ = input.readUInt32();
+              break;
+            }
+            case 26: {
+              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
+                chainKeys_ = new java.util.ArrayList<com.google.protobuf.ByteString>();
+                mutable_bitField0_ |= 0x00000004;
+              }
+              chainKeys_.add(input.readBytes());
+              break;
+            }
+            case 34: {
+              bitField0_ |= 0x00000004;
+              signingKey_ = input.readBytes();
+              break;
+            }
+          }
+        }
+      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+        throw e.setUnfinishedMessage(this);
+      } catch (java.io.IOException e) {
+        throw new com.google.protobuf.InvalidProtocolBufferException(
+            e.getMessage()).setUnfinishedMessage(this);
+      } finally {
+        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
+          chainKeys_ = java.util.Collections.unmodifiableList(chainKeys_);
+        }
+        this.unknownFields = unknownFields.build();
+        makeExtensionsImmutable();
+      }
+    }
+    public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+      return org.whispersystems.libsignal.protocol.SignalProtos.internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_descriptor;
+    }
+
+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+      return org.whispersystems.libsignal.protocol.SignalProtos.internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_fieldAccessorTable
+          .ensureFieldAccessorsInitialized(
+              org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage.class, org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage.Builder.class);
+    }
+
+    public static com.google.protobuf.Parser<FastRatchetSenderKeyDistributionMessage> PARSER =
+        new com.google.protobuf.AbstractParser<FastRatchetSenderKeyDistributionMessage>() {
+      public FastRatchetSenderKeyDistributionMessage parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return new FastRatchetSenderKeyDistributionMessage(input, extensionRegistry);
+      }
+    };
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<FastRatchetSenderKeyDistributionMessage> getParserForType() {
+      return PARSER;
+    }
+
+    private int bitField0_;
+    // optional uint32 id = 1;
+    public static final int ID_FIELD_NUMBER = 1;
+    private int id_;
+    /**
+     * <code>optional uint32 id = 1;</code>
+     */
+    public boolean hasId() {
+      return ((bitField0_ & 0x00000001) == 0x00000001);
+    }
+    /**
+     * <code>optional uint32 id = 1;</code>
+     */
+    public int getId() {
+      return id_;
+    }
+
+    // optional uint32 iteration = 2;
+    public static final int ITERATION_FIELD_NUMBER = 2;
+    private int iteration_;
+    /**
+     * <code>optional uint32 iteration = 2;</code>
+     */
+    public boolean hasIteration() {
+      return ((bitField0_ & 0x00000002) == 0x00000002);
+    }
+    /**
+     * <code>optional uint32 iteration = 2;</code>
+     */
+    public int getIteration() {
+      return iteration_;
+    }
+
+    // repeated bytes chainKeys = 3;
+    public static final int CHAINKEYS_FIELD_NUMBER = 3;
+    private java.util.List<com.google.protobuf.ByteString> chainKeys_;
+    /**
+     * <code>repeated bytes chainKeys = 3;</code>
+     */
+    public java.util.List<com.google.protobuf.ByteString>
+        getChainKeysList() {
+      return chainKeys_;
+    }
+    /**
+     * <code>repeated bytes chainKeys = 3;</code>
+     */
+    public int getChainKeysCount() {
+      return chainKeys_.size();
+    }
+    /**
+     * <code>repeated bytes chainKeys = 3;</code>
+     */
+    public com.google.protobuf.ByteString getChainKeys(int index) {
+      return chainKeys_.get(index);
+    }
+
+    // optional bytes signingKey = 4;
+    public static final int SIGNINGKEY_FIELD_NUMBER = 4;
+    private com.google.protobuf.ByteString signingKey_;
+    /**
+     * <code>optional bytes signingKey = 4;</code>
+     */
+    public boolean hasSigningKey() {
+      return ((bitField0_ & 0x00000004) == 0x00000004);
+    }
+    /**
+     * <code>optional bytes signingKey = 4;</code>
+     */
+    public com.google.protobuf.ByteString getSigningKey() {
+      return signingKey_;
+    }
+
+    private void initFields() {
+      id_ = 0;
+      iteration_ = 0;
+      chainKeys_ = java.util.Collections.emptyList();
+      signingKey_ = com.google.protobuf.ByteString.EMPTY;
+    }
+    private byte memoizedIsInitialized = -1;
+    public final boolean isInitialized() {
+      byte isInitialized = memoizedIsInitialized;
+      if (isInitialized != -1) return isInitialized == 1;
+
+      memoizedIsInitialized = 1;
+      return true;
+    }
+
+    public void writeTo(com.google.protobuf.CodedOutputStream output)
+                        throws java.io.IOException {
+      getSerializedSize();
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        output.writeUInt32(1, id_);
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        output.writeUInt32(2, iteration_);
+      }
+      for (int i = 0; i < chainKeys_.size(); i++) {
+        output.writeBytes(3, chainKeys_.get(i));
+      }
+      if (((bitField0_ & 0x00000004) == 0x00000004)) {
+        output.writeBytes(4, signingKey_);
+      }
+      getUnknownFields().writeTo(output);
+    }
+
+    private int memoizedSerializedSize = -1;
+    public int getSerializedSize() {
+      int size = memoizedSerializedSize;
+      if (size != -1) return size;
+
+      size = 0;
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeUInt32Size(1, id_);
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeUInt32Size(2, iteration_);
+      }
+      {
+        int dataSize = 0;
+        for (int i = 0; i < chainKeys_.size(); i++) {
+          dataSize += com.google.protobuf.CodedOutputStream
+            .computeBytesSizeNoTag(chainKeys_.get(i));
+        }
+        size += dataSize;
+        size += 1 * getChainKeysList().size();
+      }
+      if (((bitField0_ & 0x00000004) == 0x00000004)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeBytesSize(4, signingKey_);
+      }
+      size += getUnknownFields().getSerializedSize();
+      memoizedSerializedSize = size;
+      return size;
+    }
+
+    private static final long serialVersionUID = 0L;
+    @java.lang.Override
+    protected java.lang.Object writeReplace()
+        throws java.io.ObjectStreamException {
+      return super.writeReplace();
+    }
+
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+
+    public static Builder newBuilder() { return Builder.create(); }
+    public Builder newBuilderForType() { return newBuilder(); }
+    public static Builder newBuilder(org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage prototype) {
+      return newBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() { return newBuilder(this); }
+
+    @java.lang.Override
+    protected Builder newBuilderForType(
+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+      Builder builder = new Builder(parent);
+      return builder;
+    }
+    /**
+     * Protobuf type {@code textsecure.FastRatchetSenderKeyDistributionMessage}
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessage.Builder<Builder>
+       implements org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessageOrBuilder {
+      public static final com.google.protobuf.Descriptors.Descriptor
+          getDescriptor() {
+        return org.whispersystems.libsignal.protocol.SignalProtos.internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_descriptor;
+      }
+
+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+          internalGetFieldAccessorTable() {
+        return org.whispersystems.libsignal.protocol.SignalProtos.internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_fieldAccessorTable
+            .ensureFieldAccessorsInitialized(
+                org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage.class, org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage.Builder.class);
+      }
+
+      // Construct using org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage.newBuilder()
+      private Builder() {
+        maybeForceBuilderInitialization();
+      }
+
+      private Builder(
+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+        super(parent);
+        maybeForceBuilderInitialization();
+      }
+      private void maybeForceBuilderInitialization() {
+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+        }
+      }
+      private static Builder create() {
+        return new Builder();
+      }
+
+      public Builder clear() {
+        super.clear();
+        id_ = 0;
+        bitField0_ = (bitField0_ & ~0x00000001);
+        iteration_ = 0;
+        bitField0_ = (bitField0_ & ~0x00000002);
+        chainKeys_ = java.util.Collections.emptyList();
+        bitField0_ = (bitField0_ & ~0x00000004);
+        signingKey_ = com.google.protobuf.ByteString.EMPTY;
+        bitField0_ = (bitField0_ & ~0x00000008);
+        return this;
+      }
+
+      public Builder clone() {
+        return create().mergeFrom(buildPartial());
+      }
+
+      public com.google.protobuf.Descriptors.Descriptor
+          getDescriptorForType() {
+        return org.whispersystems.libsignal.protocol.SignalProtos.internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_descriptor;
+      }
+
+      public org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage getDefaultInstanceForType() {
+        return org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage.getDefaultInstance();
+      }
+
+      public org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage build() {
+        org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage result = buildPartial();
+        if (!result.isInitialized()) {
+          throw newUninitializedMessageException(result);
+        }
+        return result;
+      }
+
+      public org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage buildPartial() {
+        org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage result = new org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage(this);
+        int from_bitField0_ = bitField0_;
+        int to_bitField0_ = 0;
+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+          to_bitField0_ |= 0x00000001;
+        }
+        result.id_ = id_;
+        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
+          to_bitField0_ |= 0x00000002;
+        }
+        result.iteration_ = iteration_;
+        if (((bitField0_ & 0x00000004) == 0x00000004)) {
+          chainKeys_ = java.util.Collections.unmodifiableList(chainKeys_);
+          bitField0_ = (bitField0_ & ~0x00000004);
+        }
+        result.chainKeys_ = chainKeys_;
+        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
+          to_bitField0_ |= 0x00000004;
+        }
+        result.signingKey_ = signingKey_;
+        result.bitField0_ = to_bitField0_;
+        onBuilt();
+        return result;
+      }
+
+      public Builder mergeFrom(com.google.protobuf.Message other) {
+        if (other instanceof org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage) {
+          return mergeFrom((org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage)other);
+        } else {
+          super.mergeFrom(other);
+          return this;
+        }
+      }
+
+      public Builder mergeFrom(org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage other) {
+        if (other == org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage.getDefaultInstance()) return this;
+        if (other.hasId()) {
+          setId(other.getId());
+        }
+        if (other.hasIteration()) {
+          setIteration(other.getIteration());
+        }
+        if (!other.chainKeys_.isEmpty()) {
+          if (chainKeys_.isEmpty()) {
+            chainKeys_ = other.chainKeys_;
+            bitField0_ = (bitField0_ & ~0x00000004);
+          } else {
+            ensureChainKeysIsMutable();
+            chainKeys_.addAll(other.chainKeys_);
+          }
+          onChanged();
+        }
+        if (other.hasSigningKey()) {
+          setSigningKey(other.getSigningKey());
+        }
+        this.mergeUnknownFields(other.getUnknownFields());
+        return this;
+      }
+
+      public final boolean isInitialized() {
+        return true;
+      }
+
+      public Builder mergeFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage parsedMessage = null;
+        try {
+          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+          parsedMessage = (org.whispersystems.libsignal.protocol.SignalProtos.FastRatchetSenderKeyDistributionMessage) e.getUnfinishedMessage();
+          throw e;
+        } finally {
+          if (parsedMessage != null) {
+            mergeFrom(parsedMessage);
+          }
+        }
+        return this;
+      }
+      private int bitField0_;
+
+      // optional uint32 id = 1;
+      private int id_ ;
+      /**
+       * <code>optional uint32 id = 1;</code>
+       */
+      public boolean hasId() {
+        return ((bitField0_ & 0x00000001) == 0x00000001);
+      }
+      /**
+       * <code>optional uint32 id = 1;</code>
+       */
+      public int getId() {
+        return id_;
+      }
+      /**
+       * <code>optional uint32 id = 1;</code>
+       */
+      public Builder setId(int value) {
+        bitField0_ |= 0x00000001;
+        id_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional uint32 id = 1;</code>
+       */
+      public Builder clearId() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        id_ = 0;
+        onChanged();
+        return this;
+      }
+
+      // optional uint32 iteration = 2;
+      private int iteration_ ;
+      /**
+       * <code>optional uint32 iteration = 2;</code>
+       */
+      public boolean hasIteration() {
+        return ((bitField0_ & 0x00000002) == 0x00000002);
+      }
+      /**
+       * <code>optional uint32 iteration = 2;</code>
+       */
+      public int getIteration() {
+        return iteration_;
+      }
+      /**
+       * <code>optional uint32 iteration = 2;</code>
+       */
+      public Builder setIteration(int value) {
+        bitField0_ |= 0x00000002;
+        iteration_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional uint32 iteration = 2;</code>
+       */
+      public Builder clearIteration() {
+        bitField0_ = (bitField0_ & ~0x00000002);
+        iteration_ = 0;
+        onChanged();
+        return this;
+      }
+
+      // repeated bytes chainKeys = 3;
+      private java.util.List<com.google.protobuf.ByteString> chainKeys_ = java.util.Collections.emptyList();
+      private void ensureChainKeysIsMutable() {
+        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
+          chainKeys_ = new java.util.ArrayList<com.google.protobuf.ByteString>(chainKeys_);
+          bitField0_ |= 0x00000004;
+         }
+      }
+      /**
+       * <code>repeated bytes chainKeys = 3;</code>
+       */
+      public java.util.List<com.google.protobuf.ByteString>
+          getChainKeysList() {
+        return java.util.Collections.unmodifiableList(chainKeys_);
+      }
+      /**
+       * <code>repeated bytes chainKeys = 3;</code>
+       */
+      public int getChainKeysCount() {
+        return chainKeys_.size();
+      }
+      /**
+       * <code>repeated bytes chainKeys = 3;</code>
+       */
+      public com.google.protobuf.ByteString getChainKeys(int index) {
+        return chainKeys_.get(index);
+      }
+      /**
+       * <code>repeated bytes chainKeys = 3;</code>
+       */
+      public Builder setChainKeys(
+          int index, com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  ensureChainKeysIsMutable();
+        chainKeys_.set(index, value);
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>repeated bytes chainKeys = 3;</code>
+       */
+      public Builder addChainKeys(com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  ensureChainKeysIsMutable();
+        chainKeys_.add(value);
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>repeated bytes chainKeys = 3;</code>
+       */
+      public Builder addAllChainKeys(
+          java.lang.Iterable<? extends com.google.protobuf.ByteString> values) {
+        ensureChainKeysIsMutable();
+        super.addAll(values, chainKeys_);
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>repeated bytes chainKeys = 3;</code>
+       */
+      public Builder clearChainKeys() {
+        chainKeys_ = java.util.Collections.emptyList();
+        bitField0_ = (bitField0_ & ~0x00000004);
+        onChanged();
+        return this;
+      }
+
+      // optional bytes signingKey = 4;
+      private com.google.protobuf.ByteString signingKey_ = com.google.protobuf.ByteString.EMPTY;
+      /**
+       * <code>optional bytes signingKey = 4;</code>
+       */
+      public boolean hasSigningKey() {
+        return ((bitField0_ & 0x00000008) == 0x00000008);
+      }
+      /**
+       * <code>optional bytes signingKey = 4;</code>
+       */
+      public com.google.protobuf.ByteString getSigningKey() {
+        return signingKey_;
+      }
+      /**
+       * <code>optional bytes signingKey = 4;</code>
+       */
+      public Builder setSigningKey(com.google.protobuf.ByteString value) {
+        if (value == null) {
+    throw new NullPointerException();
+  }
+  bitField0_ |= 0x00000008;
+        signingKey_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional bytes signingKey = 4;</code>
+       */
+      public Builder clearSigningKey() {
+        bitField0_ = (bitField0_ & ~0x00000008);
+        signingKey_ = getDefaultInstance().getSigningKey();
+        onChanged();
+        return this;
+      }
+
+      // @@protoc_insertion_point(builder_scope:textsecure.FastRatchetSenderKeyDistributionMessage)
+    }
+
+    static {
+      defaultInstance = new FastRatchetSenderKeyDistributionMessage(true);
+      defaultInstance.initFields();
+    }
+
+    // @@protoc_insertion_point(class_scope:textsecure.FastRatchetSenderKeyDistributionMessage)
+  }
+
   public interface DeviceConsistencyCodeMessageOrBuilder
       extends com.google.protobuf.MessageOrBuilder {
 
@@ -3939,6 +4650,11 @@ public final class SignalProtos {
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
       internal_static_textsecure_SenderKeyDistributionMessage_fieldAccessorTable;
   private static com.google.protobuf.Descriptors.Descriptor
+    internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_descriptor;
+  private static
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+      internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_fieldAccessorTable;
+  private static com.google.protobuf.Descriptors.Descriptor
     internal_static_textsecure_DeviceConsistencyCodeMessage_descriptor;
   private static
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
@@ -3966,10 +4682,13 @@ public final class SignalProtos {
       "ration\030\002 \001(\r\022\022\n\nciphertext\030\003 \001(\014\"c\n\034Send" +
       "erKeyDistributionMessage\022\n\n\002id\030\001 \001(\r\022\021\n\t" +
       "iteration\030\002 \001(\r\022\020\n\010chainKey\030\003 \001(\014\022\022\n\nsig" +
-      "ningKey\030\004 \001(\014\"E\n\034DeviceConsistencyCodeMe" +
-      "ssage\022\022\n\ngeneration\030\001 \001(\r\022\021\n\tsignature\030\002" +
-      " \001(\014B5\n%org.whispersystems.libsignal.pro" +
-      "tocolB\014SignalProtos"
+      "ningKey\030\004 \001(\014\"o\n\'FastRatchetSenderKeyDis" +
+      "tributionMessage\022\n\n\002id\030\001 \001(\r\022\021\n\titeratio" +
+      "n\030\002 \001(\r\022\021\n\tchainKeys\030\003 \003(\014\022\022\n\nsigningKey" +
+      "\030\004 \001(\014\"E\n\034DeviceConsistencyCodeMessage\022\022" +
+      "\n\ngeneration\030\001 \001(\r\022\021\n\tsignature\030\002 \001(\014B5\n" +
+      "%org.whispersystems.libsignal.protocolB\014",
+      "SignalProtos"
     };
     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
@@ -4006,8 +4725,14 @@ public final class SignalProtos {
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_textsecure_SenderKeyDistributionMessage_descriptor,
               new java.lang.String[] { "Id", "Iteration", "ChainKey", "SigningKey", });
-          internal_static_textsecure_DeviceConsistencyCodeMessage_descriptor =
+          internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_descriptor =
             getDescriptor().getMessageTypes().get(5);
+          internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_fieldAccessorTable = new
+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+              internal_static_textsecure_FastRatchetSenderKeyDistributionMessage_descriptor,
+              new java.lang.String[] { "Id", "Iteration", "ChainKeys", "SigningKey", });
+          internal_static_textsecure_DeviceConsistencyCodeMessage_descriptor =
+            getDescriptor().getMessageTypes().get(6);
           internal_static_textsecure_DeviceConsistencyCodeMessage_fieldAccessorTable = new
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_textsecure_DeviceConsistencyCodeMessage_descriptor,
diff --git a/java/src/main/java/org/whispersystems/libsignal/state/StorageProtos.java b/java/src/main/java/org/whispersystems/libsignal/state/StorageProtos.java
index 6fceb8f..0e4701e 100644
--- a/java/src/main/java/org/whispersystems/libsignal/state/StorageProtos.java
+++ b/java/src/main/java/org/whispersystems/libsignal/state/StorageProtos.java
@@ -11532,6 +11532,1630 @@ public final class StorageProtos {
     // @@protoc_insertion_point(class_scope:textsecure.SenderKeyRecordStructure)
   }
 
+  public interface FastRatchetSenderKeyStateStructureOrBuilder
+      extends com.google.protobuf.MessageOrBuilder {
+
+    // optional uint32 senderKeyId = 1;
+    /**
+     * <code>optional uint32 senderKeyId = 1;</code>
+     */
+    boolean hasSenderKeyId();
+    /**
+     * <code>optional uint32 senderKeyId = 1;</code>
+     */
+    int getSenderKeyId();
+
+    // repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    java.util.List<org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey> 
+        getSenderChainKeysList();
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey getSenderChainKeys(int index);
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    int getSenderChainKeysCount();
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    java.util.List<? extends org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder> 
+        getSenderChainKeysOrBuilderList();
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder getSenderChainKeysOrBuilder(
+        int index);
+
+    // optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
+    /**
+     * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+     */
+    boolean hasSenderSigningKey();
+    /**
+     * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+     */
+    org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey getSenderSigningKey();
+    /**
+     * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+     */
+    org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKeyOrBuilder getSenderSigningKeyOrBuilder();
+  }
+  /**
+   * Protobuf type {@code textsecure.FastRatchetSenderKeyStateStructure}
+   */
+  public static final class FastRatchetSenderKeyStateStructure extends
+      com.google.protobuf.GeneratedMessage
+      implements FastRatchetSenderKeyStateStructureOrBuilder {
+    // Use FastRatchetSenderKeyStateStructure.newBuilder() to construct.
+    private FastRatchetSenderKeyStateStructure(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
+      super(builder);
+      this.unknownFields = builder.getUnknownFields();
+    }
+    private FastRatchetSenderKeyStateStructure(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
+
+    private static final FastRatchetSenderKeyStateStructure defaultInstance;
+    public static FastRatchetSenderKeyStateStructure getDefaultInstance() {
+      return defaultInstance;
+    }
+
+    public FastRatchetSenderKeyStateStructure getDefaultInstanceForType() {
+      return defaultInstance;
+    }
+
+    private final com.google.protobuf.UnknownFieldSet unknownFields;
+    @java.lang.Override
+    public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+      return this.unknownFields;
+    }
+    private FastRatchetSenderKeyStateStructure(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      initFields();
+      int mutable_bitField0_ = 0;
+      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+          com.google.protobuf.UnknownFieldSet.newBuilder();
+      try {
+        boolean done = false;
+        while (!done) {
+          int tag = input.readTag();
+          switch (tag) {
+            case 0:
+              done = true;
+              break;
+            default: {
+              if (!parseUnknownField(input, unknownFields,
+                                     extensionRegistry, tag)) {
+                done = true;
+              }
+              break;
+            }
+            case 8: {
+              bitField0_ |= 0x00000001;
+              senderKeyId_ = input.readUInt32();
+              break;
+            }
+            case 18: {
+              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
+                senderChainKeys_ = new java.util.ArrayList<org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey>();
+                mutable_bitField0_ |= 0x00000002;
+              }
+              senderChainKeys_.add(input.readMessage(org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.PARSER, extensionRegistry));
+              break;
+            }
+            case 26: {
+              org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.Builder subBuilder = null;
+              if (((bitField0_ & 0x00000002) == 0x00000002)) {
+                subBuilder = senderSigningKey_.toBuilder();
+              }
+              senderSigningKey_ = input.readMessage(org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.PARSER, extensionRegistry);
+              if (subBuilder != null) {
+                subBuilder.mergeFrom(senderSigningKey_);
+                senderSigningKey_ = subBuilder.buildPartial();
+              }
+              bitField0_ |= 0x00000002;
+              break;
+            }
+          }
+        }
+      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+        throw e.setUnfinishedMessage(this);
+      } catch (java.io.IOException e) {
+        throw new com.google.protobuf.InvalidProtocolBufferException(
+            e.getMessage()).setUnfinishedMessage(this);
+      } finally {
+        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
+          senderChainKeys_ = java.util.Collections.unmodifiableList(senderChainKeys_);
+        }
+        this.unknownFields = unknownFields.build();
+        makeExtensionsImmutable();
+      }
+    }
+    public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+      return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyStateStructure_descriptor;
+    }
+
+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+      return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyStateStructure_fieldAccessorTable
+          .ensureFieldAccessorsInitialized(
+              org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.class, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder.class);
+    }
+
+    public static com.google.protobuf.Parser<FastRatchetSenderKeyStateStructure> PARSER =
+        new com.google.protobuf.AbstractParser<FastRatchetSenderKeyStateStructure>() {
+      public FastRatchetSenderKeyStateStructure parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return new FastRatchetSenderKeyStateStructure(input, extensionRegistry);
+      }
+    };
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<FastRatchetSenderKeyStateStructure> getParserForType() {
+      return PARSER;
+    }
+
+    private int bitField0_;
+    // optional uint32 senderKeyId = 1;
+    public static final int SENDERKEYID_FIELD_NUMBER = 1;
+    private int senderKeyId_;
+    /**
+     * <code>optional uint32 senderKeyId = 1;</code>
+     */
+    public boolean hasSenderKeyId() {
+      return ((bitField0_ & 0x00000001) == 0x00000001);
+    }
+    /**
+     * <code>optional uint32 senderKeyId = 1;</code>
+     */
+    public int getSenderKeyId() {
+      return senderKeyId_;
+    }
+
+    // repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;
+    public static final int SENDERCHAINKEYS_FIELD_NUMBER = 2;
+    private java.util.List<org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey> senderChainKeys_;
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    public java.util.List<org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey> getSenderChainKeysList() {
+      return senderChainKeys_;
+    }
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    public java.util.List<? extends org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder> 
+        getSenderChainKeysOrBuilderList() {
+      return senderChainKeys_;
+    }
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    public int getSenderChainKeysCount() {
+      return senderChainKeys_.size();
+    }
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey getSenderChainKeys(int index) {
+      return senderChainKeys_.get(index);
+    }
+    /**
+     * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+     */
+    public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder getSenderChainKeysOrBuilder(
+        int index) {
+      return senderChainKeys_.get(index);
+    }
+
+    // optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
+    public static final int SENDERSIGNINGKEY_FIELD_NUMBER = 3;
+    private org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey senderSigningKey_;
+    /**
+     * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+     */
+    public boolean hasSenderSigningKey() {
+      return ((bitField0_ & 0x00000002) == 0x00000002);
+    }
+    /**
+     * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+     */
+    public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey getSenderSigningKey() {
+      return senderSigningKey_;
+    }
+    /**
+     * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+     */
+    public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKeyOrBuilder getSenderSigningKeyOrBuilder() {
+      return senderSigningKey_;
+    }
+
+    private void initFields() {
+      senderKeyId_ = 0;
+      senderChainKeys_ = java.util.Collections.emptyList();
+      senderSigningKey_ = org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.getDefaultInstance();
+    }
+    private byte memoizedIsInitialized = -1;
+    public final boolean isInitialized() {
+      byte isInitialized = memoizedIsInitialized;
+      if (isInitialized != -1) return isInitialized == 1;
+
+      memoizedIsInitialized = 1;
+      return true;
+    }
+
+    public void writeTo(com.google.protobuf.CodedOutputStream output)
+                        throws java.io.IOException {
+      getSerializedSize();
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        output.writeUInt32(1, senderKeyId_);
+      }
+      for (int i = 0; i < senderChainKeys_.size(); i++) {
+        output.writeMessage(2, senderChainKeys_.get(i));
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        output.writeMessage(3, senderSigningKey_);
+      }
+      getUnknownFields().writeTo(output);
+    }
+
+    private int memoizedSerializedSize = -1;
+    public int getSerializedSize() {
+      int size = memoizedSerializedSize;
+      if (size != -1) return size;
+
+      size = 0;
+      if (((bitField0_ & 0x00000001) == 0x00000001)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeUInt32Size(1, senderKeyId_);
+      }
+      for (int i = 0; i < senderChainKeys_.size(); i++) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeMessageSize(2, senderChainKeys_.get(i));
+      }
+      if (((bitField0_ & 0x00000002) == 0x00000002)) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeMessageSize(3, senderSigningKey_);
+      }
+      size += getUnknownFields().getSerializedSize();
+      memoizedSerializedSize = size;
+      return size;
+    }
+
+    private static final long serialVersionUID = 0L;
+    @java.lang.Override
+    protected java.lang.Object writeReplace()
+        throws java.io.ObjectStreamException {
+      return super.writeReplace();
+    }
+
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+
+    public static Builder newBuilder() { return Builder.create(); }
+    public Builder newBuilderForType() { return newBuilder(); }
+    public static Builder newBuilder(org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure prototype) {
+      return newBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() { return newBuilder(this); }
+
+    @java.lang.Override
+    protected Builder newBuilderForType(
+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+      Builder builder = new Builder(parent);
+      return builder;
+    }
+    /**
+     * Protobuf type {@code textsecure.FastRatchetSenderKeyStateStructure}
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessage.Builder<Builder>
+       implements org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder {
+      public static final com.google.protobuf.Descriptors.Descriptor
+          getDescriptor() {
+        return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyStateStructure_descriptor;
+      }
+
+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+          internalGetFieldAccessorTable() {
+        return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyStateStructure_fieldAccessorTable
+            .ensureFieldAccessorsInitialized(
+                org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.class, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder.class);
+      }
+
+      // Construct using org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.newBuilder()
+      private Builder() {
+        maybeForceBuilderInitialization();
+      }
+
+      private Builder(
+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+        super(parent);
+        maybeForceBuilderInitialization();
+      }
+      private void maybeForceBuilderInitialization() {
+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+          getSenderChainKeysFieldBuilder();
+          getSenderSigningKeyFieldBuilder();
+        }
+      }
+      private static Builder create() {
+        return new Builder();
+      }
+
+      public Builder clear() {
+        super.clear();
+        senderKeyId_ = 0;
+        bitField0_ = (bitField0_ & ~0x00000001);
+        if (senderChainKeysBuilder_ == null) {
+          senderChainKeys_ = java.util.Collections.emptyList();
+          bitField0_ = (bitField0_ & ~0x00000002);
+        } else {
+          senderChainKeysBuilder_.clear();
+        }
+        if (senderSigningKeyBuilder_ == null) {
+          senderSigningKey_ = org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.getDefaultInstance();
+        } else {
+          senderSigningKeyBuilder_.clear();
+        }
+        bitField0_ = (bitField0_ & ~0x00000004);
+        return this;
+      }
+
+      public Builder clone() {
+        return create().mergeFrom(buildPartial());
+      }
+
+      public com.google.protobuf.Descriptors.Descriptor
+          getDescriptorForType() {
+        return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyStateStructure_descriptor;
+      }
+
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure getDefaultInstanceForType() {
+        return org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.getDefaultInstance();
+      }
+
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure build() {
+        org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure result = buildPartial();
+        if (!result.isInitialized()) {
+          throw newUninitializedMessageException(result);
+        }
+        return result;
+      }
+
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure buildPartial() {
+        org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure result = new org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure(this);
+        int from_bitField0_ = bitField0_;
+        int to_bitField0_ = 0;
+        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
+          to_bitField0_ |= 0x00000001;
+        }
+        result.senderKeyId_ = senderKeyId_;
+        if (senderChainKeysBuilder_ == null) {
+          if (((bitField0_ & 0x00000002) == 0x00000002)) {
+            senderChainKeys_ = java.util.Collections.unmodifiableList(senderChainKeys_);
+            bitField0_ = (bitField0_ & ~0x00000002);
+          }
+          result.senderChainKeys_ = senderChainKeys_;
+        } else {
+          result.senderChainKeys_ = senderChainKeysBuilder_.build();
+        }
+        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
+          to_bitField0_ |= 0x00000002;
+        }
+        if (senderSigningKeyBuilder_ == null) {
+          result.senderSigningKey_ = senderSigningKey_;
+        } else {
+          result.senderSigningKey_ = senderSigningKeyBuilder_.build();
+        }
+        result.bitField0_ = to_bitField0_;
+        onBuilt();
+        return result;
+      }
+
+      public Builder mergeFrom(com.google.protobuf.Message other) {
+        if (other instanceof org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure) {
+          return mergeFrom((org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure)other);
+        } else {
+          super.mergeFrom(other);
+          return this;
+        }
+      }
+
+      public Builder mergeFrom(org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure other) {
+        if (other == org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.getDefaultInstance()) return this;
+        if (other.hasSenderKeyId()) {
+          setSenderKeyId(other.getSenderKeyId());
+        }
+        if (senderChainKeysBuilder_ == null) {
+          if (!other.senderChainKeys_.isEmpty()) {
+            if (senderChainKeys_.isEmpty()) {
+              senderChainKeys_ = other.senderChainKeys_;
+              bitField0_ = (bitField0_ & ~0x00000002);
+            } else {
+              ensureSenderChainKeysIsMutable();
+              senderChainKeys_.addAll(other.senderChainKeys_);
+            }
+            onChanged();
+          }
+        } else {
+          if (!other.senderChainKeys_.isEmpty()) {
+            if (senderChainKeysBuilder_.isEmpty()) {
+              senderChainKeysBuilder_.dispose();
+              senderChainKeysBuilder_ = null;
+              senderChainKeys_ = other.senderChainKeys_;
+              bitField0_ = (bitField0_ & ~0x00000002);
+              senderChainKeysBuilder_ = 
+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
+                   getSenderChainKeysFieldBuilder() : null;
+            } else {
+              senderChainKeysBuilder_.addAllMessages(other.senderChainKeys_);
+            }
+          }
+        }
+        if (other.hasSenderSigningKey()) {
+          mergeSenderSigningKey(other.getSenderSigningKey());
+        }
+        this.mergeUnknownFields(other.getUnknownFields());
+        return this;
+      }
+
+      public final boolean isInitialized() {
+        return true;
+      }
+
+      public Builder mergeFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure parsedMessage = null;
+        try {
+          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+          parsedMessage = (org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure) e.getUnfinishedMessage();
+          throw e;
+        } finally {
+          if (parsedMessage != null) {
+            mergeFrom(parsedMessage);
+          }
+        }
+        return this;
+      }
+      private int bitField0_;
+
+      // optional uint32 senderKeyId = 1;
+      private int senderKeyId_ ;
+      /**
+       * <code>optional uint32 senderKeyId = 1;</code>
+       */
+      public boolean hasSenderKeyId() {
+        return ((bitField0_ & 0x00000001) == 0x00000001);
+      }
+      /**
+       * <code>optional uint32 senderKeyId = 1;</code>
+       */
+      public int getSenderKeyId() {
+        return senderKeyId_;
+      }
+      /**
+       * <code>optional uint32 senderKeyId = 1;</code>
+       */
+      public Builder setSenderKeyId(int value) {
+        bitField0_ |= 0x00000001;
+        senderKeyId_ = value;
+        onChanged();
+        return this;
+      }
+      /**
+       * <code>optional uint32 senderKeyId = 1;</code>
+       */
+      public Builder clearSenderKeyId() {
+        bitField0_ = (bitField0_ & ~0x00000001);
+        senderKeyId_ = 0;
+        onChanged();
+        return this;
+      }
+
+      // repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;
+      private java.util.List<org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey> senderChainKeys_ =
+        java.util.Collections.emptyList();
+      private void ensureSenderChainKeysIsMutable() {
+        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
+          senderChainKeys_ = new java.util.ArrayList<org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey>(senderChainKeys_);
+          bitField0_ |= 0x00000002;
+         }
+      }
+
+      private com.google.protobuf.RepeatedFieldBuilder<
+          org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder> senderChainKeysBuilder_;
+
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public java.util.List<org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey> getSenderChainKeysList() {
+        if (senderChainKeysBuilder_ == null) {
+          return java.util.Collections.unmodifiableList(senderChainKeys_);
+        } else {
+          return senderChainKeysBuilder_.getMessageList();
+        }
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public int getSenderChainKeysCount() {
+        if (senderChainKeysBuilder_ == null) {
+          return senderChainKeys_.size();
+        } else {
+          return senderChainKeysBuilder_.getCount();
+        }
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey getSenderChainKeys(int index) {
+        if (senderChainKeysBuilder_ == null) {
+          return senderChainKeys_.get(index);
+        } else {
+          return senderChainKeysBuilder_.getMessage(index);
+        }
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder setSenderChainKeys(
+          int index, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey value) {
+        if (senderChainKeysBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          ensureSenderChainKeysIsMutable();
+          senderChainKeys_.set(index, value);
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.setMessage(index, value);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder setSenderChainKeys(
+          int index, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder builderForValue) {
+        if (senderChainKeysBuilder_ == null) {
+          ensureSenderChainKeysIsMutable();
+          senderChainKeys_.set(index, builderForValue.build());
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.setMessage(index, builderForValue.build());
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder addSenderChainKeys(org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey value) {
+        if (senderChainKeysBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          ensureSenderChainKeysIsMutable();
+          senderChainKeys_.add(value);
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.addMessage(value);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder addSenderChainKeys(
+          int index, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey value) {
+        if (senderChainKeysBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          ensureSenderChainKeysIsMutable();
+          senderChainKeys_.add(index, value);
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.addMessage(index, value);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder addSenderChainKeys(
+          org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder builderForValue) {
+        if (senderChainKeysBuilder_ == null) {
+          ensureSenderChainKeysIsMutable();
+          senderChainKeys_.add(builderForValue.build());
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.addMessage(builderForValue.build());
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder addSenderChainKeys(
+          int index, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder builderForValue) {
+        if (senderChainKeysBuilder_ == null) {
+          ensureSenderChainKeysIsMutable();
+          senderChainKeys_.add(index, builderForValue.build());
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.addMessage(index, builderForValue.build());
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder addAllSenderChainKeys(
+          java.lang.Iterable<? extends org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey> values) {
+        if (senderChainKeysBuilder_ == null) {
+          ensureSenderChainKeysIsMutable();
+          super.addAll(values, senderChainKeys_);
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.addAllMessages(values);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder clearSenderChainKeys() {
+        if (senderChainKeysBuilder_ == null) {
+          senderChainKeys_ = java.util.Collections.emptyList();
+          bitField0_ = (bitField0_ & ~0x00000002);
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.clear();
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public Builder removeSenderChainKeys(int index) {
+        if (senderChainKeysBuilder_ == null) {
+          ensureSenderChainKeysIsMutable();
+          senderChainKeys_.remove(index);
+          onChanged();
+        } else {
+          senderChainKeysBuilder_.remove(index);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder getSenderChainKeysBuilder(
+          int index) {
+        return getSenderChainKeysFieldBuilder().getBuilder(index);
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder getSenderChainKeysOrBuilder(
+          int index) {
+        if (senderChainKeysBuilder_ == null) {
+          return senderChainKeys_.get(index);  } else {
+          return senderChainKeysBuilder_.getMessageOrBuilder(index);
+        }
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public java.util.List<? extends org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder> 
+           getSenderChainKeysOrBuilderList() {
+        if (senderChainKeysBuilder_ != null) {
+          return senderChainKeysBuilder_.getMessageOrBuilderList();
+        } else {
+          return java.util.Collections.unmodifiableList(senderChainKeys_);
+        }
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder addSenderChainKeysBuilder() {
+        return getSenderChainKeysFieldBuilder().addBuilder(
+            org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.getDefaultInstance());
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder addSenderChainKeysBuilder(
+          int index) {
+        return getSenderChainKeysFieldBuilder().addBuilder(
+            index, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.getDefaultInstance());
+      }
+      /**
+       * <code>repeated .textsecure.SenderKeyStateStructure.SenderChainKey senderChainKeys = 2;</code>
+       */
+      public java.util.List<org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder> 
+           getSenderChainKeysBuilderList() {
+        return getSenderChainKeysFieldBuilder().getBuilderList();
+      }
+      private com.google.protobuf.RepeatedFieldBuilder<
+          org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder> 
+          getSenderChainKeysFieldBuilder() {
+        if (senderChainKeysBuilder_ == null) {
+          senderChainKeysBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
+              org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKey.Builder, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderChainKeyOrBuilder>(
+                  senderChainKeys_,
+                  ((bitField0_ & 0x00000002) == 0x00000002),
+                  getParentForChildren(),
+                  isClean());
+          senderChainKeys_ = null;
+        }
+        return senderChainKeysBuilder_;
+      }
+
+      // optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;
+      private org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey senderSigningKey_ = org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.getDefaultInstance();
+      private com.google.protobuf.SingleFieldBuilder<
+          org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.Builder, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKeyOrBuilder> senderSigningKeyBuilder_;
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      public boolean hasSenderSigningKey() {
+        return ((bitField0_ & 0x00000004) == 0x00000004);
+      }
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey getSenderSigningKey() {
+        if (senderSigningKeyBuilder_ == null) {
+          return senderSigningKey_;
+        } else {
+          return senderSigningKeyBuilder_.getMessage();
+        }
+      }
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      public Builder setSenderSigningKey(org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey value) {
+        if (senderSigningKeyBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          senderSigningKey_ = value;
+          onChanged();
+        } else {
+          senderSigningKeyBuilder_.setMessage(value);
+        }
+        bitField0_ |= 0x00000004;
+        return this;
+      }
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      public Builder setSenderSigningKey(
+          org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.Builder builderForValue) {
+        if (senderSigningKeyBuilder_ == null) {
+          senderSigningKey_ = builderForValue.build();
+          onChanged();
+        } else {
+          senderSigningKeyBuilder_.setMessage(builderForValue.build());
+        }
+        bitField0_ |= 0x00000004;
+        return this;
+      }
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      public Builder mergeSenderSigningKey(org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey value) {
+        if (senderSigningKeyBuilder_ == null) {
+          if (((bitField0_ & 0x00000004) == 0x00000004) &&
+              senderSigningKey_ != org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.getDefaultInstance()) {
+            senderSigningKey_ =
+              org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.newBuilder(senderSigningKey_).mergeFrom(value).buildPartial();
+          } else {
+            senderSigningKey_ = value;
+          }
+          onChanged();
+        } else {
+          senderSigningKeyBuilder_.mergeFrom(value);
+        }
+        bitField0_ |= 0x00000004;
+        return this;
+      }
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      public Builder clearSenderSigningKey() {
+        if (senderSigningKeyBuilder_ == null) {
+          senderSigningKey_ = org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.getDefaultInstance();
+          onChanged();
+        } else {
+          senderSigningKeyBuilder_.clear();
+        }
+        bitField0_ = (bitField0_ & ~0x00000004);
+        return this;
+      }
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.Builder getSenderSigningKeyBuilder() {
+        bitField0_ |= 0x00000004;
+        onChanged();
+        return getSenderSigningKeyFieldBuilder().getBuilder();
+      }
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKeyOrBuilder getSenderSigningKeyOrBuilder() {
+        if (senderSigningKeyBuilder_ != null) {
+          return senderSigningKeyBuilder_.getMessageOrBuilder();
+        } else {
+          return senderSigningKey_;
+        }
+      }
+      /**
+       * <code>optional .textsecure.SenderKeyStateStructure.SenderSigningKey senderSigningKey = 3;</code>
+       */
+      private com.google.protobuf.SingleFieldBuilder<
+          org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.Builder, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKeyOrBuilder> 
+          getSenderSigningKeyFieldBuilder() {
+        if (senderSigningKeyBuilder_ == null) {
+          senderSigningKeyBuilder_ = new com.google.protobuf.SingleFieldBuilder<
+              org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKey.Builder, org.whispersystems.libsignal.state.StorageProtos.SenderKeyStateStructure.SenderSigningKeyOrBuilder>(
+                  senderSigningKey_,
+                  getParentForChildren(),
+                  isClean());
+          senderSigningKey_ = null;
+        }
+        return senderSigningKeyBuilder_;
+      }
+
+      // @@protoc_insertion_point(builder_scope:textsecure.FastRatchetSenderKeyStateStructure)
+    }
+
+    static {
+      defaultInstance = new FastRatchetSenderKeyStateStructure(true);
+      defaultInstance.initFields();
+    }
+
+    // @@protoc_insertion_point(class_scope:textsecure.FastRatchetSenderKeyStateStructure)
+  }
+
+  public interface FastRatchetSenderKeyRecordStructureOrBuilder
+      extends com.google.protobuf.MessageOrBuilder {
+
+    // repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    java.util.List<org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure> 
+        getSenderKeyStatesList();
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure getSenderKeyStates(int index);
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    int getSenderKeyStatesCount();
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    java.util.List<? extends org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder> 
+        getSenderKeyStatesOrBuilderList();
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder getSenderKeyStatesOrBuilder(
+        int index);
+  }
+  /**
+   * Protobuf type {@code textsecure.FastRatchetSenderKeyRecordStructure}
+   */
+  public static final class FastRatchetSenderKeyRecordStructure extends
+      com.google.protobuf.GeneratedMessage
+      implements FastRatchetSenderKeyRecordStructureOrBuilder {
+    // Use FastRatchetSenderKeyRecordStructure.newBuilder() to construct.
+    private FastRatchetSenderKeyRecordStructure(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
+      super(builder);
+      this.unknownFields = builder.getUnknownFields();
+    }
+    private FastRatchetSenderKeyRecordStructure(boolean noInit) { this.unknownFields = com.google.protobuf.UnknownFieldSet.getDefaultInstance(); }
+
+    private static final FastRatchetSenderKeyRecordStructure defaultInstance;
+    public static FastRatchetSenderKeyRecordStructure getDefaultInstance() {
+      return defaultInstance;
+    }
+
+    public FastRatchetSenderKeyRecordStructure getDefaultInstanceForType() {
+      return defaultInstance;
+    }
+
+    private final com.google.protobuf.UnknownFieldSet unknownFields;
+    @java.lang.Override
+    public final com.google.protobuf.UnknownFieldSet
+        getUnknownFields() {
+      return this.unknownFields;
+    }
+    private FastRatchetSenderKeyRecordStructure(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      initFields();
+      int mutable_bitField0_ = 0;
+      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
+          com.google.protobuf.UnknownFieldSet.newBuilder();
+      try {
+        boolean done = false;
+        while (!done) {
+          int tag = input.readTag();
+          switch (tag) {
+            case 0:
+              done = true;
+              break;
+            default: {
+              if (!parseUnknownField(input, unknownFields,
+                                     extensionRegistry, tag)) {
+                done = true;
+              }
+              break;
+            }
+            case 10: {
+              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
+                senderKeyStates_ = new java.util.ArrayList<org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure>();
+                mutable_bitField0_ |= 0x00000001;
+              }
+              senderKeyStates_.add(input.readMessage(org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.PARSER, extensionRegistry));
+              break;
+            }
+          }
+        }
+      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+        throw e.setUnfinishedMessage(this);
+      } catch (java.io.IOException e) {
+        throw new com.google.protobuf.InvalidProtocolBufferException(
+            e.getMessage()).setUnfinishedMessage(this);
+      } finally {
+        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
+          senderKeyStates_ = java.util.Collections.unmodifiableList(senderKeyStates_);
+        }
+        this.unknownFields = unknownFields.build();
+        makeExtensionsImmutable();
+      }
+    }
+    public static final com.google.protobuf.Descriptors.Descriptor
+        getDescriptor() {
+      return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyRecordStructure_descriptor;
+    }
+
+    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+        internalGetFieldAccessorTable() {
+      return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyRecordStructure_fieldAccessorTable
+          .ensureFieldAccessorsInitialized(
+              org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure.class, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure.Builder.class);
+    }
+
+    public static com.google.protobuf.Parser<FastRatchetSenderKeyRecordStructure> PARSER =
+        new com.google.protobuf.AbstractParser<FastRatchetSenderKeyRecordStructure>() {
+      public FastRatchetSenderKeyRecordStructure parsePartialFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws com.google.protobuf.InvalidProtocolBufferException {
+        return new FastRatchetSenderKeyRecordStructure(input, extensionRegistry);
+      }
+    };
+
+    @java.lang.Override
+    public com.google.protobuf.Parser<FastRatchetSenderKeyRecordStructure> getParserForType() {
+      return PARSER;
+    }
+
+    // repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;
+    public static final int SENDERKEYSTATES_FIELD_NUMBER = 1;
+    private java.util.List<org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure> senderKeyStates_;
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    public java.util.List<org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure> getSenderKeyStatesList() {
+      return senderKeyStates_;
+    }
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    public java.util.List<? extends org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder> 
+        getSenderKeyStatesOrBuilderList() {
+      return senderKeyStates_;
+    }
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    public int getSenderKeyStatesCount() {
+      return senderKeyStates_.size();
+    }
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure getSenderKeyStates(int index) {
+      return senderKeyStates_.get(index);
+    }
+    /**
+     * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+     */
+    public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder getSenderKeyStatesOrBuilder(
+        int index) {
+      return senderKeyStates_.get(index);
+    }
+
+    private void initFields() {
+      senderKeyStates_ = java.util.Collections.emptyList();
+    }
+    private byte memoizedIsInitialized = -1;
+    public final boolean isInitialized() {
+      byte isInitialized = memoizedIsInitialized;
+      if (isInitialized != -1) return isInitialized == 1;
+
+      memoizedIsInitialized = 1;
+      return true;
+    }
+
+    public void writeTo(com.google.protobuf.CodedOutputStream output)
+                        throws java.io.IOException {
+      getSerializedSize();
+      for (int i = 0; i < senderKeyStates_.size(); i++) {
+        output.writeMessage(1, senderKeyStates_.get(i));
+      }
+      getUnknownFields().writeTo(output);
+    }
+
+    private int memoizedSerializedSize = -1;
+    public int getSerializedSize() {
+      int size = memoizedSerializedSize;
+      if (size != -1) return size;
+
+      size = 0;
+      for (int i = 0; i < senderKeyStates_.size(); i++) {
+        size += com.google.protobuf.CodedOutputStream
+          .computeMessageSize(1, senderKeyStates_.get(i));
+      }
+      size += getUnknownFields().getSerializedSize();
+      memoizedSerializedSize = size;
+      return size;
+    }
+
+    private static final long serialVersionUID = 0L;
+    @java.lang.Override
+    protected java.lang.Object writeReplace()
+        throws java.io.ObjectStreamException {
+      return super.writeReplace();
+    }
+
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseFrom(
+        com.google.protobuf.ByteString data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseFrom(
+        com.google.protobuf.ByteString data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseFrom(byte[] data)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseFrom(
+        byte[] data,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws com.google.protobuf.InvalidProtocolBufferException {
+      return PARSER.parseFrom(data, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseDelimitedFrom(java.io.InputStream input)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseDelimitedFrom(
+        java.io.InputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseDelimitedFrom(input, extensionRegistry);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseFrom(
+        com.google.protobuf.CodedInputStream input)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input);
+    }
+    public static org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parseFrom(
+        com.google.protobuf.CodedInputStream input,
+        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+        throws java.io.IOException {
+      return PARSER.parseFrom(input, extensionRegistry);
+    }
+
+    public static Builder newBuilder() { return Builder.create(); }
+    public Builder newBuilderForType() { return newBuilder(); }
+    public static Builder newBuilder(org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure prototype) {
+      return newBuilder().mergeFrom(prototype);
+    }
+    public Builder toBuilder() { return newBuilder(this); }
+
+    @java.lang.Override
+    protected Builder newBuilderForType(
+        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+      Builder builder = new Builder(parent);
+      return builder;
+    }
+    /**
+     * Protobuf type {@code textsecure.FastRatchetSenderKeyRecordStructure}
+     */
+    public static final class Builder extends
+        com.google.protobuf.GeneratedMessage.Builder<Builder>
+       implements org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructureOrBuilder {
+      public static final com.google.protobuf.Descriptors.Descriptor
+          getDescriptor() {
+        return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyRecordStructure_descriptor;
+      }
+
+      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
+          internalGetFieldAccessorTable() {
+        return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyRecordStructure_fieldAccessorTable
+            .ensureFieldAccessorsInitialized(
+                org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure.class, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure.Builder.class);
+      }
+
+      // Construct using org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure.newBuilder()
+      private Builder() {
+        maybeForceBuilderInitialization();
+      }
+
+      private Builder(
+          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
+        super(parent);
+        maybeForceBuilderInitialization();
+      }
+      private void maybeForceBuilderInitialization() {
+        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
+          getSenderKeyStatesFieldBuilder();
+        }
+      }
+      private static Builder create() {
+        return new Builder();
+      }
+
+      public Builder clear() {
+        super.clear();
+        if (senderKeyStatesBuilder_ == null) {
+          senderKeyStates_ = java.util.Collections.emptyList();
+          bitField0_ = (bitField0_ & ~0x00000001);
+        } else {
+          senderKeyStatesBuilder_.clear();
+        }
+        return this;
+      }
+
+      public Builder clone() {
+        return create().mergeFrom(buildPartial());
+      }
+
+      public com.google.protobuf.Descriptors.Descriptor
+          getDescriptorForType() {
+        return org.whispersystems.libsignal.state.StorageProtos.internal_static_textsecure_FastRatchetSenderKeyRecordStructure_descriptor;
+      }
+
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure getDefaultInstanceForType() {
+        return org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure.getDefaultInstance();
+      }
+
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure build() {
+        org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure result = buildPartial();
+        if (!result.isInitialized()) {
+          throw newUninitializedMessageException(result);
+        }
+        return result;
+      }
+
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure buildPartial() {
+        org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure result = new org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure(this);
+        int from_bitField0_ = bitField0_;
+        if (senderKeyStatesBuilder_ == null) {
+          if (((bitField0_ & 0x00000001) == 0x00000001)) {
+            senderKeyStates_ = java.util.Collections.unmodifiableList(senderKeyStates_);
+            bitField0_ = (bitField0_ & ~0x00000001);
+          }
+          result.senderKeyStates_ = senderKeyStates_;
+        } else {
+          result.senderKeyStates_ = senderKeyStatesBuilder_.build();
+        }
+        onBuilt();
+        return result;
+      }
+
+      public Builder mergeFrom(com.google.protobuf.Message other) {
+        if (other instanceof org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure) {
+          return mergeFrom((org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure)other);
+        } else {
+          super.mergeFrom(other);
+          return this;
+        }
+      }
+
+      public Builder mergeFrom(org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure other) {
+        if (other == org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure.getDefaultInstance()) return this;
+        if (senderKeyStatesBuilder_ == null) {
+          if (!other.senderKeyStates_.isEmpty()) {
+            if (senderKeyStates_.isEmpty()) {
+              senderKeyStates_ = other.senderKeyStates_;
+              bitField0_ = (bitField0_ & ~0x00000001);
+            } else {
+              ensureSenderKeyStatesIsMutable();
+              senderKeyStates_.addAll(other.senderKeyStates_);
+            }
+            onChanged();
+          }
+        } else {
+          if (!other.senderKeyStates_.isEmpty()) {
+            if (senderKeyStatesBuilder_.isEmpty()) {
+              senderKeyStatesBuilder_.dispose();
+              senderKeyStatesBuilder_ = null;
+              senderKeyStates_ = other.senderKeyStates_;
+              bitField0_ = (bitField0_ & ~0x00000001);
+              senderKeyStatesBuilder_ = 
+                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
+                   getSenderKeyStatesFieldBuilder() : null;
+            } else {
+              senderKeyStatesBuilder_.addAllMessages(other.senderKeyStates_);
+            }
+          }
+        }
+        this.mergeUnknownFields(other.getUnknownFields());
+        return this;
+      }
+
+      public final boolean isInitialized() {
+        return true;
+      }
+
+      public Builder mergeFrom(
+          com.google.protobuf.CodedInputStream input,
+          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
+          throws java.io.IOException {
+        org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure parsedMessage = null;
+        try {
+          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
+        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
+          parsedMessage = (org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyRecordStructure) e.getUnfinishedMessage();
+          throw e;
+        } finally {
+          if (parsedMessage != null) {
+            mergeFrom(parsedMessage);
+          }
+        }
+        return this;
+      }
+      private int bitField0_;
+
+      // repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;
+      private java.util.List<org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure> senderKeyStates_ =
+        java.util.Collections.emptyList();
+      private void ensureSenderKeyStatesIsMutable() {
+        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
+          senderKeyStates_ = new java.util.ArrayList<org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure>(senderKeyStates_);
+          bitField0_ |= 0x00000001;
+         }
+      }
+
+      private com.google.protobuf.RepeatedFieldBuilder<
+          org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder> senderKeyStatesBuilder_;
+
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public java.util.List<org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure> getSenderKeyStatesList() {
+        if (senderKeyStatesBuilder_ == null) {
+          return java.util.Collections.unmodifiableList(senderKeyStates_);
+        } else {
+          return senderKeyStatesBuilder_.getMessageList();
+        }
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public int getSenderKeyStatesCount() {
+        if (senderKeyStatesBuilder_ == null) {
+          return senderKeyStates_.size();
+        } else {
+          return senderKeyStatesBuilder_.getCount();
+        }
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure getSenderKeyStates(int index) {
+        if (senderKeyStatesBuilder_ == null) {
+          return senderKeyStates_.get(index);
+        } else {
+          return senderKeyStatesBuilder_.getMessage(index);
+        }
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder setSenderKeyStates(
+          int index, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure value) {
+        if (senderKeyStatesBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          ensureSenderKeyStatesIsMutable();
+          senderKeyStates_.set(index, value);
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.setMessage(index, value);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder setSenderKeyStates(
+          int index, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder builderForValue) {
+        if (senderKeyStatesBuilder_ == null) {
+          ensureSenderKeyStatesIsMutable();
+          senderKeyStates_.set(index, builderForValue.build());
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.setMessage(index, builderForValue.build());
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder addSenderKeyStates(org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure value) {
+        if (senderKeyStatesBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          ensureSenderKeyStatesIsMutable();
+          senderKeyStates_.add(value);
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.addMessage(value);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder addSenderKeyStates(
+          int index, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure value) {
+        if (senderKeyStatesBuilder_ == null) {
+          if (value == null) {
+            throw new NullPointerException();
+          }
+          ensureSenderKeyStatesIsMutable();
+          senderKeyStates_.add(index, value);
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.addMessage(index, value);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder addSenderKeyStates(
+          org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder builderForValue) {
+        if (senderKeyStatesBuilder_ == null) {
+          ensureSenderKeyStatesIsMutable();
+          senderKeyStates_.add(builderForValue.build());
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.addMessage(builderForValue.build());
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder addSenderKeyStates(
+          int index, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder builderForValue) {
+        if (senderKeyStatesBuilder_ == null) {
+          ensureSenderKeyStatesIsMutable();
+          senderKeyStates_.add(index, builderForValue.build());
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.addMessage(index, builderForValue.build());
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder addAllSenderKeyStates(
+          java.lang.Iterable<? extends org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure> values) {
+        if (senderKeyStatesBuilder_ == null) {
+          ensureSenderKeyStatesIsMutable();
+          super.addAll(values, senderKeyStates_);
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.addAllMessages(values);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder clearSenderKeyStates() {
+        if (senderKeyStatesBuilder_ == null) {
+          senderKeyStates_ = java.util.Collections.emptyList();
+          bitField0_ = (bitField0_ & ~0x00000001);
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.clear();
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public Builder removeSenderKeyStates(int index) {
+        if (senderKeyStatesBuilder_ == null) {
+          ensureSenderKeyStatesIsMutable();
+          senderKeyStates_.remove(index);
+          onChanged();
+        } else {
+          senderKeyStatesBuilder_.remove(index);
+        }
+        return this;
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder getSenderKeyStatesBuilder(
+          int index) {
+        return getSenderKeyStatesFieldBuilder().getBuilder(index);
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder getSenderKeyStatesOrBuilder(
+          int index) {
+        if (senderKeyStatesBuilder_ == null) {
+          return senderKeyStates_.get(index);  } else {
+          return senderKeyStatesBuilder_.getMessageOrBuilder(index);
+        }
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public java.util.List<? extends org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder> 
+           getSenderKeyStatesOrBuilderList() {
+        if (senderKeyStatesBuilder_ != null) {
+          return senderKeyStatesBuilder_.getMessageOrBuilderList();
+        } else {
+          return java.util.Collections.unmodifiableList(senderKeyStates_);
+        }
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder addSenderKeyStatesBuilder() {
+        return getSenderKeyStatesFieldBuilder().addBuilder(
+            org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.getDefaultInstance());
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder addSenderKeyStatesBuilder(
+          int index) {
+        return getSenderKeyStatesFieldBuilder().addBuilder(
+            index, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.getDefaultInstance());
+      }
+      /**
+       * <code>repeated .textsecure.FastRatchetSenderKeyStateStructure senderKeyStates = 1;</code>
+       */
+      public java.util.List<org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder> 
+           getSenderKeyStatesBuilderList() {
+        return getSenderKeyStatesFieldBuilder().getBuilderList();
+      }
+      private com.google.protobuf.RepeatedFieldBuilder<
+          org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder> 
+          getSenderKeyStatesFieldBuilder() {
+        if (senderKeyStatesBuilder_ == null) {
+          senderKeyStatesBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
+              org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructure.Builder, org.whispersystems.libsignal.state.StorageProtos.FastRatchetSenderKeyStateStructureOrBuilder>(
+                  senderKeyStates_,
+                  ((bitField0_ & 0x00000001) == 0x00000001),
+                  getParentForChildren(),
+                  isClean());
+          senderKeyStates_ = null;
+        }
+        return senderKeyStatesBuilder_;
+      }
+
+      // @@protoc_insertion_point(builder_scope:textsecure.FastRatchetSenderKeyRecordStructure)
+    }
+
+    static {
+      defaultInstance = new FastRatchetSenderKeyRecordStructure(true);
+      defaultInstance.initFields();
+    }
+
+    // @@protoc_insertion_point(class_scope:textsecure.FastRatchetSenderKeyRecordStructure)
+  }
+
   private static com.google.protobuf.Descriptors.Descriptor
     internal_static_textsecure_SessionStructure_descriptor;
   private static
@@ -11607,6 +13231,16 @@ public final class StorageProtos {
   private static
     com.google.protobuf.GeneratedMessage.FieldAccessorTable
       internal_static_textsecure_SenderKeyRecordStructure_fieldAccessorTable;
+  private static com.google.protobuf.Descriptors.Descriptor
+    internal_static_textsecure_FastRatchetSenderKeyStateStructure_descriptor;
+  private static
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+      internal_static_textsecure_FastRatchetSenderKeyStateStructure_fieldAccessorTable;
+  private static com.google.protobuf.Descriptors.Descriptor
+    internal_static_textsecure_FastRatchetSenderKeyRecordStructure_descriptor;
+  private static
+    com.google.protobuf.GeneratedMessage.FieldAccessorTable
+      internal_static_textsecure_FastRatchetSenderKeyRecordStructure_fieldAccessorTable;
 
   public static com.google.protobuf.Descriptors.FileDescriptor
       getDescriptor() {
@@ -11667,9 +13301,17 @@ public final class StorageProtos {
       "\n\004seed\030\002 \001(\014\0323\n\020SenderSigningKey\022\016\n\006publ" +
       "ic\030\001 \001(\014\022\017\n\007private\030\002 \001(\014\"X\n\030SenderKeyRe",
       "cordStructure\022<\n\017senderKeyStates\030\001 \003(\0132#" +
-      ".textsecure.SenderKeyStateStructureB3\n\"o" +
-      "rg.whispersystems.libsignal.stateB\rStora" +
-      "geProtos"
+      ".textsecure.SenderKeyStateStructure\"\326\001\n\"" +
+      "FastRatchetSenderKeyStateStructure\022\023\n\013se" +
+      "nderKeyId\030\001 \001(\r\022K\n\017senderChainKeys\030\002 \003(\013" +
+      "22.textsecure.SenderKeyStateStructure.Se" +
+      "nderChainKey\022N\n\020senderSigningKey\030\003 \001(\01324" +
+      ".textsecure.SenderKeyStateStructure.Send" +
+      "erSigningKey\"n\n#FastRatchetSenderKeyReco" +
+      "rdStructure\022G\n\017senderKeyStates\030\001 \003(\0132..t" +
+      "extsecure.FastRatchetSenderKeyStateStruc",
+      "tureB3\n\"org.whispersystems.libsignal.sta" +
+      "teB\rStorageProtos"
     };
     com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
       new com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner() {
@@ -11766,6 +13408,18 @@ public final class StorageProtos {
             com.google.protobuf.GeneratedMessage.FieldAccessorTable(
               internal_static_textsecure_SenderKeyRecordStructure_descriptor,
               new java.lang.String[] { "SenderKeyStates", });
+          internal_static_textsecure_FastRatchetSenderKeyStateStructure_descriptor =
+            getDescriptor().getMessageTypes().get(7);
+          internal_static_textsecure_FastRatchetSenderKeyStateStructure_fieldAccessorTable = new
+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+              internal_static_textsecure_FastRatchetSenderKeyStateStructure_descriptor,
+              new java.lang.String[] { "SenderKeyId", "SenderChainKeys", "SenderSigningKey", });
+          internal_static_textsecure_FastRatchetSenderKeyRecordStructure_descriptor =
+            getDescriptor().getMessageTypes().get(8);
+          internal_static_textsecure_FastRatchetSenderKeyRecordStructure_fieldAccessorTable = new
+            com.google.protobuf.GeneratedMessage.FieldAccessorTable(
+              internal_static_textsecure_FastRatchetSenderKeyRecordStructure_descriptor,
+              new java.lang.String[] { "SenderKeyStates", });
           return null;
         }
       };
diff --git a/java/src/main/java/org/whispersystems/libsignal/util/FastRatchetUtil.java b/java/src/main/java/org/whispersystems/libsignal/util/FastRatchetUtil.java
new file mode 100644
index 0000000..098cf24
--- /dev/null
+++ b/java/src/main/java/org/whispersystems/libsignal/util/FastRatchetUtil.java
@@ -0,0 +1,79 @@
+/**
+ * Copyright (C) 2017 WhatsApp Inc. All rights reserved.
+ *
+ * Licensed according to the LICENSE file in this repository.
+ */
+package org.whispersystems.libsignal.util;
+
+/**
+ * Helper class for various conversion operations needed by the fast ratchet
+ * group cipher.
+ */
+public class FastRatchetUtil {
+  private FastRatchetUtil() {}
+
+  /**
+   * Convert the "scale" parameter value into the number of actual key chains
+   * it should represent.
+   */
+  public static int scaleToDimensions(int scale) {
+    return 1 << scale;
+  }
+
+  static int composeIterations(int[] components) {
+    int dimensions = components.length;
+    int bits = 32 / dimensions;
+    int mask = (int)((1L << bits) - 1);
+    int result = 0;
+
+    for (int i = 0; i < dimensions; i++) {
+      result += (components[dimensions - i - 1] & mask) << (bits * i);
+    }
+    return result;
+  }
+
+  /**
+   * Compose individual chain key iterations into the corresponding message
+   * iteration.
+   *
+   * @param chainIterations Individual chain key iterations
+   * @return Message iteration
+   */
+  public static int composeChainIterations(int[] chainIterations) {
+    int[] result = new int[chainIterations.length];
+    for (int i = 0; i < chainIterations.length - 1; i++) {
+      result[i] = chainIterations[i] - 1;
+    }
+    result[chainIterations.length - 1] = chainIterations[chainIterations.length - 1];
+
+    return composeIterations(result);
+  }
+
+  static int[] decomposeIteration(int iteration, int count) {
+    int dimensions = count;
+    int bits = 32 / dimensions;
+    int mask = (int)((1L << bits) - 1);
+    int[] result = new int[count];
+
+    for (int i = 0; i < dimensions; i++) {
+      result[dimensions - i - 1] = (iteration >> bits * i) & mask;
+    }
+
+    return result;
+  }
+
+  /**
+   * Decompose a message iteration into the individual chain key iterations.
+   *
+   * @param iteration The iteration to decompose
+   * @param chainCount The number of chains in the cipher
+   * @return Individual chain key iterations
+   */
+  public static int[] decomposeChainIterations(int iteration, int chainCount) {
+    int[] result = decomposeIteration(iteration, chainCount);
+    for (int i = 0; i < result.length - 1; i++) {
+      result[i]++;
+    }
+    return result;
+  }
+}
diff --git a/protobuf/LocalStorageProtocol.proto b/protobuf/LocalStorageProtocol.proto
index 7de2f19..88117a5 100644
--- a/protobuf/LocalStorageProtocol.proto
+++ b/protobuf/LocalStorageProtocol.proto
@@ -109,4 +109,14 @@ message SenderKeyStateStructure {
 
 message SenderKeyRecordStructure {
     repeated SenderKeyStateStructure senderKeyStates = 1;
+}
+
+message FastRatchetSenderKeyStateStructure {
+    optional uint32                                   senderKeyId       = 1;
+    repeated SenderKeyStateStructure.SenderChainKey   senderChainKeys   = 2;
+    optional SenderKeyStateStructure.SenderSigningKey senderSigningKey  = 3;
+}
+
+message FastRatchetSenderKeyRecordStructure {
+    repeated FastRatchetSenderKeyStateStructure senderKeyStates = 1;
 }
\ No newline at end of file
diff --git a/protobuf/WhisperTextProtocol.proto b/protobuf/WhisperTextProtocol.proto
index f6a3c95..241c260 100644
--- a/protobuf/WhisperTextProtocol.proto
+++ b/protobuf/WhisperTextProtocol.proto
@@ -40,6 +40,13 @@ message SenderKeyDistributionMessage {
   optional bytes  signingKey = 4;
 }
 
+message FastRatchetSenderKeyDistributionMessage {
+  optional uint32 id         = 1;
+  optional uint32 iteration  = 2;
+  repeated bytes  chainKeys  = 3;
+  optional bytes  signingKey = 4;
+}
+
 message DeviceConsistencyCodeMessage {
   optional uint32 generation = 1;
   optional bytes  signature  = 2;
diff --git a/tests/src/test/java/org/whispersystems/libsignal/groups/FastRatchetGroupCipherTest.java b/tests/src/test/java/org/whispersystems/libsignal/groups/FastRatchetGroupCipherTest.java
new file mode 100644
index 0000000..b301902
--- /dev/null
+++ b/tests/src/test/java/org/whispersystems/libsignal/groups/FastRatchetGroupCipherTest.java
@@ -0,0 +1,562 @@
+package org.whispersystems.libsignal.groups;
+
+import android.test.MoreAsserts;
+
+import junit.framework.TestCase;
+
+import org.whispersystems.libsignal.DuplicateMessageException;
+import org.whispersystems.libsignal.InvalidKeyIdException;
+import org.whispersystems.libsignal.InvalidMessageException;
+import org.whispersystems.libsignal.LegacyMessageException;
+import org.whispersystems.libsignal.NoSessionException;
+import org.whispersystems.libsignal.SignalProtocolAddress;
+import org.whispersystems.libsignal.groups.ratchet.FastRatchetSenderChainKey;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyRecord;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyState;
+import org.whispersystems.libsignal.protocol.FastRatchetSenderKeyDistributionMessage;
+import org.whispersystems.libsignal.util.FastRatchetUtil;
+import org.whispersystems.libsignal.util.KeyHelper;
+
+import java.security.InvalidKeyException;
+import java.security.NoSuchAlgorithmException;
+import java.util.Arrays;
+
+import javax.crypto.Mac;
+import javax.crypto.spec.SecretKeySpec;
+
+public class FastRatchetGroupCipherTest extends TestCase {
+
+  private static final SignalProtocolAddress SENDER_ADDRESS = new SignalProtocolAddress("+14150001111", 1);
+  private static final SenderKeyName         GROUP_SENDER   = new SenderKeyName("nihilist history broadcast group", SENDER_ADDRESS);
+
+
+  public void testBasicEncryptDecrypt()
+      throws LegacyMessageException, DuplicateMessageException, InvalidMessageException, NoSessionException
+  {
+    InMemoryFastRatchetSenderKeyStore aliceStore = new InMemoryFastRatchetSenderKeyStore();
+    InMemoryFastRatchetSenderKeyStore bobStore   = new InMemoryFastRatchetSenderKeyStore();
+
+    FastRatchetGroupSessionBuilder aliceSessionBuilder = new FastRatchetGroupSessionBuilder(aliceStore);
+    FastRatchetGroupSessionBuilder bobSessionBuilder   = new FastRatchetGroupSessionBuilder(bobStore);
+
+    FastRatchetGroupCipher aliceGroupCipher = new FastRatchetGroupCipher(aliceStore, GROUP_SENDER);
+    FastRatchetGroupCipher bobGroupCipher   = new FastRatchetGroupCipher(bobStore, GROUP_SENDER);
+
+    FastRatchetSenderKeyDistributionMessage sentAliceDistributionMessage     = aliceSessionBuilder.create(GROUP_SENDER, 2);
+    FastRatchetSenderKeyDistributionMessage receivedAliceDistributionMessage = new FastRatchetSenderKeyDistributionMessage(sentAliceDistributionMessage.serialize());
+    bobSessionBuilder.process(GROUP_SENDER, receivedAliceDistributionMessage);
+
+    byte[] ciphertextFromAlice = aliceGroupCipher.encrypt("smert ze smert".getBytes());
+    byte[] plaintextFromAlice  = bobGroupCipher.decrypt(ciphertextFromAlice);
+
+    assertTrue(new String(plaintextFromAlice).equals("smert ze smert"));
+  }
+
+  public void testBasicRatchet()
+      throws LegacyMessageException, DuplicateMessageException, InvalidMessageException, NoSessionException
+  {
+    InMemoryFastRatchetSenderKeyStore aliceStore = new InMemoryFastRatchetSenderKeyStore();
+    InMemoryFastRatchetSenderKeyStore bobStore   = new InMemoryFastRatchetSenderKeyStore();
+
+    FastRatchetGroupSessionBuilder aliceSessionBuilder = new FastRatchetGroupSessionBuilder(aliceStore);
+    FastRatchetGroupSessionBuilder bobSessionBuilder   = new FastRatchetGroupSessionBuilder(bobStore);
+
+    SenderKeyName aliceName = GROUP_SENDER;
+
+    FastRatchetGroupCipher aliceGroupCipher = new FastRatchetGroupCipher(aliceStore, aliceName);
+    FastRatchetGroupCipher bobGroupCipher   = new FastRatchetGroupCipher(bobStore, aliceName);
+
+    FastRatchetSenderKeyDistributionMessage sentAliceDistributionMessage =
+        aliceSessionBuilder.create(aliceName, 2);
+    FastRatchetSenderKeyDistributionMessage receivedAliceDistributionMessage =
+        new FastRatchetSenderKeyDistributionMessage(sentAliceDistributionMessage.serialize());
+
+    bobSessionBuilder.process(aliceName, receivedAliceDistributionMessage);
+
+    byte[] ciphertextFromAlice  = aliceGroupCipher.encrypt("smert ze smert".getBytes());
+    byte[] ciphertextFromAlice2 = aliceGroupCipher.encrypt("smert ze smert2".getBytes());
+    byte[] ciphertextFromAlice3 = aliceGroupCipher.encrypt("smert ze smert3".getBytes());
+
+    byte[] plaintextFromAlice = bobGroupCipher.decrypt(ciphertextFromAlice);
+
+    try {
+      bobGroupCipher.decrypt(ciphertextFromAlice);
+      throw new AssertionError("Should have ratcheted forward!");
+    } catch (DuplicateMessageException dme) {
+      // good
+    }
+
+    byte[] plaintextFromAlice2 = bobGroupCipher.decrypt(ciphertextFromAlice2);
+    byte[] plaintextFromAlice3 = bobGroupCipher.decrypt(ciphertextFromAlice3);
+
+    assertTrue(new String(plaintextFromAlice).equals("smert ze smert"));
+    assertTrue(new String(plaintextFromAlice2).equals("smert ze smert2"));
+    assertTrue(new String(plaintextFromAlice3).equals("smert ze smert3"));
+  }
+
+  public void testLateJoin() throws NoSessionException, InvalidMessageException, LegacyMessageException, DuplicateMessageException {
+    InMemoryFastRatchetSenderKeyStore aliceStore = new InMemoryFastRatchetSenderKeyStore();
+    InMemoryFastRatchetSenderKeyStore bobStore   = new InMemoryFastRatchetSenderKeyStore();
+
+    FastRatchetGroupSessionBuilder aliceSessionBuilder = new FastRatchetGroupSessionBuilder(aliceStore);
+
+
+    SenderKeyName aliceName = GROUP_SENDER;
+    int           scale     = 3;
+
+    FastRatchetGroupCipher aliceGroupCipher = new FastRatchetGroupCipher(aliceStore, aliceName);
+
+    FastRatchetSenderKeyDistributionMessage aliceDistributionMessage = aliceSessionBuilder.create(aliceName, scale);
+    // Send off to some people.
+
+    for (int i = 0; i < 100; i++) {
+      aliceGroupCipher.encrypt("up the punks up the punks up the punks".getBytes());
+    }
+
+    // Now Bob Joins.
+    FastRatchetGroupSessionBuilder bobSessionBuilder = new FastRatchetGroupSessionBuilder(bobStore);
+    FastRatchetGroupCipher         bobGroupCipher    = new FastRatchetGroupCipher(bobStore, aliceName);
+
+
+    FastRatchetSenderKeyDistributionMessage distributionMessageToBob = aliceSessionBuilder.create(aliceName, scale);
+    bobSessionBuilder.process(aliceName, new FastRatchetSenderKeyDistributionMessage(distributionMessageToBob.serialize()));
+
+    byte[] ciphertext = aliceGroupCipher.encrypt("welcome to the group".getBytes());
+    byte[] plaintext  = bobGroupCipher.decrypt(ciphertext);
+
+    assertEquals(new String(plaintext), "welcome to the group");
+  }
+
+  public void testOutOfOrderUnsupported()
+      throws LegacyMessageException, DuplicateMessageException, InvalidMessageException, NoSessionException
+  {
+    InMemoryFastRatchetSenderKeyStore aliceStore = new InMemoryFastRatchetSenderKeyStore();
+    InMemoryFastRatchetSenderKeyStore bobStore   = new InMemoryFastRatchetSenderKeyStore();
+
+    FastRatchetGroupSessionBuilder aliceSessionBuilder = new FastRatchetGroupSessionBuilder(aliceStore);
+    FastRatchetGroupSessionBuilder bobSessionBuilder   = new FastRatchetGroupSessionBuilder(bobStore);
+
+    SenderKeyName aliceName = GROUP_SENDER;
+
+    FastRatchetGroupCipher aliceGroupCipher = new FastRatchetGroupCipher(aliceStore, aliceName);
+    FastRatchetGroupCipher bobGroupCipher   = new FastRatchetGroupCipher(bobStore, aliceName);
+
+    FastRatchetSenderKeyDistributionMessage aliceDistributionMessage =
+        aliceSessionBuilder.create(aliceName, 3);
+
+    bobSessionBuilder.process(aliceName, aliceDistributionMessage);
+
+    byte[] ciphertext1 = aliceGroupCipher.encrypt("up the punks1".getBytes());
+    byte[] ciphertext2 = aliceGroupCipher.encrypt("up the punks2".getBytes());
+    byte[] ciphertext3 = aliceGroupCipher.encrypt("up the punks3".getBytes());
+    byte[] ciphertext4 = aliceGroupCipher.encrypt("up the punks4".getBytes());
+
+    byte[] plaintextFromAlice2 = bobGroupCipher.decrypt(ciphertext2);
+
+    try {
+      bobGroupCipher.decrypt(ciphertext1);
+      throw new AssertionError("Should have failed!");
+    } catch (DuplicateMessageException e) {
+      // good
+    }
+
+    byte[] plaintextFromAlice4 = bobGroupCipher.decrypt(ciphertext4);
+
+    try {
+      bobGroupCipher.decrypt(ciphertext3);
+      throw new AssertionError("Should have failed!");
+    } catch (DuplicateMessageException e) {
+      // good
+    }
+
+    assertTrue(new String(plaintextFromAlice2).equals("up the punks2"));
+    assertTrue(new String(plaintextFromAlice4).equals("up the punks4"));
+
+  }
+
+  public void testEncryptWithLossyDecrypt()
+      throws LegacyMessageException, DuplicateMessageException, InvalidMessageException, NoSessionException, InvalidKeyIdException
+  {
+    runEncryptWithLossyDecrypt(0, 1, 2, 10);
+    runEncryptWithLossyDecrypt(1, 10, 20, 30);
+    runEncryptWithLossyDecrypt(2, 100, 100, 100);
+    runEncryptWithLossyDecrypt(3, 16, 48, 18);
+    runEncryptWithLossyDecrypt(4, 99, 14, 6);
+    runEncryptWithLossyDecrypt(5, 126, 1, 1);
+  }
+
+  private void runEncryptWithLossyDecrypt(int scale, int skip1, int skip2, int skip3) throws InvalidMessageException, LegacyMessageException, NoSessionException, DuplicateMessageException, InvalidKeyIdException {
+    InMemoryFastRatchetSenderKeyStore aliceStore = new InMemoryFastRatchetSenderKeyStore();
+    InMemoryFastRatchetSenderKeyStore bobStore   = new InMemoryFastRatchetSenderKeyStore();
+
+    FastRatchetGroupSessionBuilder aliceSessionBuilder = new FastRatchetGroupSessionBuilder(aliceStore);
+    FastRatchetGroupSessionBuilder bobSessionBuilder   = new FastRatchetGroupSessionBuilder(bobStore);
+
+    FastRatchetGroupCipher aliceGroupCipher = new FastRatchetGroupCipher(aliceStore, GROUP_SENDER);
+    FastRatchetGroupCipher bobGroupCipher   = new FastRatchetGroupCipher(bobStore, GROUP_SENDER);
+
+    FastRatchetSenderKeyDistributionMessage sentAliceDistributionMessage     = aliceSessionBuilder.create(GROUP_SENDER, scale);
+    FastRatchetSenderKeyDistributionMessage receivedAliceDistributionMessage = new FastRatchetSenderKeyDistributionMessage(sentAliceDistributionMessage.serialize());
+    bobSessionBuilder.process(GROUP_SENDER, receivedAliceDistributionMessage);
+
+    int expectedIteration = 0;
+
+    // Encrypt a series of messages, only retaining a few of them
+    for (int i = 0; i < skip1; i++) {
+      aliceGroupCipher.encrypt("missed smert ze smert".getBytes());
+    }
+
+    byte[] ciphertextFromAlice = aliceGroupCipher.encrypt("smert ze smert".getBytes());
+    expectedIteration += skip1 + 1;
+
+    for (int i = 0; i < skip2; i++) {
+      aliceGroupCipher.encrypt("missed smert ze smert".getBytes());
+    }
+
+    byte[] ciphertextFromAlice2 = aliceGroupCipher.encrypt("smert ze smert2".getBytes());
+    expectedIteration += skip2 + 1;
+
+    for (int i = 0; i < skip3; i++) {
+      aliceGroupCipher.encrypt("missed smert ze smert".getBytes());
+    }
+
+    byte[] ciphertextFromAlice3 = aliceGroupCipher.encrypt("smert ze smert3".getBytes());
+    expectedIteration += skip3 + 1;
+
+    // Verify that the sender is on the expected iteration
+    FastRatchetSenderKeyRecord aliceRecord = aliceStore.loadFastRatchetSenderKey(GROUP_SENDER);
+    FastRatchetSenderKeyState  aliceState  = aliceRecord.getSenderKeyState();
+    assertEquals(expectedIteration, aliceState.getSenderChainKey().getIteration());
+
+    // Decrypt the few messages we retained
+    byte[] plaintextFromAlice  = bobGroupCipher.decrypt(ciphertextFromAlice);
+    byte[] plaintextFromAlice2 = bobGroupCipher.decrypt(ciphertextFromAlice2);
+    byte[] plaintextFromAlice3 = bobGroupCipher.decrypt(ciphertextFromAlice3);
+
+    assertTrue(new String(plaintextFromAlice).equals("smert ze smert"));
+    assertTrue(new String(plaintextFromAlice2).equals("smert ze smert2"));
+    assertTrue(new String(plaintextFromAlice3).equals("smert ze smert3"));
+
+    // Verify that receiver is also on the expected iteration
+    FastRatchetSenderKeyRecord bobRecord = bobStore.loadFastRatchetSenderKey(GROUP_SENDER);
+    FastRatchetSenderKeyState  bobState  = bobRecord.getSenderKeyState();
+    assertEquals(expectedIteration, bobState.getSenderChainKey().getIteration());
+  }
+
+  public void testInitialSingleChainState() {
+    byte[]                    initialSeed = KeyHelper.generateSenderKey();
+    FastRatchetSenderChainKey chainKey    = new FastRatchetSenderChainKey(initialSeed, 0);
+
+    assertEquals(0, chainKey.getIteration());
+
+    byte[][] seeds = chainKey.getSeeds();
+    assertEquals(1, seeds.length);
+    assertTrue(Arrays.equals(initialSeed, seeds[0]));
+  }
+
+  public void testInitialMultiChainState() {
+    byte[] initialSeed = KeyHelper.generateSenderKey();
+
+    for (int i = 1; i <= 5; i++) {
+      FastRatchetSenderChainKey chainKey       = new FastRatchetSenderChainKey(initialSeed, i);
+      int                       expectedChains = FastRatchetUtil.scaleToDimensions(i);
+
+      assertEquals(0, chainKey.getIteration());
+
+      byte[][] chainSeeds = chainKey.getDerivedSeeds();
+
+      assertEquals(expectedChains, chainSeeds.length);
+
+      for (int j = 0; j < expectedChains; j++) {
+        assertFalse(Arrays.equals(initialSeed, chainSeeds[j]));
+      }
+    }
+  }
+
+  public void testInitialChainState() {
+    byte[] initialSeed = KeyHelper.generateSenderKey();
+
+    // Create the expected chains
+    byte[] CK1 = initialSeed;
+    byte[] CK2;
+    byte[] CK3;
+    byte[] CK4;
+
+    CK2 = HmacSHA256(new byte[] {0x03}, CK1);
+    CK1 = HmacSHA256(new byte[] {0x02}, CK1);
+
+    CK3 = HmacSHA256(new byte[] {0x04}, CK2);
+    CK2 = HmacSHA256(new byte[] {0x03}, CK2);
+
+    CK4 = HmacSHA256(new byte[] {0x05}, CK3);
+    CK3 = HmacSHA256(new byte[] {0x04}, CK3);
+
+    // Compute and verify the actual chains
+    FastRatchetSenderChainKey chainKey = new FastRatchetSenderChainKey(initialSeed, 2);
+
+    assertEquals(0, chainKey.getIteration());
+
+    byte[][] seeds = chainKey.getDerivedSeeds();
+    assertEquals(4, seeds.length);
+    MoreAsserts.assertEquals(CK1, seeds[0]);
+    MoreAsserts.assertEquals(CK2, seeds[1]);
+    MoreAsserts.assertEquals(CK3, seeds[2]);
+    MoreAsserts.assertEquals(CK4, seeds[3]);
+  }
+
+  public void testIntermediateRatchet() {
+    byte[] CK1 = KeyHelper.generateSenderKey();
+    byte[] CK2 = KeyHelper.generateSenderKey();
+    byte[] CK3 = KeyHelper.generateSenderKey();
+    byte[] CK4 = KeyHelper.generateSenderKey();
+
+    int initialIteration = 356;
+    int finalIteration   = 66306;
+
+    FastRatchetSenderChainKey chainKey = new FastRatchetSenderChainKey(
+        initialIteration, new byte[][] {CK1, CK2, CK3, CK4});
+
+    // Create the expected chain operation results
+    // New CK3 from CK2
+    CK3 = HmacSHA256(new byte[] {0x04}, CK2);
+
+    // Ratchet CK2
+    CK2 = HmacSHA256(new byte[] {0x03}, CK2);
+
+    // Ratchet CK3
+    CK3 = HmacSHA256(new byte[] {0x04}, CK3);
+    CK3 = HmacSHA256(new byte[] {0x04}, CK3);
+    CK3 = HmacSHA256(new byte[] {0x04}, CK3);
+
+    // New CK4 from CK3
+    CK4 = HmacSHA256(new byte[] {0x05}, CK3);
+
+    // Ratchet CK3 one last time
+    CK3 = HmacSHA256(new byte[] {0x04}, CK3);
+
+    // Ratchet CK4
+    CK4 = HmacSHA256(new byte[] {0x05}, CK4);
+    CK4 = HmacSHA256(new byte[] {0x05}, CK4);
+
+    // Compare to the actual results
+    FastRatchetSenderChainKey finalKey = chainKey.getNext(finalIteration - initialIteration);
+
+    assertEquals(finalIteration, finalKey.getIteration());
+
+    byte[][] seeds = finalKey.getSeeds();
+    assertEquals(4, seeds.length);
+    MoreAsserts.assertEquals(CK1, seeds[0]);
+    MoreAsserts.assertEquals(CK2, seeds[1]);
+    MoreAsserts.assertEquals(CK3, seeds[2]);
+    MoreAsserts.assertEquals(CK4, seeds[3]);
+  }
+
+  public void testLargeScaleRatchet() {
+    byte[] CK1  = KeyHelper.generateSenderKey();
+    byte[] CK2  = KeyHelper.generateSenderKey();
+    byte[] CK3  = KeyHelper.generateSenderKey();
+    byte[] CK4  = KeyHelper.generateSenderKey();
+    byte[] CK5  = KeyHelper.generateSenderKey();
+    byte[] CK6  = KeyHelper.generateSenderKey();
+    byte[] CK7  = KeyHelper.generateSenderKey();
+    byte[] CK8  = KeyHelper.generateSenderKey();
+    byte[] CK9  = KeyHelper.generateSenderKey();
+    byte[] CK10 = KeyHelper.generateSenderKey();
+    byte[] CK11 = KeyHelper.generateSenderKey();
+    byte[] CK12 = KeyHelper.generateSenderKey();
+    byte[] CK13 = KeyHelper.generateSenderKey();
+    byte[] CK14 = KeyHelper.generateSenderKey();
+    byte[] CK15 = KeyHelper.generateSenderKey();
+    byte[] CK16 = KeyHelper.generateSenderKey();
+
+    int initialIteration = 0;
+    int finalIteration   = 85;
+
+    FastRatchetSenderChainKey chainKey = new FastRatchetSenderChainKey(
+        initialIteration, new byte[][] {
+        CK1, CK2, CK3, CK4, CK5, CK6, CK7, CK8,
+        CK9, CK10, CK11, CK12, CK13, CK14, CK15, CK16});
+
+    // Create the expected chain operation results
+    // CK:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
+    // From: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
+    // To:   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1]
+
+    // New CK14 from CK13
+    CK14 = HmacSHA256(new byte[] {0x0F}, CK13);
+
+    // Ratchet CK13
+    CK13 = HmacSHA256(new byte[] {0x0E}, CK13);
+
+    // Ratchet CK14
+    CK14 = HmacSHA256(new byte[] {0x0F}, CK14);
+
+    // New CK15 from CK14
+    CK15 = HmacSHA256(new byte[] {0x10}, CK14);
+
+    // Ratchet CK14 one last time
+    CK14 = HmacSHA256(new byte[] {0x0F}, CK14);
+
+    // Ratchet CK15
+    CK15 = HmacSHA256(new byte[] {0x10}, CK15);
+
+    // New CK16 from CK15
+    CK16 = HmacSHA256(new byte[] {0x11}, CK15);
+
+    // Ratchet CK15 one last time
+    CK15 = HmacSHA256(new byte[] {0x10}, CK15);
+
+    // Ratchet CK16
+    CK16 = HmacSHA256(new byte[] {0x11}, CK16);
+
+    // Compare to the actual results
+    FastRatchetSenderChainKey finalKey = chainKey.getNext(finalIteration - initialIteration);
+
+    assertEquals(finalIteration, finalKey.getIteration());
+
+    byte[][] seeds = finalKey.getSeeds();
+    assertEquals(16, seeds.length);
+    MoreAsserts.assertEquals(CK1, seeds[0]);
+    MoreAsserts.assertEquals(CK2, seeds[1]);
+    MoreAsserts.assertEquals(CK3, seeds[2]);
+    MoreAsserts.assertEquals(CK4, seeds[3]);
+    MoreAsserts.assertEquals(CK5, seeds[4]);
+    MoreAsserts.assertEquals(CK6, seeds[5]);
+    MoreAsserts.assertEquals(CK7, seeds[6]);
+    MoreAsserts.assertEquals(CK8, seeds[7]);
+    MoreAsserts.assertEquals(CK9, seeds[8]);
+    MoreAsserts.assertEquals(CK10, seeds[9]);
+    MoreAsserts.assertEquals(CK11, seeds[10]);
+    MoreAsserts.assertEquals(CK12, seeds[11]);
+    MoreAsserts.assertEquals(CK13, seeds[12]);
+    MoreAsserts.assertEquals(CK14, seeds[13]);
+    MoreAsserts.assertEquals(CK15, seeds[14]);
+    MoreAsserts.assertEquals(CK16, seeds[15]);
+  }
+
+  public void testLargeScaleRatchetWithRollover() {
+    byte[] CK1  = KeyHelper.generateSenderKey();
+    byte[] CK2  = KeyHelper.generateSenderKey();
+    byte[] CK3  = KeyHelper.generateSenderKey();
+    byte[] CK4  = KeyHelper.generateSenderKey();
+    byte[] CK5  = KeyHelper.generateSenderKey();
+    byte[] CK6  = KeyHelper.generateSenderKey();
+    byte[] CK7  = KeyHelper.generateSenderKey();
+    byte[] CK8  = KeyHelper.generateSenderKey();
+    byte[] CK9  = KeyHelper.generateSenderKey();
+    byte[] CK10 = KeyHelper.generateSenderKey();
+    byte[] CK11 = KeyHelper.generateSenderKey();
+    byte[] CK12 = KeyHelper.generateSenderKey();
+    byte[] CK13 = KeyHelper.generateSenderKey();
+    byte[] CK14 = KeyHelper.generateSenderKey();
+    byte[] CK15 = KeyHelper.generateSenderKey();
+    byte[] CK16 = KeyHelper.generateSenderKey();
+
+    int initialIteration = 0;
+    int finalIteration   = 174;
+
+    FastRatchetSenderChainKey chainKey = new FastRatchetSenderChainKey(
+        initialIteration, new byte[][] {
+        CK1, CK2, CK3, CK4, CK5, CK6, CK7, CK8,
+        CK9, CK10, CK11, CK12, CK13, CK14, CK15, CK16});
+
+    // Create the expected chain operation results
+    // CK:    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16
+    // From: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
+    // To:   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 3, 4, 2]
+
+    // Ratchet CK13
+    CK13 = HmacSHA256(new byte[] {0x0E}, CK13);
+
+    // New CK14 from CK13
+    CK14 = HmacSHA256(new byte[] {0x0F}, CK13);
+
+    // Ratchet CK13
+    CK13 = HmacSHA256(new byte[] {0x0E}, CK13);
+
+    // Ratchet CK14 twice
+    CK14 = HmacSHA256(new byte[] {0x0F}, CK14);
+    CK14 = HmacSHA256(new byte[] {0x0F}, CK14);
+
+    // New CK15 from CK14
+    CK15 = HmacSHA256(new byte[] {0x10}, CK14);
+
+    // Ratchet CK14
+    CK14 = HmacSHA256(new byte[] {0x0F}, CK14);
+
+    // Ratchet CK15 three times
+    CK15 = HmacSHA256(new byte[] {0x10}, CK15);
+    CK15 = HmacSHA256(new byte[] {0x10}, CK15);
+    CK15 = HmacSHA256(new byte[] {0x10}, CK15);
+
+    // New CK16 from CK15
+    CK16 = HmacSHA256(new byte[] {0x11}, CK15);
+
+    // Ratchet CK15
+    CK15 = HmacSHA256(new byte[] {0x10}, CK15);
+
+    // Ratchet CK16 twice
+    CK16 = HmacSHA256(new byte[] {0x11}, CK16);
+    CK16 = HmacSHA256(new byte[] {0x11}, CK16);
+
+    // Compare to the actual results
+    FastRatchetSenderChainKey finalKey = chainKey.getNext(finalIteration - initialIteration);
+
+    assertEquals(finalIteration, finalKey.getIteration());
+
+    byte[][] seeds = finalKey.getSeeds();
+    assertEquals(16, seeds.length);
+    MoreAsserts.assertEquals(CK1, seeds[0]);
+    MoreAsserts.assertEquals(CK2, seeds[1]);
+    MoreAsserts.assertEquals(CK3, seeds[2]);
+    MoreAsserts.assertEquals(CK4, seeds[3]);
+    MoreAsserts.assertEquals(CK5, seeds[4]);
+    MoreAsserts.assertEquals(CK6, seeds[5]);
+    MoreAsserts.assertEquals(CK7, seeds[6]);
+    MoreAsserts.assertEquals(CK8, seeds[7]);
+    MoreAsserts.assertEquals(CK9, seeds[8]);
+    MoreAsserts.assertEquals(CK10, seeds[9]);
+    MoreAsserts.assertEquals(CK11, seeds[10]);
+    MoreAsserts.assertEquals(CK12, seeds[11]);
+    MoreAsserts.assertEquals(CK13, seeds[12]);
+    MoreAsserts.assertEquals(CK14, seeds[13]);
+    MoreAsserts.assertEquals(CK15, seeds[14]);
+    MoreAsserts.assertEquals(CK16, seeds[15]);
+  }
+
+  public void testDistributionMessageSizes()
+      throws LegacyMessageException, DuplicateMessageException, InvalidMessageException, NoSessionException
+  {
+    InMemoryFastRatchetSenderKeyStore aliceStore = new InMemoryFastRatchetSenderKeyStore();
+    FastRatchetGroupSessionBuilder aliceSessionBuilder = new FastRatchetGroupSessionBuilder(aliceStore);
+    FastRatchetGroupCipher aliceGroupCipher = new FastRatchetGroupCipher(aliceStore, GROUP_SENDER);
+
+    FastRatchetSenderKeyDistributionMessage distributionMessage = aliceSessionBuilder.create(GROUP_SENDER, 2);
+    byte[] distribution0 = distributionMessage.serialize();
+
+    aliceGroupCipher.encrypt("smert ze smert".getBytes());
+
+    distributionMessage = aliceSessionBuilder.create(GROUP_SENDER, 2);
+
+    byte[] distribution1 = distributionMessage.serialize();
+
+    aliceGroupCipher.encrypt("smert ze smert".getBytes());
+
+    byte[] distribution2 = distributionMessage.serialize();
+
+    assertTrue(distribution0.length < distribution1.length);
+    assertEquals(distribution1.length, distribution2.length);
+  }
+
+  private static byte[] HmacSHA256(byte[] seed, byte[] key) {
+    try {
+      Mac mac = Mac.getInstance("HmacSHA256");
+      mac.init(new SecretKeySpec(key, "HmacSHA256"));
+
+      return mac.doFinal(seed);
+    } catch (NoSuchAlgorithmException | InvalidKeyException e) {
+      throw new AssertionError(e);
+    }
+  }
+
+}
diff --git a/tests/src/test/java/org/whispersystems/libsignal/groups/InMemoryFastRatchetSenderKeyStore.java b/tests/src/test/java/org/whispersystems/libsignal/groups/InMemoryFastRatchetSenderKeyStore.java
new file mode 100644
index 0000000..642ba02
--- /dev/null
+++ b/tests/src/test/java/org/whispersystems/libsignal/groups/InMemoryFastRatchetSenderKeyStore.java
@@ -0,0 +1,33 @@
+package org.whispersystems.libsignal.groups;
+
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyRecord;
+import org.whispersystems.libsignal.groups.state.FastRatchetSenderKeyStore;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+public class InMemoryFastRatchetSenderKeyStore implements FastRatchetSenderKeyStore {
+
+  private final Map<SenderKeyName, FastRatchetSenderKeyRecord> store = new HashMap<>();
+
+  @Override
+  public void storeFastRatchetSenderKey(SenderKeyName senderKeyName, FastRatchetSenderKeyRecord record) {
+    store.put(senderKeyName, record);
+  }
+
+  @Override
+  public FastRatchetSenderKeyRecord loadFastRatchetSenderKey(SenderKeyName senderKeyName) {
+    try {
+      FastRatchetSenderKeyRecord record = store.get(senderKeyName);
+
+      if (record == null) {
+        return new FastRatchetSenderKeyRecord();
+      } else {
+        return new FastRatchetSenderKeyRecord(record.serialize());
+      }
+    } catch (IOException e) {
+      throw new AssertionError(e);
+    }
+  }
+}
diff --git a/tests/src/test/java/org/whispersystems/libsignal/util/FastRatchetUtilTest.java b/tests/src/test/java/org/whispersystems/libsignal/util/FastRatchetUtilTest.java
new file mode 100644
index 0000000..6ec4fd7
--- /dev/null
+++ b/tests/src/test/java/org/whispersystems/libsignal/util/FastRatchetUtilTest.java
@@ -0,0 +1,60 @@
+package org.whispersystems.libsignal.util;
+
+import android.test.MoreAsserts;
+
+import junit.framework.TestCase;
+
+public class FastRatchetUtilTest extends TestCase {
+
+  public void testComposeIterationScale0() {
+    assertEquals(0, FastRatchetUtil.composeIterations(new int[] {0x00}));
+    assertEquals(1, FastRatchetUtil.composeIterations(new int[] {0x01}));
+  }
+
+  public void testComposeIterationScale4() {
+    assertEquals(4, FastRatchetUtil.composeIterations(new int[] {0x00, 0x00, 0x00, 0x04}));
+    assertEquals(772, FastRatchetUtil.composeIterations(new int[] {0x00, 0x00, 0x03, 0x04}));
+    assertEquals(131844, FastRatchetUtil.composeIterations(new int[] {0x00, 0x02, 0x03, 0x04}));
+    assertEquals(16909060, FastRatchetUtil.composeIterations(new int[] {0x01, 0x02, 0x03, 0x04}));
+    assertEquals(65280, FastRatchetUtil.composeIterations(new int[] {0x00, 0x00, 0xFF, 0x00}));
+  }
+
+  public void testDecomposeIterationScale0() {
+    MoreAsserts.assertEquals(new int[] {0x00}, FastRatchetUtil.decomposeIteration(0, 1));
+    MoreAsserts.assertEquals(new int[] {0x01}, FastRatchetUtil.decomposeIteration(1, 1));
+  }
+
+  public void testDecomposeIterationScale4() {
+    MoreAsserts.assertEquals(new int[] {0x00, 0x00, 0x00, 0x04}, FastRatchetUtil.decomposeIteration(4, 4));
+    MoreAsserts.assertEquals(new int[] {0x00, 0x00, 0x03, 0x04}, FastRatchetUtil.decomposeIteration(772, 4));
+    MoreAsserts.assertEquals(new int[] {0x00, 0x02, 0x03, 0x04}, FastRatchetUtil.decomposeIteration(131844, 4));
+    MoreAsserts.assertEquals(new int[] {0x01, 0x02, 0x03, 0x04}, FastRatchetUtil.decomposeIteration(16909060, 4));
+    MoreAsserts.assertEquals(new int[] {0x00, 0x00, 0xFF, 0x00}, FastRatchetUtil.decomposeIteration(65280, 4));
+  }
+
+  public void testComposeChainIterationsScale0() {
+    assertEquals(0, FastRatchetUtil.composeChainIterations(new int[] {0x00}));
+    assertEquals(1, FastRatchetUtil.composeChainIterations(new int[] {0x01}));
+  }
+
+  public void testComposeChainIterationsScale4() {
+    assertEquals(4, FastRatchetUtil.composeChainIterations(new int[] {0x01, 0x01, 0x01, 0x04}));
+    assertEquals(772, FastRatchetUtil.composeChainIterations(new int[] {0x01, 0x01, 0x04, 0x04}));
+    assertEquals(131844, FastRatchetUtil.composeChainIterations(new int[] {0x01, 0x03, 0x04, 0x04}));
+    assertEquals(16909060, FastRatchetUtil.composeChainIterations(new int[] {0x02, 0x03, 0x04, 0x04}));
+    assertEquals(65280, FastRatchetUtil.composeChainIterations(new int[] {0x01, 0x01, 0x100, 0x00}));
+  }
+
+  public void testDecomposeChainIterationsScale0() {
+    MoreAsserts.assertEquals(new int[] {0x00}, FastRatchetUtil.decomposeChainIterations(0, 1));
+    MoreAsserts.assertEquals(new int[] {0x01}, FastRatchetUtil.decomposeChainIterations(1, 1));
+  }
+
+  public void testDecomposeChainIterationsScale4() {
+    MoreAsserts.assertEquals(new int[] {0x01, 0x01, 0x01, 0x04}, FastRatchetUtil.decomposeChainIterations(4, 4));
+    MoreAsserts.assertEquals(new int[] {0x01, 0x01, 0x04, 0x04}, FastRatchetUtil.decomposeChainIterations(772, 4));
+    MoreAsserts.assertEquals(new int[] {0x01, 0x03, 0x04, 0x04}, FastRatchetUtil.decomposeChainIterations(131844, 4));
+    MoreAsserts.assertEquals(new int[] {0x02, 0x03, 0x04, 0x04}, FastRatchetUtil.decomposeChainIterations(16909060, 4));
+    MoreAsserts.assertEquals(new int[] {0x01, 0x01, 0x100, 0x00}, FastRatchetUtil.decomposeChainIterations(65280, 4));
+  }
+}
-- 
2.7.4

